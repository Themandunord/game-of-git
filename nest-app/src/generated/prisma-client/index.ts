// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  appKey: (where?: AppKeyWhereInput) => Promise<boolean>;
  game: (where?: GameWhereInput) => Promise<boolean>;
  gitHubBranch: (where?: GitHubBranchWhereInput) => Promise<boolean>;
  gitHubComment: (where?: GitHubCommentWhereInput) => Promise<boolean>;
  gitHubCommit: (where?: GitHubCommitWhereInput) => Promise<boolean>;
  gitHubFileDiff: (where?: GitHubFileDiffWhereInput) => Promise<boolean>;
  gitHubIssue: (where?: GitHubIssueWhereInput) => Promise<boolean>;
  gitHubLabel: (where?: GitHubLabelWhereInput) => Promise<boolean>;
  gitHubPullRequest: (where?: GitHubPullRequestWhereInput) => Promise<boolean>;
  gitHubPullRequestReview: (
    where?: GitHubPullRequestReviewWhereInput
  ) => Promise<boolean>;
  gitHubRepository: (where?: GitHubRepositoryWhereInput) => Promise<boolean>;
  gitHubReviewRequest: (
    where?: GitHubReviewRequestWhereInput
  ) => Promise<boolean>;
  gitHubReviewThread: (
    where?: GitHubReviewThreadWhereInput
  ) => Promise<boolean>;
  gitHubTopic: (where?: GitHubTopicWhereInput) => Promise<boolean>;
  gitHubUser: (where?: GitHubUserWhereInput) => Promise<boolean>;
  gitHubWebhookEvent: (
    where?: GitHubWebhookEventWhereInput
  ) => Promise<boolean>;
  post: (where?: PostWhereInput) => Promise<boolean>;
  repository: (where?: RepositoryWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  appKey: (where: AppKeyWhereUniqueInput) => AppKeyNullablePromise;
  appKeys: (args?: {
    where?: AppKeyWhereInput;
    orderBy?: AppKeyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<AppKey>;
  appKeysConnection: (args?: {
    where?: AppKeyWhereInput;
    orderBy?: AppKeyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AppKeyConnectionPromise;
  game: (where: GameWhereUniqueInput) => GameNullablePromise;
  games: (args?: {
    where?: GameWhereInput;
    orderBy?: GameOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Game>;
  gamesConnection: (args?: {
    where?: GameWhereInput;
    orderBy?: GameOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => GameConnectionPromise;
  gitHubBranch: (
    where: GitHubBranchWhereUniqueInput
  ) => GitHubBranchNullablePromise;
  gitHubBranches: (args?: {
    where?: GitHubBranchWhereInput;
    orderBy?: GitHubBranchOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<GitHubBranch>;
  gitHubBranchesConnection: (args?: {
    where?: GitHubBranchWhereInput;
    orderBy?: GitHubBranchOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => GitHubBranchConnectionPromise;
  gitHubComment: (
    where: GitHubCommentWhereUniqueInput
  ) => GitHubCommentNullablePromise;
  gitHubComments: (args?: {
    where?: GitHubCommentWhereInput;
    orderBy?: GitHubCommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<GitHubComment>;
  gitHubCommentsConnection: (args?: {
    where?: GitHubCommentWhereInput;
    orderBy?: GitHubCommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => GitHubCommentConnectionPromise;
  gitHubCommit: (
    where: GitHubCommitWhereUniqueInput
  ) => GitHubCommitNullablePromise;
  gitHubCommits: (args?: {
    where?: GitHubCommitWhereInput;
    orderBy?: GitHubCommitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<GitHubCommit>;
  gitHubCommitsConnection: (args?: {
    where?: GitHubCommitWhereInput;
    orderBy?: GitHubCommitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => GitHubCommitConnectionPromise;
  gitHubFileDiff: (
    where: GitHubFileDiffWhereUniqueInput
  ) => GitHubFileDiffNullablePromise;
  gitHubFileDiffs: (args?: {
    where?: GitHubFileDiffWhereInput;
    orderBy?: GitHubFileDiffOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<GitHubFileDiff>;
  gitHubFileDiffsConnection: (args?: {
    where?: GitHubFileDiffWhereInput;
    orderBy?: GitHubFileDiffOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => GitHubFileDiffConnectionPromise;
  gitHubIssue: (
    where: GitHubIssueWhereUniqueInput
  ) => GitHubIssueNullablePromise;
  gitHubIssues: (args?: {
    where?: GitHubIssueWhereInput;
    orderBy?: GitHubIssueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<GitHubIssue>;
  gitHubIssuesConnection: (args?: {
    where?: GitHubIssueWhereInput;
    orderBy?: GitHubIssueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => GitHubIssueConnectionPromise;
  gitHubLabel: (
    where: GitHubLabelWhereUniqueInput
  ) => GitHubLabelNullablePromise;
  gitHubLabels: (args?: {
    where?: GitHubLabelWhereInput;
    orderBy?: GitHubLabelOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<GitHubLabel>;
  gitHubLabelsConnection: (args?: {
    where?: GitHubLabelWhereInput;
    orderBy?: GitHubLabelOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => GitHubLabelConnectionPromise;
  gitHubPullRequest: (
    where: GitHubPullRequestWhereUniqueInput
  ) => GitHubPullRequestNullablePromise;
  gitHubPullRequests: (args?: {
    where?: GitHubPullRequestWhereInput;
    orderBy?: GitHubPullRequestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<GitHubPullRequest>;
  gitHubPullRequestsConnection: (args?: {
    where?: GitHubPullRequestWhereInput;
    orderBy?: GitHubPullRequestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => GitHubPullRequestConnectionPromise;
  gitHubPullRequestReview: (
    where: GitHubPullRequestReviewWhereUniqueInput
  ) => GitHubPullRequestReviewNullablePromise;
  gitHubPullRequestReviews: (args?: {
    where?: GitHubPullRequestReviewWhereInput;
    orderBy?: GitHubPullRequestReviewOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<GitHubPullRequestReview>;
  gitHubPullRequestReviewsConnection: (args?: {
    where?: GitHubPullRequestReviewWhereInput;
    orderBy?: GitHubPullRequestReviewOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => GitHubPullRequestReviewConnectionPromise;
  gitHubRepository: (
    where: GitHubRepositoryWhereUniqueInput
  ) => GitHubRepositoryNullablePromise;
  gitHubRepositories: (args?: {
    where?: GitHubRepositoryWhereInput;
    orderBy?: GitHubRepositoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<GitHubRepository>;
  gitHubRepositoriesConnection: (args?: {
    where?: GitHubRepositoryWhereInput;
    orderBy?: GitHubRepositoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => GitHubRepositoryConnectionPromise;
  gitHubReviewRequest: (
    where: GitHubReviewRequestWhereUniqueInput
  ) => GitHubReviewRequestNullablePromise;
  gitHubReviewRequests: (args?: {
    where?: GitHubReviewRequestWhereInput;
    orderBy?: GitHubReviewRequestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<GitHubReviewRequest>;
  gitHubReviewRequestsConnection: (args?: {
    where?: GitHubReviewRequestWhereInput;
    orderBy?: GitHubReviewRequestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => GitHubReviewRequestConnectionPromise;
  gitHubReviewThread: (
    where: GitHubReviewThreadWhereUniqueInput
  ) => GitHubReviewThreadNullablePromise;
  gitHubReviewThreads: (args?: {
    where?: GitHubReviewThreadWhereInput;
    orderBy?: GitHubReviewThreadOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<GitHubReviewThread>;
  gitHubReviewThreadsConnection: (args?: {
    where?: GitHubReviewThreadWhereInput;
    orderBy?: GitHubReviewThreadOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => GitHubReviewThreadConnectionPromise;
  gitHubTopic: (
    where: GitHubTopicWhereUniqueInput
  ) => GitHubTopicNullablePromise;
  gitHubTopics: (args?: {
    where?: GitHubTopicWhereInput;
    orderBy?: GitHubTopicOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<GitHubTopic>;
  gitHubTopicsConnection: (args?: {
    where?: GitHubTopicWhereInput;
    orderBy?: GitHubTopicOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => GitHubTopicConnectionPromise;
  gitHubUser: (where: GitHubUserWhereUniqueInput) => GitHubUserNullablePromise;
  gitHubUsers: (args?: {
    where?: GitHubUserWhereInput;
    orderBy?: GitHubUserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<GitHubUser>;
  gitHubUsersConnection: (args?: {
    where?: GitHubUserWhereInput;
    orderBy?: GitHubUserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => GitHubUserConnectionPromise;
  gitHubWebhookEvent: (
    where: GitHubWebhookEventWhereUniqueInput
  ) => GitHubWebhookEventNullablePromise;
  gitHubWebhookEvents: (args?: {
    where?: GitHubWebhookEventWhereInput;
    orderBy?: GitHubWebhookEventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<GitHubWebhookEvent>;
  gitHubWebhookEventsConnection: (args?: {
    where?: GitHubWebhookEventWhereInput;
    orderBy?: GitHubWebhookEventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => GitHubWebhookEventConnectionPromise;
  post: (where: PostWhereUniqueInput) => PostNullablePromise;
  posts: (args?: {
    where?: PostWhereInput;
    orderBy?: PostOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Post>;
  postsConnection: (args?: {
    where?: PostWhereInput;
    orderBy?: PostOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PostConnectionPromise;
  repository: (where: RepositoryWhereUniqueInput) => RepositoryNullablePromise;
  repositories: (args?: {
    where?: RepositoryWhereInput;
    orderBy?: RepositoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Repository>;
  repositoriesConnection: (args?: {
    where?: RepositoryWhereInput;
    orderBy?: RepositoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => RepositoryConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createAppKey: (data: AppKeyCreateInput) => AppKeyPromise;
  updateAppKey: (args: {
    data: AppKeyUpdateInput;
    where: AppKeyWhereUniqueInput;
  }) => AppKeyPromise;
  updateManyAppKeys: (args: {
    data: AppKeyUpdateManyMutationInput;
    where?: AppKeyWhereInput;
  }) => BatchPayloadPromise;
  upsertAppKey: (args: {
    where: AppKeyWhereUniqueInput;
    create: AppKeyCreateInput;
    update: AppKeyUpdateInput;
  }) => AppKeyPromise;
  deleteAppKey: (where: AppKeyWhereUniqueInput) => AppKeyPromise;
  deleteManyAppKeys: (where?: AppKeyWhereInput) => BatchPayloadPromise;
  createGame: (data: GameCreateInput) => GamePromise;
  updateGame: (args: {
    data: GameUpdateInput;
    where: GameWhereUniqueInput;
  }) => GamePromise;
  updateManyGames: (args: {
    data: GameUpdateManyMutationInput;
    where?: GameWhereInput;
  }) => BatchPayloadPromise;
  upsertGame: (args: {
    where: GameWhereUniqueInput;
    create: GameCreateInput;
    update: GameUpdateInput;
  }) => GamePromise;
  deleteGame: (where: GameWhereUniqueInput) => GamePromise;
  deleteManyGames: (where?: GameWhereInput) => BatchPayloadPromise;
  createGitHubBranch: (data: GitHubBranchCreateInput) => GitHubBranchPromise;
  updateGitHubBranch: (args: {
    data: GitHubBranchUpdateInput;
    where: GitHubBranchWhereUniqueInput;
  }) => GitHubBranchPromise;
  updateManyGitHubBranches: (args: {
    data: GitHubBranchUpdateManyMutationInput;
    where?: GitHubBranchWhereInput;
  }) => BatchPayloadPromise;
  upsertGitHubBranch: (args: {
    where: GitHubBranchWhereUniqueInput;
    create: GitHubBranchCreateInput;
    update: GitHubBranchUpdateInput;
  }) => GitHubBranchPromise;
  deleteGitHubBranch: (
    where: GitHubBranchWhereUniqueInput
  ) => GitHubBranchPromise;
  deleteManyGitHubBranches: (
    where?: GitHubBranchWhereInput
  ) => BatchPayloadPromise;
  createGitHubComment: (data: GitHubCommentCreateInput) => GitHubCommentPromise;
  updateGitHubComment: (args: {
    data: GitHubCommentUpdateInput;
    where: GitHubCommentWhereUniqueInput;
  }) => GitHubCommentPromise;
  updateManyGitHubComments: (args: {
    data: GitHubCommentUpdateManyMutationInput;
    where?: GitHubCommentWhereInput;
  }) => BatchPayloadPromise;
  upsertGitHubComment: (args: {
    where: GitHubCommentWhereUniqueInput;
    create: GitHubCommentCreateInput;
    update: GitHubCommentUpdateInput;
  }) => GitHubCommentPromise;
  deleteGitHubComment: (
    where: GitHubCommentWhereUniqueInput
  ) => GitHubCommentPromise;
  deleteManyGitHubComments: (
    where?: GitHubCommentWhereInput
  ) => BatchPayloadPromise;
  createGitHubCommit: (data: GitHubCommitCreateInput) => GitHubCommitPromise;
  updateGitHubCommit: (args: {
    data: GitHubCommitUpdateInput;
    where: GitHubCommitWhereUniqueInput;
  }) => GitHubCommitPromise;
  updateManyGitHubCommits: (args: {
    data: GitHubCommitUpdateManyMutationInput;
    where?: GitHubCommitWhereInput;
  }) => BatchPayloadPromise;
  upsertGitHubCommit: (args: {
    where: GitHubCommitWhereUniqueInput;
    create: GitHubCommitCreateInput;
    update: GitHubCommitUpdateInput;
  }) => GitHubCommitPromise;
  deleteGitHubCommit: (
    where: GitHubCommitWhereUniqueInput
  ) => GitHubCommitPromise;
  deleteManyGitHubCommits: (
    where?: GitHubCommitWhereInput
  ) => BatchPayloadPromise;
  createGitHubFileDiff: (
    data: GitHubFileDiffCreateInput
  ) => GitHubFileDiffPromise;
  updateGitHubFileDiff: (args: {
    data: GitHubFileDiffUpdateInput;
    where: GitHubFileDiffWhereUniqueInput;
  }) => GitHubFileDiffPromise;
  updateManyGitHubFileDiffs: (args: {
    data: GitHubFileDiffUpdateManyMutationInput;
    where?: GitHubFileDiffWhereInput;
  }) => BatchPayloadPromise;
  upsertGitHubFileDiff: (args: {
    where: GitHubFileDiffWhereUniqueInput;
    create: GitHubFileDiffCreateInput;
    update: GitHubFileDiffUpdateInput;
  }) => GitHubFileDiffPromise;
  deleteGitHubFileDiff: (
    where: GitHubFileDiffWhereUniqueInput
  ) => GitHubFileDiffPromise;
  deleteManyGitHubFileDiffs: (
    where?: GitHubFileDiffWhereInput
  ) => BatchPayloadPromise;
  createGitHubIssue: (data: GitHubIssueCreateInput) => GitHubIssuePromise;
  updateGitHubIssue: (args: {
    data: GitHubIssueUpdateInput;
    where: GitHubIssueWhereUniqueInput;
  }) => GitHubIssuePromise;
  updateManyGitHubIssues: (args: {
    data: GitHubIssueUpdateManyMutationInput;
    where?: GitHubIssueWhereInput;
  }) => BatchPayloadPromise;
  upsertGitHubIssue: (args: {
    where: GitHubIssueWhereUniqueInput;
    create: GitHubIssueCreateInput;
    update: GitHubIssueUpdateInput;
  }) => GitHubIssuePromise;
  deleteGitHubIssue: (where: GitHubIssueWhereUniqueInput) => GitHubIssuePromise;
  deleteManyGitHubIssues: (
    where?: GitHubIssueWhereInput
  ) => BatchPayloadPromise;
  createGitHubLabel: (data: GitHubLabelCreateInput) => GitHubLabelPromise;
  updateGitHubLabel: (args: {
    data: GitHubLabelUpdateInput;
    where: GitHubLabelWhereUniqueInput;
  }) => GitHubLabelPromise;
  updateManyGitHubLabels: (args: {
    data: GitHubLabelUpdateManyMutationInput;
    where?: GitHubLabelWhereInput;
  }) => BatchPayloadPromise;
  upsertGitHubLabel: (args: {
    where: GitHubLabelWhereUniqueInput;
    create: GitHubLabelCreateInput;
    update: GitHubLabelUpdateInput;
  }) => GitHubLabelPromise;
  deleteGitHubLabel: (where: GitHubLabelWhereUniqueInput) => GitHubLabelPromise;
  deleteManyGitHubLabels: (
    where?: GitHubLabelWhereInput
  ) => BatchPayloadPromise;
  createGitHubPullRequest: (
    data: GitHubPullRequestCreateInput
  ) => GitHubPullRequestPromise;
  updateGitHubPullRequest: (args: {
    data: GitHubPullRequestUpdateInput;
    where: GitHubPullRequestWhereUniqueInput;
  }) => GitHubPullRequestPromise;
  updateManyGitHubPullRequests: (args: {
    data: GitHubPullRequestUpdateManyMutationInput;
    where?: GitHubPullRequestWhereInput;
  }) => BatchPayloadPromise;
  upsertGitHubPullRequest: (args: {
    where: GitHubPullRequestWhereUniqueInput;
    create: GitHubPullRequestCreateInput;
    update: GitHubPullRequestUpdateInput;
  }) => GitHubPullRequestPromise;
  deleteGitHubPullRequest: (
    where: GitHubPullRequestWhereUniqueInput
  ) => GitHubPullRequestPromise;
  deleteManyGitHubPullRequests: (
    where?: GitHubPullRequestWhereInput
  ) => BatchPayloadPromise;
  createGitHubPullRequestReview: (
    data: GitHubPullRequestReviewCreateInput
  ) => GitHubPullRequestReviewPromise;
  updateGitHubPullRequestReview: (args: {
    data: GitHubPullRequestReviewUpdateInput;
    where: GitHubPullRequestReviewWhereUniqueInput;
  }) => GitHubPullRequestReviewPromise;
  updateManyGitHubPullRequestReviews: (args: {
    data: GitHubPullRequestReviewUpdateManyMutationInput;
    where?: GitHubPullRequestReviewWhereInput;
  }) => BatchPayloadPromise;
  upsertGitHubPullRequestReview: (args: {
    where: GitHubPullRequestReviewWhereUniqueInput;
    create: GitHubPullRequestReviewCreateInput;
    update: GitHubPullRequestReviewUpdateInput;
  }) => GitHubPullRequestReviewPromise;
  deleteGitHubPullRequestReview: (
    where: GitHubPullRequestReviewWhereUniqueInput
  ) => GitHubPullRequestReviewPromise;
  deleteManyGitHubPullRequestReviews: (
    where?: GitHubPullRequestReviewWhereInput
  ) => BatchPayloadPromise;
  createGitHubRepository: (
    data: GitHubRepositoryCreateInput
  ) => GitHubRepositoryPromise;
  updateGitHubRepository: (args: {
    data: GitHubRepositoryUpdateInput;
    where: GitHubRepositoryWhereUniqueInput;
  }) => GitHubRepositoryPromise;
  updateManyGitHubRepositories: (args: {
    data: GitHubRepositoryUpdateManyMutationInput;
    where?: GitHubRepositoryWhereInput;
  }) => BatchPayloadPromise;
  upsertGitHubRepository: (args: {
    where: GitHubRepositoryWhereUniqueInput;
    create: GitHubRepositoryCreateInput;
    update: GitHubRepositoryUpdateInput;
  }) => GitHubRepositoryPromise;
  deleteGitHubRepository: (
    where: GitHubRepositoryWhereUniqueInput
  ) => GitHubRepositoryPromise;
  deleteManyGitHubRepositories: (
    where?: GitHubRepositoryWhereInput
  ) => BatchPayloadPromise;
  createGitHubReviewRequest: (
    data: GitHubReviewRequestCreateInput
  ) => GitHubReviewRequestPromise;
  updateGitHubReviewRequest: (args: {
    data: GitHubReviewRequestUpdateInput;
    where: GitHubReviewRequestWhereUniqueInput;
  }) => GitHubReviewRequestPromise;
  upsertGitHubReviewRequest: (args: {
    where: GitHubReviewRequestWhereUniqueInput;
    create: GitHubReviewRequestCreateInput;
    update: GitHubReviewRequestUpdateInput;
  }) => GitHubReviewRequestPromise;
  deleteGitHubReviewRequest: (
    where: GitHubReviewRequestWhereUniqueInput
  ) => GitHubReviewRequestPromise;
  deleteManyGitHubReviewRequests: (
    where?: GitHubReviewRequestWhereInput
  ) => BatchPayloadPromise;
  createGitHubReviewThread: (
    data: GitHubReviewThreadCreateInput
  ) => GitHubReviewThreadPromise;
  updateGitHubReviewThread: (args: {
    data: GitHubReviewThreadUpdateInput;
    where: GitHubReviewThreadWhereUniqueInput;
  }) => GitHubReviewThreadPromise;
  updateManyGitHubReviewThreads: (args: {
    data: GitHubReviewThreadUpdateManyMutationInput;
    where?: GitHubReviewThreadWhereInput;
  }) => BatchPayloadPromise;
  upsertGitHubReviewThread: (args: {
    where: GitHubReviewThreadWhereUniqueInput;
    create: GitHubReviewThreadCreateInput;
    update: GitHubReviewThreadUpdateInput;
  }) => GitHubReviewThreadPromise;
  deleteGitHubReviewThread: (
    where: GitHubReviewThreadWhereUniqueInput
  ) => GitHubReviewThreadPromise;
  deleteManyGitHubReviewThreads: (
    where?: GitHubReviewThreadWhereInput
  ) => BatchPayloadPromise;
  createGitHubTopic: (data: GitHubTopicCreateInput) => GitHubTopicPromise;
  updateGitHubTopic: (args: {
    data: GitHubTopicUpdateInput;
    where: GitHubTopicWhereUniqueInput;
  }) => GitHubTopicPromise;
  updateManyGitHubTopics: (args: {
    data: GitHubTopicUpdateManyMutationInput;
    where?: GitHubTopicWhereInput;
  }) => BatchPayloadPromise;
  upsertGitHubTopic: (args: {
    where: GitHubTopicWhereUniqueInput;
    create: GitHubTopicCreateInput;
    update: GitHubTopicUpdateInput;
  }) => GitHubTopicPromise;
  deleteGitHubTopic: (where: GitHubTopicWhereUniqueInput) => GitHubTopicPromise;
  deleteManyGitHubTopics: (
    where?: GitHubTopicWhereInput
  ) => BatchPayloadPromise;
  createGitHubUser: (data: GitHubUserCreateInput) => GitHubUserPromise;
  updateGitHubUser: (args: {
    data: GitHubUserUpdateInput;
    where: GitHubUserWhereUniqueInput;
  }) => GitHubUserPromise;
  updateManyGitHubUsers: (args: {
    data: GitHubUserUpdateManyMutationInput;
    where?: GitHubUserWhereInput;
  }) => BatchPayloadPromise;
  upsertGitHubUser: (args: {
    where: GitHubUserWhereUniqueInput;
    create: GitHubUserCreateInput;
    update: GitHubUserUpdateInput;
  }) => GitHubUserPromise;
  deleteGitHubUser: (where: GitHubUserWhereUniqueInput) => GitHubUserPromise;
  deleteManyGitHubUsers: (where?: GitHubUserWhereInput) => BatchPayloadPromise;
  createGitHubWebhookEvent: (
    data: GitHubWebhookEventCreateInput
  ) => GitHubWebhookEventPromise;
  updateGitHubWebhookEvent: (args: {
    data: GitHubWebhookEventUpdateInput;
    where: GitHubWebhookEventWhereUniqueInput;
  }) => GitHubWebhookEventPromise;
  updateManyGitHubWebhookEvents: (args: {
    data: GitHubWebhookEventUpdateManyMutationInput;
    where?: GitHubWebhookEventWhereInput;
  }) => BatchPayloadPromise;
  upsertGitHubWebhookEvent: (args: {
    where: GitHubWebhookEventWhereUniqueInput;
    create: GitHubWebhookEventCreateInput;
    update: GitHubWebhookEventUpdateInput;
  }) => GitHubWebhookEventPromise;
  deleteGitHubWebhookEvent: (
    where: GitHubWebhookEventWhereUniqueInput
  ) => GitHubWebhookEventPromise;
  deleteManyGitHubWebhookEvents: (
    where?: GitHubWebhookEventWhereInput
  ) => BatchPayloadPromise;
  createPost: (data: PostCreateInput) => PostPromise;
  updatePost: (args: {
    data: PostUpdateInput;
    where: PostWhereUniqueInput;
  }) => PostPromise;
  updateManyPosts: (args: {
    data: PostUpdateManyMutationInput;
    where?: PostWhereInput;
  }) => BatchPayloadPromise;
  upsertPost: (args: {
    where: PostWhereUniqueInput;
    create: PostCreateInput;
    update: PostUpdateInput;
  }) => PostPromise;
  deletePost: (where: PostWhereUniqueInput) => PostPromise;
  deleteManyPosts: (where?: PostWhereInput) => BatchPayloadPromise;
  createRepository: (data: RepositoryCreateInput) => RepositoryPromise;
  updateRepository: (args: {
    data: RepositoryUpdateInput;
    where: RepositoryWhereUniqueInput;
  }) => RepositoryPromise;
  updateManyRepositories: (args: {
    data: RepositoryUpdateManyMutationInput;
    where?: RepositoryWhereInput;
  }) => BatchPayloadPromise;
  upsertRepository: (args: {
    where: RepositoryWhereUniqueInput;
    create: RepositoryCreateInput;
    update: RepositoryUpdateInput;
  }) => RepositoryPromise;
  deleteRepository: (where: RepositoryWhereUniqueInput) => RepositoryPromise;
  deleteManyRepositories: (where?: RepositoryWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  appKey: (
    where?: AppKeySubscriptionWhereInput
  ) => AppKeySubscriptionPayloadSubscription;
  game: (
    where?: GameSubscriptionWhereInput
  ) => GameSubscriptionPayloadSubscription;
  gitHubBranch: (
    where?: GitHubBranchSubscriptionWhereInput
  ) => GitHubBranchSubscriptionPayloadSubscription;
  gitHubComment: (
    where?: GitHubCommentSubscriptionWhereInput
  ) => GitHubCommentSubscriptionPayloadSubscription;
  gitHubCommit: (
    where?: GitHubCommitSubscriptionWhereInput
  ) => GitHubCommitSubscriptionPayloadSubscription;
  gitHubFileDiff: (
    where?: GitHubFileDiffSubscriptionWhereInput
  ) => GitHubFileDiffSubscriptionPayloadSubscription;
  gitHubIssue: (
    where?: GitHubIssueSubscriptionWhereInput
  ) => GitHubIssueSubscriptionPayloadSubscription;
  gitHubLabel: (
    where?: GitHubLabelSubscriptionWhereInput
  ) => GitHubLabelSubscriptionPayloadSubscription;
  gitHubPullRequest: (
    where?: GitHubPullRequestSubscriptionWhereInput
  ) => GitHubPullRequestSubscriptionPayloadSubscription;
  gitHubPullRequestReview: (
    where?: GitHubPullRequestReviewSubscriptionWhereInput
  ) => GitHubPullRequestReviewSubscriptionPayloadSubscription;
  gitHubRepository: (
    where?: GitHubRepositorySubscriptionWhereInput
  ) => GitHubRepositorySubscriptionPayloadSubscription;
  gitHubReviewRequest: (
    where?: GitHubReviewRequestSubscriptionWhereInput
  ) => GitHubReviewRequestSubscriptionPayloadSubscription;
  gitHubReviewThread: (
    where?: GitHubReviewThreadSubscriptionWhereInput
  ) => GitHubReviewThreadSubscriptionPayloadSubscription;
  gitHubTopic: (
    where?: GitHubTopicSubscriptionWhereInput
  ) => GitHubTopicSubscriptionPayloadSubscription;
  gitHubUser: (
    where?: GitHubUserSubscriptionWhereInput
  ) => GitHubUserSubscriptionPayloadSubscription;
  gitHubWebhookEvent: (
    where?: GitHubWebhookEventSubscriptionWhereInput
  ) => GitHubWebhookEventSubscriptionPayloadSubscription;
  post: (
    where?: PostSubscriptionWhereInput
  ) => PostSubscriptionPayloadSubscription;
  repository: (
    where?: RepositorySubscriptionWhereInput
  ) => RepositorySubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type GitHubLabelOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "updatedAtExternal_ASC"
  | "updatedAtExternal_DESC"
  | "createdAtExternal_ASC"
  | "createdAtExternal_DESC"
  | "color_ASC"
  | "color_DESC"
  | "description_ASC"
  | "description_DESC"
  | "name_ASC"
  | "name_DESC"
  | "url_ASC"
  | "url_DESC";

export type GameOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "title_ASC"
  | "title_DESC"
  | "type_ASC"
  | "type_DESC";

export type Role = "USER" | "ADMIN";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "email_ASC"
  | "email_DESC"
  | "name_ASC"
  | "name_DESC"
  | "password_ASC"
  | "password_DESC"
  | "role_ASC"
  | "role_DESC"
  | "gitLogin_ASC"
  | "gitLogin_DESC";

export type PostOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "title_ASC"
  | "title_DESC"
  | "published_ASC"
  | "published_DESC";

export type GitHubBranchOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "merged_ASC"
  | "merged_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type GitHubIssueOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "createdAtExternal_ASC"
  | "createdAtExternal_DESC"
  | "updatedAtExternal_ASC"
  | "updatedAtExternal_DESC"
  | "lastEditedAt_ASC"
  | "lastEditedAt_DESC"
  | "bodyText_ASC"
  | "bodyText_DESC"
  | "closed_ASC"
  | "closed_DESC"
  | "locked_ASC"
  | "locked_DESC"
  | "number_ASC"
  | "number_DESC"
  | "state_ASC"
  | "state_DESC"
  | "title_ASC"
  | "title_DESC"
  | "url_ASC"
  | "url_DESC";

export type GitHubReviewThreadOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "isResolved_ASC"
  | "isResolved_DESC";

export type GitHubCommentOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "createdAtExternal_ASC"
  | "createdAtExternal_DESC"
  | "bodyText_ASC"
  | "bodyText_DESC"
  | "url_ASC"
  | "url_DESC";

export type GitHubReviewRequestOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type AppKeyOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "key_ASC"
  | "key_DESC"
  | "name_ASC"
  | "name_DESC";

export type GitHubPullRequestOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "createdAtExternal_ASC"
  | "createdAtExternal_DESC"
  | "publishedAt_ASC"
  | "publishedAt_DESC"
  | "closedAt_ASC"
  | "closedAt_DESC"
  | "mergedAt_ASC"
  | "mergedAt_DESC"
  | "number_ASC"
  | "number_DESC"
  | "closed_ASC"
  | "closed_DESC"
  | "isCrossRepository_ASC"
  | "isCrossRepository_DESC"
  | "locked_ASC"
  | "locked_DESC"
  | "merged_ASC"
  | "merged_DESC"
  | "additions_ASC"
  | "additions_DESC"
  | "changedFiles_ASC"
  | "changedFiles_DESC"
  | "deletions_ASC"
  | "deletions_DESC"
  | "bodyText_ASC"
  | "bodyText_DESC";

export type GitHubCommitOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "additions_ASC"
  | "additions_DESC"
  | "authedDate_ASC"
  | "authedDate_DESC"
  | "changedFiles_ASC"
  | "changedFiles_DESC"
  | "commitUrl_ASC"
  | "commitUrl_DESC"
  | "deletions_ASC"
  | "deletions_DESC"
  | "message_ASC"
  | "message_DESC"
  | "messageHeadline_ASC"
  | "messageHeadline_DESC"
  | "pushedDate_ASC"
  | "pushedDate_DESC"
  | "treeUrl_ASC"
  | "treeUrl_DESC"
  | "url_ASC"
  | "url_DESC";

export type GitHubWebhookEventOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "eventType_ASC"
  | "eventType_DESC"
  | "action_ASC"
  | "action_DESC"
  | "sender_ASC"
  | "sender_DESC";

export type GitHubUserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "createdAtExternal_ASC"
  | "createdAtExternal_DESC"
  | "isBountyHunter_ASC"
  | "isBountyHunter_DESC"
  | "isCampusExpert_ASC"
  | "isCampusExpert_DESC"
  | "isDeveloperProgramMember_ASC"
  | "isDeveloperProgramMember_DESC"
  | "isEmployee_ASC"
  | "isEmployee_DESC"
  | "isHireable_ASC"
  | "isHireable_DESC"
  | "isSiteAdmin_ASC"
  | "isSiteAdmin_DESC"
  | "isViewer_ASC"
  | "isViewer_DESC"
  | "url_ASC"
  | "url_DESC"
  | "name_ASC"
  | "name_DESC"
  | "login_ASC"
  | "login_DESC"
  | "avatarUrl_ASC"
  | "avatarUrl_DESC"
  | "bio_ASC"
  | "bio_DESC"
  | "company_ASC"
  | "company_DESC"
  | "email_ASC"
  | "email_DESC";

export type RepositoryOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "idExternal_ASC"
  | "idExternal_DESC"
  | "createdAtExternal_ASC"
  | "createdAtExternal_DESC"
  | "updatedAtExternal_ASC"
  | "updatedAtExternal_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "homepageUrl_ASC"
  | "homepageUrl_DESC"
  | "url_ASC"
  | "url_DESC"
  | "owner_ASC"
  | "owner_DESC"
  | "isTracked_ASC"
  | "isTracked_DESC"
  | "isFork_ASC"
  | "isFork_DESC"
  | "isLocked_ASC"
  | "isLocked_DESC"
  | "isPrivate_ASC"
  | "isPrivate_DESC"
  | "isArchived_ASC"
  | "isArchived_DESC"
  | "isDisabled_ASC"
  | "isDisabled_DESC"
  | "sshUrl_ASC"
  | "sshUrl_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type GitHubFileDiffOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "additions_ASC"
  | "additions_DESC"
  | "deletions_ASC"
  | "deletions_DESC"
  | "filepath_ASC"
  | "filepath_DESC";

export type GitHubPullRequestReviewOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "createdAtExternal_ASC"
  | "createdAtExternal_DESC"
  | "updatedAtExternal_ASC"
  | "updatedAtExternal_DESC"
  | "submittedAt_ASC"
  | "submittedAt_DESC"
  | "lastEditedAt_ASC"
  | "lastEditedAt_DESC"
  | "publishedAt_ASC"
  | "publishedAt_DESC"
  | "state_ASC"
  | "state_DESC"
  | "bodyText_ASC"
  | "bodyText_DESC"
  | "url_ASC"
  | "url_DESC";

export type GitHubTopicOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "name_ASC"
  | "name_DESC";

export type GitHubRepositoryOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC"
  | "updatedAtExternal_ASC"
  | "updatedAtExternal_DESC"
  | "hasBranchRules_ASC"
  | "hasBranchRules_DESC"
  | "hasContributingGuidelines_ASC"
  | "hasContributingGuidelines_DESC"
  | "hasPullRequestTemplate_ASC"
  | "hasPullRequestTemplate_DESC"
  | "hasReadMe_ASC"
  | "hasReadMe_DESC"
  | "hasWiki_ASC"
  | "hasWiki_DESC"
  | "isArchived_ASC"
  | "isArchived_DESC"
  | "isDisabled_ASC"
  | "isDisabled_DESC"
  | "isFork_ASC"
  | "isFork_DESC"
  | "isLocked_ASC"
  | "isLocked_DESC"
  | "isPrivate_ASC"
  | "isPrivate_DESC"
  | "description_ASC"
  | "description_DESC"
  | "license_ASC"
  | "license_DESC"
  | "name_ASC"
  | "name_DESC"
  | "primaryLanguage_ASC"
  | "primaryLanguage_DESC"
  | "sshUrl_ASC"
  | "sshUrl_DESC"
  | "url_ASC"
  | "url_DESC";

export interface GitHubRepositoryCreateInput {
  id?: Maybe<ID_Input>;
  updatedAtExternal: DateTimeInput;
  collaborators?: Maybe<GitHubUserCreateManyInput>;
  owner: GitHubUserCreateOneInput;
  repositoryTopics?: Maybe<GitHubTopicCreateManyInput>;
  stargazers?: Maybe<GitHubUserCreateManyInput>;
  watchers?: Maybe<GitHubUserCreateManyInput>;
  hasBranchRules: Boolean;
  hasContributingGuidelines: Boolean;
  hasPullRequestTemplate: Boolean;
  hasReadMe: Boolean;
  hasWiki: Boolean;
  isArchived: Boolean;
  isDisabled: Boolean;
  isFork: Boolean;
  isLocked: Boolean;
  isPrivate: Boolean;
  description: String;
  license?: Maybe<String>;
  name: String;
  primaryLanguage?: Maybe<String>;
  sshUrl: String;
  url: String;
}

export type AppKeyWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  key?: Maybe<String>;
}>;

export interface RepositoryUpsertWithWhereUniqueWithoutAddedByInput {
  where: RepositoryWhereUniqueInput;
  update: RepositoryUpdateWithoutAddedByDataInput;
  create: RepositoryCreateWithoutAddedByInput;
}

export interface GitHubBranchUpdateManyMutationInput {
  name?: Maybe<String>;
  merged?: Maybe<Boolean>;
}

export interface UserUpsertWithoutKeysInput {
  update: UserUpdateWithoutKeysDataInput;
  create: UserCreateWithoutKeysInput;
}

export interface GitHubBranchUpdateInput {
  name?: Maybe<String>;
  commits?: Maybe<GitHubCommitUpdateManyInput>;
  pullRequest?: Maybe<GitHubPullRequestUpdateOneInput>;
  merged?: Maybe<Boolean>;
}

export interface AppKeyUpdateManyMutationInput {
  key?: Maybe<String>;
  name?: Maybe<String>;
}

export interface RepositorySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<RepositoryWhereInput>;
  AND?: Maybe<
    RepositorySubscriptionWhereInput[] | RepositorySubscriptionWhereInput
  >;
}

export interface GitHubCommitUpdateManyMutationInput {
  additions?: Maybe<Int>;
  authedDate?: Maybe<DateTimeInput>;
  changedFiles?: Maybe<Int>;
  commitUrl?: Maybe<String>;
  deletions?: Maybe<Int>;
  message?: Maybe<String>;
  messageHeadline?: Maybe<String>;
  pushedDate?: Maybe<DateTimeInput>;
  treeUrl?: Maybe<String>;
  url?: Maybe<String>;
}

export interface PostSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PostWhereInput>;
  AND?: Maybe<PostSubscriptionWhereInput[] | PostSubscriptionWhereInput>;
}

export interface GitHubCommitUpdateInput {
  author?: Maybe<GitHubUserUpdateOneRequiredInput>;
  associatedPullRequests?: Maybe<
    GitHubPullRequestUpdateManyWithoutCommitsInput
  >;
  committer?: Maybe<GitHubUserUpdateOneRequiredInput>;
  additions?: Maybe<Int>;
  authedDate?: Maybe<DateTimeInput>;
  changedFiles?: Maybe<Int>;
  commitUrl?: Maybe<String>;
  deletions?: Maybe<Int>;
  message?: Maybe<String>;
  messageHeadline?: Maybe<String>;
  pushedDate?: Maybe<DateTimeInput>;
  treeUrl?: Maybe<String>;
  url?: Maybe<String>;
}

export interface GitHubUserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<GitHubUserWhereInput>;
  AND?: Maybe<
    GitHubUserSubscriptionWhereInput[] | GitHubUserSubscriptionWhereInput
  >;
}

export interface GameCreateInput {
  id?: Maybe<ID_Input>;
  repository: RepositoryCreateOneWithoutGameInput;
  title: String;
  owner: UserCreateOneInput;
  type: String;
}

export type GitHubBranchWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface RepositoryCreateOneWithoutGameInput {
  create?: Maybe<RepositoryCreateWithoutGameInput>;
  connect?: Maybe<RepositoryWhereUniqueInput>;
}

export interface GitHubCommitWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  author?: Maybe<GitHubUserWhereInput>;
  associatedPullRequests_some?: Maybe<GitHubPullRequestWhereInput>;
  committer?: Maybe<GitHubUserWhereInput>;
  additions?: Maybe<Int>;
  additions_not?: Maybe<Int>;
  additions_in?: Maybe<Int[] | Int>;
  additions_not_in?: Maybe<Int[] | Int>;
  additions_lt?: Maybe<Int>;
  additions_lte?: Maybe<Int>;
  additions_gt?: Maybe<Int>;
  additions_gte?: Maybe<Int>;
  authedDate?: Maybe<DateTimeInput>;
  authedDate_not?: Maybe<DateTimeInput>;
  authedDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  authedDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  authedDate_lt?: Maybe<DateTimeInput>;
  authedDate_lte?: Maybe<DateTimeInput>;
  authedDate_gt?: Maybe<DateTimeInput>;
  authedDate_gte?: Maybe<DateTimeInput>;
  changedFiles?: Maybe<Int>;
  changedFiles_not?: Maybe<Int>;
  changedFiles_in?: Maybe<Int[] | Int>;
  changedFiles_not_in?: Maybe<Int[] | Int>;
  changedFiles_lt?: Maybe<Int>;
  changedFiles_lte?: Maybe<Int>;
  changedFiles_gt?: Maybe<Int>;
  changedFiles_gte?: Maybe<Int>;
  commitUrl?: Maybe<String>;
  commitUrl_not?: Maybe<String>;
  commitUrl_in?: Maybe<String[] | String>;
  commitUrl_not_in?: Maybe<String[] | String>;
  commitUrl_lt?: Maybe<String>;
  commitUrl_lte?: Maybe<String>;
  commitUrl_gt?: Maybe<String>;
  commitUrl_gte?: Maybe<String>;
  commitUrl_contains?: Maybe<String>;
  commitUrl_not_contains?: Maybe<String>;
  commitUrl_starts_with?: Maybe<String>;
  commitUrl_not_starts_with?: Maybe<String>;
  commitUrl_ends_with?: Maybe<String>;
  commitUrl_not_ends_with?: Maybe<String>;
  deletions?: Maybe<Int>;
  deletions_not?: Maybe<Int>;
  deletions_in?: Maybe<Int[] | Int>;
  deletions_not_in?: Maybe<Int[] | Int>;
  deletions_lt?: Maybe<Int>;
  deletions_lte?: Maybe<Int>;
  deletions_gt?: Maybe<Int>;
  deletions_gte?: Maybe<Int>;
  message?: Maybe<String>;
  message_not?: Maybe<String>;
  message_in?: Maybe<String[] | String>;
  message_not_in?: Maybe<String[] | String>;
  message_lt?: Maybe<String>;
  message_lte?: Maybe<String>;
  message_gt?: Maybe<String>;
  message_gte?: Maybe<String>;
  message_contains?: Maybe<String>;
  message_not_contains?: Maybe<String>;
  message_starts_with?: Maybe<String>;
  message_not_starts_with?: Maybe<String>;
  message_ends_with?: Maybe<String>;
  message_not_ends_with?: Maybe<String>;
  messageHeadline?: Maybe<String>;
  messageHeadline_not?: Maybe<String>;
  messageHeadline_in?: Maybe<String[] | String>;
  messageHeadline_not_in?: Maybe<String[] | String>;
  messageHeadline_lt?: Maybe<String>;
  messageHeadline_lte?: Maybe<String>;
  messageHeadline_gt?: Maybe<String>;
  messageHeadline_gte?: Maybe<String>;
  messageHeadline_contains?: Maybe<String>;
  messageHeadline_not_contains?: Maybe<String>;
  messageHeadline_starts_with?: Maybe<String>;
  messageHeadline_not_starts_with?: Maybe<String>;
  messageHeadline_ends_with?: Maybe<String>;
  messageHeadline_not_ends_with?: Maybe<String>;
  pushedDate?: Maybe<DateTimeInput>;
  pushedDate_not?: Maybe<DateTimeInput>;
  pushedDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  pushedDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  pushedDate_lt?: Maybe<DateTimeInput>;
  pushedDate_lte?: Maybe<DateTimeInput>;
  pushedDate_gt?: Maybe<DateTimeInput>;
  pushedDate_gte?: Maybe<DateTimeInput>;
  treeUrl?: Maybe<String>;
  treeUrl_not?: Maybe<String>;
  treeUrl_in?: Maybe<String[] | String>;
  treeUrl_not_in?: Maybe<String[] | String>;
  treeUrl_lt?: Maybe<String>;
  treeUrl_lte?: Maybe<String>;
  treeUrl_gt?: Maybe<String>;
  treeUrl_gte?: Maybe<String>;
  treeUrl_contains?: Maybe<String>;
  treeUrl_not_contains?: Maybe<String>;
  treeUrl_starts_with?: Maybe<String>;
  treeUrl_not_starts_with?: Maybe<String>;
  treeUrl_ends_with?: Maybe<String>;
  treeUrl_not_ends_with?: Maybe<String>;
  url?: Maybe<String>;
  url_not?: Maybe<String>;
  url_in?: Maybe<String[] | String>;
  url_not_in?: Maybe<String[] | String>;
  url_lt?: Maybe<String>;
  url_lte?: Maybe<String>;
  url_gt?: Maybe<String>;
  url_gte?: Maybe<String>;
  url_contains?: Maybe<String>;
  url_not_contains?: Maybe<String>;
  url_starts_with?: Maybe<String>;
  url_not_starts_with?: Maybe<String>;
  url_ends_with?: Maybe<String>;
  url_not_ends_with?: Maybe<String>;
  AND?: Maybe<GitHubCommitWhereInput[] | GitHubCommitWhereInput>;
}

export interface RepositoryCreateWithoutGameInput {
  id?: Maybe<ID_Input>;
  idExternal: String;
  createdAtExternal: DateTimeInput;
  updatedAtExternal: DateTimeInput;
  addedBy: UserCreateOneWithoutAddedRepositoriesInput;
  name: String;
  description?: Maybe<String>;
  homepageUrl?: Maybe<String>;
  url: String;
  owner: String;
  isTracked: Boolean;
  appKey: AppKeyCreateOneWithoutRepositoriesInput;
  isFork: Boolean;
  isLocked: Boolean;
  isPrivate: Boolean;
  isArchived: Boolean;
  isDisabled: Boolean;
  sshUrl?: Maybe<String>;
  webhookEvents?: Maybe<GitHubWebhookEventCreateManyWithoutRepositoryInput>;
}

export interface GitHubCommentWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdAtExternal?: Maybe<DateTimeInput>;
  createdAtExternal_not?: Maybe<DateTimeInput>;
  createdAtExternal_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAtExternal_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAtExternal_lt?: Maybe<DateTimeInput>;
  createdAtExternal_lte?: Maybe<DateTimeInput>;
  createdAtExternal_gt?: Maybe<DateTimeInput>;
  createdAtExternal_gte?: Maybe<DateTimeInput>;
  author?: Maybe<GitHubUserWhereInput>;
  bodyText?: Maybe<String>;
  bodyText_not?: Maybe<String>;
  bodyText_in?: Maybe<String[] | String>;
  bodyText_not_in?: Maybe<String[] | String>;
  bodyText_lt?: Maybe<String>;
  bodyText_lte?: Maybe<String>;
  bodyText_gt?: Maybe<String>;
  bodyText_gte?: Maybe<String>;
  bodyText_contains?: Maybe<String>;
  bodyText_not_contains?: Maybe<String>;
  bodyText_starts_with?: Maybe<String>;
  bodyText_not_starts_with?: Maybe<String>;
  bodyText_ends_with?: Maybe<String>;
  bodyText_not_ends_with?: Maybe<String>;
  url?: Maybe<String>;
  url_not?: Maybe<String>;
  url_in?: Maybe<String[] | String>;
  url_not_in?: Maybe<String[] | String>;
  url_lt?: Maybe<String>;
  url_lte?: Maybe<String>;
  url_gt?: Maybe<String>;
  url_gte?: Maybe<String>;
  url_contains?: Maybe<String>;
  url_not_contains?: Maybe<String>;
  url_starts_with?: Maybe<String>;
  url_not_starts_with?: Maybe<String>;
  url_ends_with?: Maybe<String>;
  url_not_ends_with?: Maybe<String>;
  AND?: Maybe<GitHubCommentWhereInput[] | GitHubCommentWhereInput>;
}

export interface GameUpdateInput {
  repository?: Maybe<RepositoryUpdateOneRequiredWithoutGameInput>;
  title?: Maybe<String>;
  owner?: Maybe<UserUpdateOneRequiredInput>;
  type?: Maybe<String>;
}

export interface GitHubLabelWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  updatedAtExternal?: Maybe<DateTimeInput>;
  updatedAtExternal_not?: Maybe<DateTimeInput>;
  updatedAtExternal_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAtExternal_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAtExternal_lt?: Maybe<DateTimeInput>;
  updatedAtExternal_lte?: Maybe<DateTimeInput>;
  updatedAtExternal_gt?: Maybe<DateTimeInput>;
  updatedAtExternal_gte?: Maybe<DateTimeInput>;
  createdAtExternal?: Maybe<DateTimeInput>;
  createdAtExternal_not?: Maybe<DateTimeInput>;
  createdAtExternal_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAtExternal_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAtExternal_lt?: Maybe<DateTimeInput>;
  createdAtExternal_lte?: Maybe<DateTimeInput>;
  createdAtExternal_gt?: Maybe<DateTimeInput>;
  createdAtExternal_gte?: Maybe<DateTimeInput>;
  issues_some?: Maybe<GitHubIssueWhereInput>;
  pullRequests_some?: Maybe<GitHubPullRequestWhereInput>;
  color?: Maybe<String>;
  color_not?: Maybe<String>;
  color_in?: Maybe<String[] | String>;
  color_not_in?: Maybe<String[] | String>;
  color_lt?: Maybe<String>;
  color_lte?: Maybe<String>;
  color_gt?: Maybe<String>;
  color_gte?: Maybe<String>;
  color_contains?: Maybe<String>;
  color_not_contains?: Maybe<String>;
  color_starts_with?: Maybe<String>;
  color_not_starts_with?: Maybe<String>;
  color_ends_with?: Maybe<String>;
  color_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  url?: Maybe<String>;
  url_not?: Maybe<String>;
  url_in?: Maybe<String[] | String>;
  url_not_in?: Maybe<String[] | String>;
  url_lt?: Maybe<String>;
  url_lte?: Maybe<String>;
  url_gt?: Maybe<String>;
  url_gte?: Maybe<String>;
  url_contains?: Maybe<String>;
  url_not_contains?: Maybe<String>;
  url_starts_with?: Maybe<String>;
  url_not_starts_with?: Maybe<String>;
  url_ends_with?: Maybe<String>;
  url_not_ends_with?: Maybe<String>;
  AND?: Maybe<GitHubLabelWhereInput[] | GitHubLabelWhereInput>;
}

export interface RepositoryUpdateOneRequiredWithoutGameInput {
  create?: Maybe<RepositoryCreateWithoutGameInput>;
  update?: Maybe<RepositoryUpdateWithoutGameDataInput>;
  upsert?: Maybe<RepositoryUpsertWithoutGameInput>;
  connect?: Maybe<RepositoryWhereUniqueInput>;
}

export interface GitHubFileDiffWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  additions?: Maybe<Int>;
  additions_not?: Maybe<Int>;
  additions_in?: Maybe<Int[] | Int>;
  additions_not_in?: Maybe<Int[] | Int>;
  additions_lt?: Maybe<Int>;
  additions_lte?: Maybe<Int>;
  additions_gt?: Maybe<Int>;
  additions_gte?: Maybe<Int>;
  deletions?: Maybe<Int>;
  deletions_not?: Maybe<Int>;
  deletions_in?: Maybe<Int[] | Int>;
  deletions_not_in?: Maybe<Int[] | Int>;
  deletions_lt?: Maybe<Int>;
  deletions_lte?: Maybe<Int>;
  deletions_gt?: Maybe<Int>;
  deletions_gte?: Maybe<Int>;
  filepath?: Maybe<String>;
  filepath_not?: Maybe<String>;
  filepath_in?: Maybe<String[] | String>;
  filepath_not_in?: Maybe<String[] | String>;
  filepath_lt?: Maybe<String>;
  filepath_lte?: Maybe<String>;
  filepath_gt?: Maybe<String>;
  filepath_gte?: Maybe<String>;
  filepath_contains?: Maybe<String>;
  filepath_not_contains?: Maybe<String>;
  filepath_starts_with?: Maybe<String>;
  filepath_not_starts_with?: Maybe<String>;
  filepath_ends_with?: Maybe<String>;
  filepath_not_ends_with?: Maybe<String>;
  AND?: Maybe<GitHubFileDiffWhereInput[] | GitHubFileDiffWhereInput>;
}

export interface RepositoryUpdateWithoutGameDataInput {
  idExternal?: Maybe<String>;
  createdAtExternal?: Maybe<DateTimeInput>;
  updatedAtExternal?: Maybe<DateTimeInput>;
  addedBy?: Maybe<UserUpdateOneRequiredWithoutAddedRepositoriesInput>;
  name?: Maybe<String>;
  description?: Maybe<String>;
  homepageUrl?: Maybe<String>;
  url?: Maybe<String>;
  owner?: Maybe<String>;
  isTracked?: Maybe<Boolean>;
  appKey?: Maybe<AppKeyUpdateOneRequiredWithoutRepositoriesInput>;
  isFork?: Maybe<Boolean>;
  isLocked?: Maybe<Boolean>;
  isPrivate?: Maybe<Boolean>;
  isArchived?: Maybe<Boolean>;
  isDisabled?: Maybe<Boolean>;
  sshUrl?: Maybe<String>;
  webhookEvents?: Maybe<GitHubWebhookEventUpdateManyWithoutRepositoryInput>;
}

export interface GitHubPullRequestReviewWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdAtExternal?: Maybe<DateTimeInput>;
  createdAtExternal_not?: Maybe<DateTimeInput>;
  createdAtExternal_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAtExternal_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAtExternal_lt?: Maybe<DateTimeInput>;
  createdAtExternal_lte?: Maybe<DateTimeInput>;
  createdAtExternal_gt?: Maybe<DateTimeInput>;
  createdAtExternal_gte?: Maybe<DateTimeInput>;
  updatedAtExternal?: Maybe<DateTimeInput>;
  updatedAtExternal_not?: Maybe<DateTimeInput>;
  updatedAtExternal_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAtExternal_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAtExternal_lt?: Maybe<DateTimeInput>;
  updatedAtExternal_lte?: Maybe<DateTimeInput>;
  updatedAtExternal_gt?: Maybe<DateTimeInput>;
  updatedAtExternal_gte?: Maybe<DateTimeInput>;
  submittedAt?: Maybe<DateTimeInput>;
  submittedAt_not?: Maybe<DateTimeInput>;
  submittedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  submittedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  submittedAt_lt?: Maybe<DateTimeInput>;
  submittedAt_lte?: Maybe<DateTimeInput>;
  submittedAt_gt?: Maybe<DateTimeInput>;
  submittedAt_gte?: Maybe<DateTimeInput>;
  lastEditedAt?: Maybe<DateTimeInput>;
  lastEditedAt_not?: Maybe<DateTimeInput>;
  lastEditedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  lastEditedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  lastEditedAt_lt?: Maybe<DateTimeInput>;
  lastEditedAt_lte?: Maybe<DateTimeInput>;
  lastEditedAt_gt?: Maybe<DateTimeInput>;
  lastEditedAt_gte?: Maybe<DateTimeInput>;
  publishedAt?: Maybe<DateTimeInput>;
  publishedAt_not?: Maybe<DateTimeInput>;
  publishedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  publishedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  publishedAt_lt?: Maybe<DateTimeInput>;
  publishedAt_lte?: Maybe<DateTimeInput>;
  publishedAt_gt?: Maybe<DateTimeInput>;
  publishedAt_gte?: Maybe<DateTimeInput>;
  author?: Maybe<GitHubUserWhereInput>;
  comments_some?: Maybe<GitHubCommentWhereInput>;
  commit_some?: Maybe<GitHubCommitWhereInput>;
  pullRequest?: Maybe<GitHubPullRequestWhereInput>;
  state?: Maybe<String>;
  state_not?: Maybe<String>;
  state_in?: Maybe<String[] | String>;
  state_not_in?: Maybe<String[] | String>;
  state_lt?: Maybe<String>;
  state_lte?: Maybe<String>;
  state_gt?: Maybe<String>;
  state_gte?: Maybe<String>;
  state_contains?: Maybe<String>;
  state_not_contains?: Maybe<String>;
  state_starts_with?: Maybe<String>;
  state_not_starts_with?: Maybe<String>;
  state_ends_with?: Maybe<String>;
  state_not_ends_with?: Maybe<String>;
  bodyText?: Maybe<String>;
  bodyText_not?: Maybe<String>;
  bodyText_in?: Maybe<String[] | String>;
  bodyText_not_in?: Maybe<String[] | String>;
  bodyText_lt?: Maybe<String>;
  bodyText_lte?: Maybe<String>;
  bodyText_gt?: Maybe<String>;
  bodyText_gte?: Maybe<String>;
  bodyText_contains?: Maybe<String>;
  bodyText_not_contains?: Maybe<String>;
  bodyText_starts_with?: Maybe<String>;
  bodyText_not_starts_with?: Maybe<String>;
  bodyText_ends_with?: Maybe<String>;
  bodyText_not_ends_with?: Maybe<String>;
  url?: Maybe<String>;
  url_not?: Maybe<String>;
  url_in?: Maybe<String[] | String>;
  url_not_in?: Maybe<String[] | String>;
  url_lt?: Maybe<String>;
  url_lte?: Maybe<String>;
  url_gt?: Maybe<String>;
  url_gte?: Maybe<String>;
  url_contains?: Maybe<String>;
  url_not_contains?: Maybe<String>;
  url_starts_with?: Maybe<String>;
  url_not_starts_with?: Maybe<String>;
  url_ends_with?: Maybe<String>;
  url_not_ends_with?: Maybe<String>;
  AND?: Maybe<
    GitHubPullRequestReviewWhereInput[] | GitHubPullRequestReviewWhereInput
  >;
}

export interface RepositoryUpsertWithoutGameInput {
  update: RepositoryUpdateWithoutGameDataInput;
  create: RepositoryCreateWithoutGameInput;
}

export interface GitHubRepositoryWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  updatedAtExternal?: Maybe<DateTimeInput>;
  updatedAtExternal_not?: Maybe<DateTimeInput>;
  updatedAtExternal_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAtExternal_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAtExternal_lt?: Maybe<DateTimeInput>;
  updatedAtExternal_lte?: Maybe<DateTimeInput>;
  updatedAtExternal_gt?: Maybe<DateTimeInput>;
  updatedAtExternal_gte?: Maybe<DateTimeInput>;
  collaborators_some?: Maybe<GitHubUserWhereInput>;
  owner?: Maybe<GitHubUserWhereInput>;
  repositoryTopics_some?: Maybe<GitHubTopicWhereInput>;
  stargazers_some?: Maybe<GitHubUserWhereInput>;
  watchers_some?: Maybe<GitHubUserWhereInput>;
  hasBranchRules?: Maybe<Boolean>;
  hasBranchRules_not?: Maybe<Boolean>;
  hasContributingGuidelines?: Maybe<Boolean>;
  hasContributingGuidelines_not?: Maybe<Boolean>;
  hasPullRequestTemplate?: Maybe<Boolean>;
  hasPullRequestTemplate_not?: Maybe<Boolean>;
  hasReadMe?: Maybe<Boolean>;
  hasReadMe_not?: Maybe<Boolean>;
  hasWiki?: Maybe<Boolean>;
  hasWiki_not?: Maybe<Boolean>;
  isArchived?: Maybe<Boolean>;
  isArchived_not?: Maybe<Boolean>;
  isDisabled?: Maybe<Boolean>;
  isDisabled_not?: Maybe<Boolean>;
  isFork?: Maybe<Boolean>;
  isFork_not?: Maybe<Boolean>;
  isLocked?: Maybe<Boolean>;
  isLocked_not?: Maybe<Boolean>;
  isPrivate?: Maybe<Boolean>;
  isPrivate_not?: Maybe<Boolean>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  license?: Maybe<String>;
  license_not?: Maybe<String>;
  license_in?: Maybe<String[] | String>;
  license_not_in?: Maybe<String[] | String>;
  license_lt?: Maybe<String>;
  license_lte?: Maybe<String>;
  license_gt?: Maybe<String>;
  license_gte?: Maybe<String>;
  license_contains?: Maybe<String>;
  license_not_contains?: Maybe<String>;
  license_starts_with?: Maybe<String>;
  license_not_starts_with?: Maybe<String>;
  license_ends_with?: Maybe<String>;
  license_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  primaryLanguage?: Maybe<String>;
  primaryLanguage_not?: Maybe<String>;
  primaryLanguage_in?: Maybe<String[] | String>;
  primaryLanguage_not_in?: Maybe<String[] | String>;
  primaryLanguage_lt?: Maybe<String>;
  primaryLanguage_lte?: Maybe<String>;
  primaryLanguage_gt?: Maybe<String>;
  primaryLanguage_gte?: Maybe<String>;
  primaryLanguage_contains?: Maybe<String>;
  primaryLanguage_not_contains?: Maybe<String>;
  primaryLanguage_starts_with?: Maybe<String>;
  primaryLanguage_not_starts_with?: Maybe<String>;
  primaryLanguage_ends_with?: Maybe<String>;
  primaryLanguage_not_ends_with?: Maybe<String>;
  sshUrl?: Maybe<String>;
  sshUrl_not?: Maybe<String>;
  sshUrl_in?: Maybe<String[] | String>;
  sshUrl_not_in?: Maybe<String[] | String>;
  sshUrl_lt?: Maybe<String>;
  sshUrl_lte?: Maybe<String>;
  sshUrl_gt?: Maybe<String>;
  sshUrl_gte?: Maybe<String>;
  sshUrl_contains?: Maybe<String>;
  sshUrl_not_contains?: Maybe<String>;
  sshUrl_starts_with?: Maybe<String>;
  sshUrl_not_starts_with?: Maybe<String>;
  sshUrl_ends_with?: Maybe<String>;
  sshUrl_not_ends_with?: Maybe<String>;
  url?: Maybe<String>;
  url_not?: Maybe<String>;
  url_in?: Maybe<String[] | String>;
  url_not_in?: Maybe<String[] | String>;
  url_lt?: Maybe<String>;
  url_lte?: Maybe<String>;
  url_gt?: Maybe<String>;
  url_gte?: Maybe<String>;
  url_contains?: Maybe<String>;
  url_not_contains?: Maybe<String>;
  url_starts_with?: Maybe<String>;
  url_not_starts_with?: Maybe<String>;
  url_ends_with?: Maybe<String>;
  url_not_ends_with?: Maybe<String>;
  AND?: Maybe<GitHubRepositoryWhereInput[] | GitHubRepositoryWhereInput>;
}

export interface GameUpdateManyMutationInput {
  title?: Maybe<String>;
  type?: Maybe<String>;
}

export interface GitHubReviewRequestSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<GitHubReviewRequestWhereInput>;
  AND?: Maybe<
    | GitHubReviewRequestSubscriptionWhereInput[]
    | GitHubReviewRequestSubscriptionWhereInput
  >;
}

export interface GitHubBranchCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  commits?: Maybe<GitHubCommitCreateManyInput>;
  pullRequest?: Maybe<GitHubPullRequestCreateOneInput>;
  merged?: Maybe<Boolean>;
}

export interface GitHubPullRequestReviewSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<GitHubPullRequestReviewWhereInput>;
  AND?: Maybe<
    | GitHubPullRequestReviewSubscriptionWhereInput[]
    | GitHubPullRequestReviewSubscriptionWhereInput
  >;
}

export interface GitHubCommitCreateManyInput {
  create?: Maybe<GitHubCommitCreateInput[] | GitHubCommitCreateInput>;
  connect?: Maybe<
    GitHubCommitWhereUniqueInput[] | GitHubCommitWhereUniqueInput
  >;
}

export interface GitHubLabelSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<GitHubLabelWhereInput>;
  AND?: Maybe<
    GitHubLabelSubscriptionWhereInput[] | GitHubLabelSubscriptionWhereInput
  >;
}

export interface GitHubCommitCreateInput {
  id?: Maybe<ID_Input>;
  author: GitHubUserCreateOneInput;
  associatedPullRequests?: Maybe<
    GitHubPullRequestCreateManyWithoutCommitsInput
  >;
  committer: GitHubUserCreateOneInput;
  additions: Int;
  authedDate: DateTimeInput;
  changedFiles: Int;
  commitUrl: String;
  deletions: Int;
  message: String;
  messageHeadline: String;
  pushedDate: DateTimeInput;
  treeUrl: String;
  url: String;
}

export interface GitHubFileDiffSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<GitHubFileDiffWhereInput>;
  AND?: Maybe<
    | GitHubFileDiffSubscriptionWhereInput[]
    | GitHubFileDiffSubscriptionWhereInput
  >;
}

export interface GitHubUserCreateOneInput {
  create?: Maybe<GitHubUserCreateInput>;
  connect?: Maybe<GitHubUserWhereUniqueInput>;
}

export interface GameWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  repository?: Maybe<RepositoryWhereInput>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  owner?: Maybe<UserWhereInput>;
  type?: Maybe<String>;
  type_not?: Maybe<String>;
  type_in?: Maybe<String[] | String>;
  type_not_in?: Maybe<String[] | String>;
  type_lt?: Maybe<String>;
  type_lte?: Maybe<String>;
  type_gt?: Maybe<String>;
  type_gte?: Maybe<String>;
  type_contains?: Maybe<String>;
  type_not_contains?: Maybe<String>;
  type_starts_with?: Maybe<String>;
  type_not_starts_with?: Maybe<String>;
  type_ends_with?: Maybe<String>;
  type_not_ends_with?: Maybe<String>;
  AND?: Maybe<GameWhereInput[] | GameWhereInput>;
}

export interface GitHubUserCreateInput {
  id?: Maybe<ID_Input>;
  createdAtExternal: DateTimeInput;
  followers?: Maybe<GitHubUserCreateManyWithoutFollowersInput>;
  following?: Maybe<GitHubUserCreateManyWithoutFollowingInput>;
  issueComments?: Maybe<GitHubCommentCreateManyWithoutAuthorInput>;
  issues?: Maybe<GitHubIssueCreateManyInput>;
  pullRequests?: Maybe<GitHubPullRequestCreateManyInput>;
  isBountyHunter: Boolean;
  isCampusExpert: Boolean;
  isDeveloperProgramMember: Boolean;
  isEmployee: Boolean;
  isHireable: Boolean;
  isSiteAdmin: Boolean;
  isViewer: Boolean;
  url: String;
  name: String;
  login: String;
  avatarUrl: String;
  bio?: Maybe<String>;
  company?: Maybe<String>;
  email?: Maybe<String>;
}

export interface GitHubWebhookEventWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  repository?: Maybe<RepositoryWhereInput>;
  eventType?: Maybe<String>;
  eventType_not?: Maybe<String>;
  eventType_in?: Maybe<String[] | String>;
  eventType_not_in?: Maybe<String[] | String>;
  eventType_lt?: Maybe<String>;
  eventType_lte?: Maybe<String>;
  eventType_gt?: Maybe<String>;
  eventType_gte?: Maybe<String>;
  eventType_contains?: Maybe<String>;
  eventType_not_contains?: Maybe<String>;
  eventType_starts_with?: Maybe<String>;
  eventType_not_starts_with?: Maybe<String>;
  eventType_ends_with?: Maybe<String>;
  eventType_not_ends_with?: Maybe<String>;
  action?: Maybe<String>;
  action_not?: Maybe<String>;
  action_in?: Maybe<String[] | String>;
  action_not_in?: Maybe<String[] | String>;
  action_lt?: Maybe<String>;
  action_lte?: Maybe<String>;
  action_gt?: Maybe<String>;
  action_gte?: Maybe<String>;
  action_contains?: Maybe<String>;
  action_not_contains?: Maybe<String>;
  action_starts_with?: Maybe<String>;
  action_not_starts_with?: Maybe<String>;
  action_ends_with?: Maybe<String>;
  action_not_ends_with?: Maybe<String>;
  sender?: Maybe<String>;
  sender_not?: Maybe<String>;
  sender_in?: Maybe<String[] | String>;
  sender_not_in?: Maybe<String[] | String>;
  sender_lt?: Maybe<String>;
  sender_lte?: Maybe<String>;
  sender_gt?: Maybe<String>;
  sender_gte?: Maybe<String>;
  sender_contains?: Maybe<String>;
  sender_not_contains?: Maybe<String>;
  sender_starts_with?: Maybe<String>;
  sender_not_starts_with?: Maybe<String>;
  sender_ends_with?: Maybe<String>;
  sender_not_ends_with?: Maybe<String>;
  AND?: Maybe<GitHubWebhookEventWhereInput[] | GitHubWebhookEventWhereInput>;
}

export interface GitHubUserCreateManyWithoutFollowersInput {
  create?: Maybe<
    | GitHubUserCreateWithoutFollowersInput[]
    | GitHubUserCreateWithoutFollowersInput
  >;
  connect?: Maybe<GitHubUserWhereUniqueInput[] | GitHubUserWhereUniqueInput>;
}

export interface RepositoryWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  idExternal?: Maybe<String>;
  idExternal_not?: Maybe<String>;
  idExternal_in?: Maybe<String[] | String>;
  idExternal_not_in?: Maybe<String[] | String>;
  idExternal_lt?: Maybe<String>;
  idExternal_lte?: Maybe<String>;
  idExternal_gt?: Maybe<String>;
  idExternal_gte?: Maybe<String>;
  idExternal_contains?: Maybe<String>;
  idExternal_not_contains?: Maybe<String>;
  idExternal_starts_with?: Maybe<String>;
  idExternal_not_starts_with?: Maybe<String>;
  idExternal_ends_with?: Maybe<String>;
  idExternal_not_ends_with?: Maybe<String>;
  createdAtExternal?: Maybe<DateTimeInput>;
  createdAtExternal_not?: Maybe<DateTimeInput>;
  createdAtExternal_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAtExternal_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAtExternal_lt?: Maybe<DateTimeInput>;
  createdAtExternal_lte?: Maybe<DateTimeInput>;
  createdAtExternal_gt?: Maybe<DateTimeInput>;
  createdAtExternal_gte?: Maybe<DateTimeInput>;
  updatedAtExternal?: Maybe<DateTimeInput>;
  updatedAtExternal_not?: Maybe<DateTimeInput>;
  updatedAtExternal_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAtExternal_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAtExternal_lt?: Maybe<DateTimeInput>;
  updatedAtExternal_lte?: Maybe<DateTimeInput>;
  updatedAtExternal_gt?: Maybe<DateTimeInput>;
  updatedAtExternal_gte?: Maybe<DateTimeInput>;
  addedBy?: Maybe<UserWhereInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  homepageUrl?: Maybe<String>;
  homepageUrl_not?: Maybe<String>;
  homepageUrl_in?: Maybe<String[] | String>;
  homepageUrl_not_in?: Maybe<String[] | String>;
  homepageUrl_lt?: Maybe<String>;
  homepageUrl_lte?: Maybe<String>;
  homepageUrl_gt?: Maybe<String>;
  homepageUrl_gte?: Maybe<String>;
  homepageUrl_contains?: Maybe<String>;
  homepageUrl_not_contains?: Maybe<String>;
  homepageUrl_starts_with?: Maybe<String>;
  homepageUrl_not_starts_with?: Maybe<String>;
  homepageUrl_ends_with?: Maybe<String>;
  homepageUrl_not_ends_with?: Maybe<String>;
  url?: Maybe<String>;
  url_not?: Maybe<String>;
  url_in?: Maybe<String[] | String>;
  url_not_in?: Maybe<String[] | String>;
  url_lt?: Maybe<String>;
  url_lte?: Maybe<String>;
  url_gt?: Maybe<String>;
  url_gte?: Maybe<String>;
  url_contains?: Maybe<String>;
  url_not_contains?: Maybe<String>;
  url_starts_with?: Maybe<String>;
  url_not_starts_with?: Maybe<String>;
  url_ends_with?: Maybe<String>;
  url_not_ends_with?: Maybe<String>;
  owner?: Maybe<String>;
  owner_not?: Maybe<String>;
  owner_in?: Maybe<String[] | String>;
  owner_not_in?: Maybe<String[] | String>;
  owner_lt?: Maybe<String>;
  owner_lte?: Maybe<String>;
  owner_gt?: Maybe<String>;
  owner_gte?: Maybe<String>;
  owner_contains?: Maybe<String>;
  owner_not_contains?: Maybe<String>;
  owner_starts_with?: Maybe<String>;
  owner_not_starts_with?: Maybe<String>;
  owner_ends_with?: Maybe<String>;
  owner_not_ends_with?: Maybe<String>;
  isTracked?: Maybe<Boolean>;
  isTracked_not?: Maybe<Boolean>;
  appKey?: Maybe<AppKeyWhereInput>;
  isFork?: Maybe<Boolean>;
  isFork_not?: Maybe<Boolean>;
  isLocked?: Maybe<Boolean>;
  isLocked_not?: Maybe<Boolean>;
  isPrivate?: Maybe<Boolean>;
  isPrivate_not?: Maybe<Boolean>;
  isArchived?: Maybe<Boolean>;
  isArchived_not?: Maybe<Boolean>;
  isDisabled?: Maybe<Boolean>;
  isDisabled_not?: Maybe<Boolean>;
  sshUrl?: Maybe<String>;
  sshUrl_not?: Maybe<String>;
  sshUrl_in?: Maybe<String[] | String>;
  sshUrl_not_in?: Maybe<String[] | String>;
  sshUrl_lt?: Maybe<String>;
  sshUrl_lte?: Maybe<String>;
  sshUrl_gt?: Maybe<String>;
  sshUrl_gte?: Maybe<String>;
  sshUrl_contains?: Maybe<String>;
  sshUrl_not_contains?: Maybe<String>;
  sshUrl_starts_with?: Maybe<String>;
  sshUrl_not_starts_with?: Maybe<String>;
  sshUrl_ends_with?: Maybe<String>;
  sshUrl_not_ends_with?: Maybe<String>;
  webhookEvents_some?: Maybe<GitHubWebhookEventWhereInput>;
  game?: Maybe<GameWhereInput>;
  AND?: Maybe<RepositoryWhereInput[] | RepositoryWhereInput>;
}

export interface GitHubUserCreateWithoutFollowersInput {
  id?: Maybe<ID_Input>;
  createdAtExternal: DateTimeInput;
  following?: Maybe<GitHubUserCreateManyWithoutFollowingInput>;
  issueComments?: Maybe<GitHubCommentCreateManyWithoutAuthorInput>;
  issues?: Maybe<GitHubIssueCreateManyInput>;
  pullRequests?: Maybe<GitHubPullRequestCreateManyInput>;
  isBountyHunter: Boolean;
  isCampusExpert: Boolean;
  isDeveloperProgramMember: Boolean;
  isEmployee: Boolean;
  isHireable: Boolean;
  isSiteAdmin: Boolean;
  isViewer: Boolean;
  url: String;
  name: String;
  login: String;
  avatarUrl: String;
  bio?: Maybe<String>;
  company?: Maybe<String>;
  email?: Maybe<String>;
}

export interface AppKeyWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  user?: Maybe<UserWhereInput>;
  repositories_some?: Maybe<RepositoryWhereInput>;
  key?: Maybe<String>;
  key_not?: Maybe<String>;
  key_in?: Maybe<String[] | String>;
  key_not_in?: Maybe<String[] | String>;
  key_lt?: Maybe<String>;
  key_lte?: Maybe<String>;
  key_gt?: Maybe<String>;
  key_gte?: Maybe<String>;
  key_contains?: Maybe<String>;
  key_not_contains?: Maybe<String>;
  key_starts_with?: Maybe<String>;
  key_not_starts_with?: Maybe<String>;
  key_ends_with?: Maybe<String>;
  key_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<AppKeyWhereInput[] | AppKeyWhereInput>;
}

export interface GitHubUserCreateManyWithoutFollowingInput {
  create?: Maybe<
    | GitHubUserCreateWithoutFollowingInput[]
    | GitHubUserCreateWithoutFollowingInput
  >;
  connect?: Maybe<GitHubUserWhereUniqueInput[] | GitHubUserWhereUniqueInput>;
}

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  posts_some?: Maybe<PostWhereInput>;
  keys_some?: Maybe<AppKeyWhereInput>;
  addedRepositories_some?: Maybe<RepositoryWhereInput>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  role?: Maybe<Role>;
  role_not?: Maybe<Role>;
  role_in?: Maybe<Role[] | Role>;
  role_not_in?: Maybe<Role[] | Role>;
  gitLogin?: Maybe<String>;
  gitLogin_not?: Maybe<String>;
  gitLogin_in?: Maybe<String[] | String>;
  gitLogin_not_in?: Maybe<String[] | String>;
  gitLogin_lt?: Maybe<String>;
  gitLogin_lte?: Maybe<String>;
  gitLogin_gt?: Maybe<String>;
  gitLogin_gte?: Maybe<String>;
  gitLogin_contains?: Maybe<String>;
  gitLogin_not_contains?: Maybe<String>;
  gitLogin_starts_with?: Maybe<String>;
  gitLogin_not_starts_with?: Maybe<String>;
  gitLogin_ends_with?: Maybe<String>;
  gitLogin_not_ends_with?: Maybe<String>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface GitHubUserCreateWithoutFollowingInput {
  id?: Maybe<ID_Input>;
  createdAtExternal: DateTimeInput;
  followers?: Maybe<GitHubUserCreateManyWithoutFollowersInput>;
  issueComments?: Maybe<GitHubCommentCreateManyWithoutAuthorInput>;
  issues?: Maybe<GitHubIssueCreateManyInput>;
  pullRequests?: Maybe<GitHubPullRequestCreateManyInput>;
  isBountyHunter: Boolean;
  isCampusExpert: Boolean;
  isDeveloperProgramMember: Boolean;
  isEmployee: Boolean;
  isHireable: Boolean;
  isSiteAdmin: Boolean;
  isViewer: Boolean;
  url: String;
  name: String;
  login: String;
  avatarUrl: String;
  bio?: Maybe<String>;
  company?: Maybe<String>;
  email?: Maybe<String>;
}

export interface UserUpdateInput {
  posts?: Maybe<PostUpdateManyWithoutAuthorInput>;
  keys?: Maybe<AppKeyUpdateManyWithoutUserInput>;
  addedRepositories?: Maybe<RepositoryUpdateManyWithoutAddedByInput>;
  email?: Maybe<String>;
  name?: Maybe<String>;
  password?: Maybe<String>;
  role?: Maybe<Role>;
  gitLogin?: Maybe<String>;
}

export interface GitHubCommentCreateManyWithoutAuthorInput {
  create?: Maybe<
    | GitHubCommentCreateWithoutAuthorInput[]
    | GitHubCommentCreateWithoutAuthorInput
  >;
  connect?: Maybe<
    GitHubCommentWhereUniqueInput[] | GitHubCommentWhereUniqueInput
  >;
}

export interface RepositoryUpdateInput {
  idExternal?: Maybe<String>;
  createdAtExternal?: Maybe<DateTimeInput>;
  updatedAtExternal?: Maybe<DateTimeInput>;
  addedBy?: Maybe<UserUpdateOneRequiredWithoutAddedRepositoriesInput>;
  name?: Maybe<String>;
  description?: Maybe<String>;
  homepageUrl?: Maybe<String>;
  url?: Maybe<String>;
  owner?: Maybe<String>;
  isTracked?: Maybe<Boolean>;
  appKey?: Maybe<AppKeyUpdateOneRequiredWithoutRepositoriesInput>;
  isFork?: Maybe<Boolean>;
  isLocked?: Maybe<Boolean>;
  isPrivate?: Maybe<Boolean>;
  isArchived?: Maybe<Boolean>;
  isDisabled?: Maybe<Boolean>;
  sshUrl?: Maybe<String>;
  webhookEvents?: Maybe<GitHubWebhookEventUpdateManyWithoutRepositoryInput>;
  game?: Maybe<GameUpdateOneWithoutRepositoryInput>;
}

export interface GitHubCommentCreateWithoutAuthorInput {
  id?: Maybe<ID_Input>;
  createdAtExternal: DateTimeInput;
  bodyText: String;
  url: String;
}

export interface RepositoryCreateInput {
  id?: Maybe<ID_Input>;
  idExternal: String;
  createdAtExternal: DateTimeInput;
  updatedAtExternal: DateTimeInput;
  addedBy: UserCreateOneWithoutAddedRepositoriesInput;
  name: String;
  description?: Maybe<String>;
  homepageUrl?: Maybe<String>;
  url: String;
  owner: String;
  isTracked: Boolean;
  appKey: AppKeyCreateOneWithoutRepositoriesInput;
  isFork: Boolean;
  isLocked: Boolean;
  isPrivate: Boolean;
  isArchived: Boolean;
  isDisabled: Boolean;
  sshUrl?: Maybe<String>;
  webhookEvents?: Maybe<GitHubWebhookEventCreateManyWithoutRepositoryInput>;
  game?: Maybe<GameCreateOneWithoutRepositoryInput>;
}

export interface GitHubIssueCreateManyInput {
  create?: Maybe<GitHubIssueCreateInput[] | GitHubIssueCreateInput>;
  connect?: Maybe<GitHubIssueWhereUniqueInput[] | GitHubIssueWhereUniqueInput>;
}

export interface PostUpdateManyMutationInput {
  title?: Maybe<String>;
  published?: Maybe<Boolean>;
}

export interface GitHubIssueCreateInput {
  id?: Maybe<ID_Input>;
  createdAtExternal: DateTimeInput;
  updatedAtExternal: DateTimeInput;
  lastEditedAt: DateTimeInput;
  assignees?: Maybe<GitHubUserCreateManyInput>;
  author: GitHubUserCreateOneInput;
  comments?: Maybe<GitHubCommentCreateManyInput>;
  labels?: Maybe<GitHubLabelCreateManyWithoutIssuesInput>;
  participants?: Maybe<GitHubUserCreateManyInput>;
  bodyText: String;
  closed?: Maybe<DateTimeInput>;
  locked: Boolean;
  number: Int;
  state: String;
  title: String;
  url: String;
}

export interface UserUpdateWithoutPostsDataInput {
  keys?: Maybe<AppKeyUpdateManyWithoutUserInput>;
  addedRepositories?: Maybe<RepositoryUpdateManyWithoutAddedByInput>;
  email?: Maybe<String>;
  name?: Maybe<String>;
  password?: Maybe<String>;
  role?: Maybe<Role>;
  gitLogin?: Maybe<String>;
}

export interface GitHubUserCreateManyInput {
  create?: Maybe<GitHubUserCreateInput[] | GitHubUserCreateInput>;
  connect?: Maybe<GitHubUserWhereUniqueInput[] | GitHubUserWhereUniqueInput>;
}

export type GitHubCommentWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface GitHubCommentCreateManyInput {
  create?: Maybe<GitHubCommentCreateInput[] | GitHubCommentCreateInput>;
  connect?: Maybe<
    GitHubCommentWhereUniqueInput[] | GitHubCommentWhereUniqueInput
  >;
}

export interface UserCreateWithoutPostsInput {
  id?: Maybe<ID_Input>;
  keys?: Maybe<AppKeyCreateManyWithoutUserInput>;
  addedRepositories?: Maybe<RepositoryCreateManyWithoutAddedByInput>;
  email: String;
  name?: Maybe<String>;
  password: String;
  role?: Maybe<Role>;
  gitLogin: String;
}

export interface GitHubCommentCreateInput {
  id?: Maybe<ID_Input>;
  createdAtExternal: DateTimeInput;
  author: GitHubUserCreateOneWithoutIssueCommentsInput;
  bodyText: String;
  url: String;
}

export type GitHubCommitWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface GitHubUserCreateOneWithoutIssueCommentsInput {
  create?: Maybe<GitHubUserCreateWithoutIssueCommentsInput>;
  connect?: Maybe<GitHubUserWhereUniqueInput>;
}

export interface GitHubWebhookEventUpdateManyMutationInput {
  eventType?: Maybe<String>;
  action?: Maybe<String>;
  sender?: Maybe<String>;
}

export interface GitHubUserCreateWithoutIssueCommentsInput {
  id?: Maybe<ID_Input>;
  createdAtExternal: DateTimeInput;
  followers?: Maybe<GitHubUserCreateManyWithoutFollowersInput>;
  following?: Maybe<GitHubUserCreateManyWithoutFollowingInput>;
  issues?: Maybe<GitHubIssueCreateManyInput>;
  pullRequests?: Maybe<GitHubPullRequestCreateManyInput>;
  isBountyHunter: Boolean;
  isCampusExpert: Boolean;
  isDeveloperProgramMember: Boolean;
  isEmployee: Boolean;
  isHireable: Boolean;
  isSiteAdmin: Boolean;
  isViewer: Boolean;
  url: String;
  name: String;
  login: String;
  avatarUrl: String;
  bio?: Maybe<String>;
  company?: Maybe<String>;
  email?: Maybe<String>;
}

export type GitHubFileDiffWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface GitHubPullRequestCreateManyInput {
  create?: Maybe<GitHubPullRequestCreateInput[] | GitHubPullRequestCreateInput>;
  connect?: Maybe<
    GitHubPullRequestWhereUniqueInput[] | GitHubPullRequestWhereUniqueInput
  >;
}

export interface RepositoryUpdateOneRequiredWithoutWebhookEventsInput {
  create?: Maybe<RepositoryCreateWithoutWebhookEventsInput>;
  update?: Maybe<RepositoryUpdateWithoutWebhookEventsDataInput>;
  upsert?: Maybe<RepositoryUpsertWithoutWebhookEventsInput>;
  connect?: Maybe<RepositoryWhereUniqueInput>;
}

export interface GitHubPullRequestCreateInput {
  id?: Maybe<ID_Input>;
  createdAtExternal: DateTimeInput;
  publishedAt?: Maybe<DateTimeInput>;
  closedAt?: Maybe<DateTimeInput>;
  mergedAt?: Maybe<DateTimeInput>;
  assignees?: Maybe<GitHubUserCreateManyInput>;
  author: GitHubUserCreateOneInput;
  comments?: Maybe<GitHubCommentCreateManyInput>;
  commits?: Maybe<GitHubCommitCreateManyWithoutAssociatedPullRequestsInput>;
  files?: Maybe<GitHubFileDiffCreateManyInput>;
  labels?: Maybe<GitHubLabelCreateManyWithoutPullRequestsInput>;
  participants?: Maybe<GitHubUserCreateManyInput>;
  reviewRequests?: Maybe<GitHubReviewRequestCreateManyWithoutPullRequestInput>;
  reviews?: Maybe<GitHubPullRequestReviewCreateManyWithoutPullRequestInput>;
  reviewThreads?: Maybe<GitHubReviewThreadCreateManyWithoutPullRequestInput>;
  mergedBy?: Maybe<GitHubUserCreateOneInput>;
  number: Int;
  closed: Boolean;
  isCrossRepository: Boolean;
  locked: Boolean;
  merged: Boolean;
  additions: Int;
  changedFiles: Int;
  deletions: Int;
  bodyText: String;
}

export type GitHubIssueWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface GitHubCommitCreateManyWithoutAssociatedPullRequestsInput {
  create?: Maybe<
    | GitHubCommitCreateWithoutAssociatedPullRequestsInput[]
    | GitHubCommitCreateWithoutAssociatedPullRequestsInput
  >;
  connect?: Maybe<
    GitHubCommitWhereUniqueInput[] | GitHubCommitWhereUniqueInput
  >;
}

export interface RepositoryCreateOneWithoutWebhookEventsInput {
  create?: Maybe<RepositoryCreateWithoutWebhookEventsInput>;
  connect?: Maybe<RepositoryWhereUniqueInput>;
}

export interface GitHubCommitCreateWithoutAssociatedPullRequestsInput {
  id?: Maybe<ID_Input>;
  author: GitHubUserCreateOneInput;
  committer: GitHubUserCreateOneInput;
  additions: Int;
  authedDate: DateTimeInput;
  changedFiles: Int;
  commitUrl: String;
  deletions: Int;
  message: String;
  messageHeadline: String;
  pushedDate: DateTimeInput;
  treeUrl: String;
  url: String;
}

export type GitHubLabelWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface GitHubFileDiffCreateManyInput {
  create?: Maybe<GitHubFileDiffCreateInput[] | GitHubFileDiffCreateInput>;
  connect?: Maybe<
    GitHubFileDiffWhereUniqueInput[] | GitHubFileDiffWhereUniqueInput
  >;
}

export interface GitHubUserUpdateInput {
  createdAtExternal?: Maybe<DateTimeInput>;
  followers?: Maybe<GitHubUserUpdateManyWithoutFollowersInput>;
  following?: Maybe<GitHubUserUpdateManyWithoutFollowingInput>;
  issueComments?: Maybe<GitHubCommentUpdateManyWithoutAuthorInput>;
  issues?: Maybe<GitHubIssueUpdateManyInput>;
  pullRequests?: Maybe<GitHubPullRequestUpdateManyInput>;
  isBountyHunter?: Maybe<Boolean>;
  isCampusExpert?: Maybe<Boolean>;
  isDeveloperProgramMember?: Maybe<Boolean>;
  isEmployee?: Maybe<Boolean>;
  isHireable?: Maybe<Boolean>;
  isSiteAdmin?: Maybe<Boolean>;
  isViewer?: Maybe<Boolean>;
  url?: Maybe<String>;
  name?: Maybe<String>;
  login?: Maybe<String>;
  avatarUrl?: Maybe<String>;
  bio?: Maybe<String>;
  company?: Maybe<String>;
  email?: Maybe<String>;
}

export interface GitHubFileDiffCreateInput {
  id?: Maybe<ID_Input>;
  additions: Int;
  deletions: Int;
  filepath: String;
}

export type GitHubPullRequestWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface GitHubLabelCreateManyWithoutPullRequestsInput {
  create?: Maybe<
    | GitHubLabelCreateWithoutPullRequestsInput[]
    | GitHubLabelCreateWithoutPullRequestsInput
  >;
  connect?: Maybe<GitHubLabelWhereUniqueInput[] | GitHubLabelWhereUniqueInput>;
}

export interface GitHubReviewThreadUpdateManyMutationInput {
  isResolved?: Maybe<Boolean>;
}

export interface GitHubLabelCreateWithoutPullRequestsInput {
  id?: Maybe<ID_Input>;
  updatedAtExternal: DateTimeInput;
  createdAtExternal: DateTimeInput;
  issues?: Maybe<GitHubIssueCreateManyWithoutLabelsInput>;
  color: String;
  description: String;
  name: String;
  url: String;
}

export type GitHubPullRequestReviewWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface GitHubIssueCreateManyWithoutLabelsInput {
  create?: Maybe<
    GitHubIssueCreateWithoutLabelsInput[] | GitHubIssueCreateWithoutLabelsInput
  >;
  connect?: Maybe<GitHubIssueWhereUniqueInput[] | GitHubIssueWhereUniqueInput>;
}

export interface GitHubPullRequestUpdateOneRequiredWithoutReviewThreadsInput {
  create?: Maybe<GitHubPullRequestCreateWithoutReviewThreadsInput>;
  update?: Maybe<GitHubPullRequestUpdateWithoutReviewThreadsDataInput>;
  upsert?: Maybe<GitHubPullRequestUpsertWithoutReviewThreadsInput>;
  connect?: Maybe<GitHubPullRequestWhereUniqueInput>;
}

export interface GitHubIssueCreateWithoutLabelsInput {
  id?: Maybe<ID_Input>;
  createdAtExternal: DateTimeInput;
  updatedAtExternal: DateTimeInput;
  lastEditedAt: DateTimeInput;
  assignees?: Maybe<GitHubUserCreateManyInput>;
  author: GitHubUserCreateOneInput;
  comments?: Maybe<GitHubCommentCreateManyInput>;
  participants?: Maybe<GitHubUserCreateManyInput>;
  bodyText: String;
  closed?: Maybe<DateTimeInput>;
  locked: Boolean;
  number: Int;
  state: String;
  title: String;
  url: String;
}

export type GitHubRepositoryWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface GitHubReviewRequestCreateManyWithoutPullRequestInput {
  create?: Maybe<
    | GitHubReviewRequestCreateWithoutPullRequestInput[]
    | GitHubReviewRequestCreateWithoutPullRequestInput
  >;
  connect?: Maybe<
    GitHubReviewRequestWhereUniqueInput[] | GitHubReviewRequestWhereUniqueInput
  >;
}

export interface GitHubPullRequestCreateOneWithoutReviewThreadsInput {
  create?: Maybe<GitHubPullRequestCreateWithoutReviewThreadsInput>;
  connect?: Maybe<GitHubPullRequestWhereUniqueInput>;
}

export interface GitHubReviewRequestCreateWithoutPullRequestInput {
  id?: Maybe<ID_Input>;
  requestedReviewer: GitHubUserCreateOneInput;
}

export interface GitHubPullRequestUpsertWithoutReviewRequestsInput {
  update: GitHubPullRequestUpdateWithoutReviewRequestsDataInput;
  create: GitHubPullRequestCreateWithoutReviewRequestsInput;
}

export interface GitHubPullRequestReviewCreateManyWithoutPullRequestInput {
  create?: Maybe<
    | GitHubPullRequestReviewCreateWithoutPullRequestInput[]
    | GitHubPullRequestReviewCreateWithoutPullRequestInput
  >;
  connect?: Maybe<
    | GitHubPullRequestReviewWhereUniqueInput[]
    | GitHubPullRequestReviewWhereUniqueInput
  >;
}

export interface GitHubPullRequestUpdateWithoutReviewRequestsDataInput {
  createdAtExternal?: Maybe<DateTimeInput>;
  publishedAt?: Maybe<DateTimeInput>;
  closedAt?: Maybe<DateTimeInput>;
  mergedAt?: Maybe<DateTimeInput>;
  assignees?: Maybe<GitHubUserUpdateManyInput>;
  author?: Maybe<GitHubUserUpdateOneRequiredInput>;
  comments?: Maybe<GitHubCommentUpdateManyInput>;
  commits?: Maybe<GitHubCommitUpdateManyWithoutAssociatedPullRequestsInput>;
  files?: Maybe<GitHubFileDiffUpdateManyInput>;
  labels?: Maybe<GitHubLabelUpdateManyWithoutPullRequestsInput>;
  participants?: Maybe<GitHubUserUpdateManyInput>;
  reviews?: Maybe<GitHubPullRequestReviewUpdateManyWithoutPullRequestInput>;
  reviewThreads?: Maybe<GitHubReviewThreadUpdateManyWithoutPullRequestInput>;
  mergedBy?: Maybe<GitHubUserUpdateOneInput>;
  number?: Maybe<Int>;
  closed?: Maybe<Boolean>;
  isCrossRepository?: Maybe<Boolean>;
  locked?: Maybe<Boolean>;
  merged?: Maybe<Boolean>;
  additions?: Maybe<Int>;
  changedFiles?: Maybe<Int>;
  deletions?: Maybe<Int>;
  bodyText?: Maybe<String>;
}

export interface GitHubPullRequestReviewCreateWithoutPullRequestInput {
  id?: Maybe<ID_Input>;
  createdAtExternal: DateTimeInput;
  updatedAtExternal: DateTimeInput;
  submittedAt: DateTimeInput;
  lastEditedAt: DateTimeInput;
  publishedAt: DateTimeInput;
  author: GitHubUserCreateOneInput;
  comments?: Maybe<GitHubCommentCreateManyInput>;
  commit?: Maybe<GitHubCommitCreateManyInput>;
  state: String;
  bodyText: String;
  url: String;
}

export interface GitHubReviewRequestUpdateInput {
  pullRequest?: Maybe<
    GitHubPullRequestUpdateOneRequiredWithoutReviewRequestsInput
  >;
  requestedReviewer?: Maybe<GitHubUserUpdateOneRequiredInput>;
}

export interface GitHubReviewThreadCreateManyWithoutPullRequestInput {
  create?: Maybe<
    | GitHubReviewThreadCreateWithoutPullRequestInput[]
    | GitHubReviewThreadCreateWithoutPullRequestInput
  >;
  connect?: Maybe<
    GitHubReviewThreadWhereUniqueInput[] | GitHubReviewThreadWhereUniqueInput
  >;
}

export interface GitHubPullRequestCreateWithoutReviewRequestsInput {
  id?: Maybe<ID_Input>;
  createdAtExternal: DateTimeInput;
  publishedAt?: Maybe<DateTimeInput>;
  closedAt?: Maybe<DateTimeInput>;
  mergedAt?: Maybe<DateTimeInput>;
  assignees?: Maybe<GitHubUserCreateManyInput>;
  author: GitHubUserCreateOneInput;
  comments?: Maybe<GitHubCommentCreateManyInput>;
  commits?: Maybe<GitHubCommitCreateManyWithoutAssociatedPullRequestsInput>;
  files?: Maybe<GitHubFileDiffCreateManyInput>;
  labels?: Maybe<GitHubLabelCreateManyWithoutPullRequestsInput>;
  participants?: Maybe<GitHubUserCreateManyInput>;
  reviews?: Maybe<GitHubPullRequestReviewCreateManyWithoutPullRequestInput>;
  reviewThreads?: Maybe<GitHubReviewThreadCreateManyWithoutPullRequestInput>;
  mergedBy?: Maybe<GitHubUserCreateOneInput>;
  number: Int;
  closed: Boolean;
  isCrossRepository: Boolean;
  locked: Boolean;
  merged: Boolean;
  additions: Int;
  changedFiles: Int;
  deletions: Int;
  bodyText: String;
}

export interface GitHubReviewThreadCreateWithoutPullRequestInput {
  id?: Maybe<ID_Input>;
  comments?: Maybe<GitHubCommentCreateManyInput>;
  repository: GitHubRepositoryCreateOneInput;
  resolvedBy: GitHubUserCreateOneInput;
  isResolved: Boolean;
}

export interface GitHubReviewRequestCreateInput {
  id?: Maybe<ID_Input>;
  pullRequest: GitHubPullRequestCreateOneWithoutReviewRequestsInput;
  requestedReviewer: GitHubUserCreateOneInput;
}

export interface GitHubRepositoryCreateOneInput {
  create?: Maybe<GitHubRepositoryCreateInput>;
  connect?: Maybe<GitHubRepositoryWhereUniqueInput>;
}

export interface GitHubRepositoryUpdateManyMutationInput {
  updatedAtExternal?: Maybe<DateTimeInput>;
  hasBranchRules?: Maybe<Boolean>;
  hasContributingGuidelines?: Maybe<Boolean>;
  hasPullRequestTemplate?: Maybe<Boolean>;
  hasReadMe?: Maybe<Boolean>;
  hasWiki?: Maybe<Boolean>;
  isArchived?: Maybe<Boolean>;
  isDisabled?: Maybe<Boolean>;
  isFork?: Maybe<Boolean>;
  isLocked?: Maybe<Boolean>;
  isPrivate?: Maybe<Boolean>;
  description?: Maybe<String>;
  license?: Maybe<String>;
  name?: Maybe<String>;
  primaryLanguage?: Maybe<String>;
  sshUrl?: Maybe<String>;
  url?: Maybe<String>;
}

export interface GitHubCommentUpdateManyMutationInput {
  createdAtExternal?: Maybe<DateTimeInput>;
  bodyText?: Maybe<String>;
  url?: Maybe<String>;
}

export interface GitHubPullRequestReviewUpdateManyMutationInput {
  createdAtExternal?: Maybe<DateTimeInput>;
  updatedAtExternal?: Maybe<DateTimeInput>;
  submittedAt?: Maybe<DateTimeInput>;
  lastEditedAt?: Maybe<DateTimeInput>;
  publishedAt?: Maybe<DateTimeInput>;
  state?: Maybe<String>;
  bodyText?: Maybe<String>;
  url?: Maybe<String>;
}

export interface GitHubTopicCreateManyInput {
  create?: Maybe<GitHubTopicCreateInput[] | GitHubTopicCreateInput>;
  connect?: Maybe<GitHubTopicWhereUniqueInput[] | GitHubTopicWhereUniqueInput>;
}

export interface GitHubPullRequestUpsertWithoutReviewsInput {
  update: GitHubPullRequestUpdateWithoutReviewsDataInput;
  create: GitHubPullRequestCreateWithoutReviewsInput;
}

export interface GitHubTopicCreateInput {
  id?: Maybe<ID_Input>;
  relatedTopics?: Maybe<GitHubTopicCreateManyWithoutRelatedTopicsInput>;
  stargazers?: Maybe<GitHubUserCreateManyInput>;
  name: String;
}

export interface GitHubPullRequestUpdateOneRequiredWithoutReviewsInput {
  create?: Maybe<GitHubPullRequestCreateWithoutReviewsInput>;
  update?: Maybe<GitHubPullRequestUpdateWithoutReviewsDataInput>;
  upsert?: Maybe<GitHubPullRequestUpsertWithoutReviewsInput>;
  connect?: Maybe<GitHubPullRequestWhereUniqueInput>;
}

export interface GitHubTopicCreateManyWithoutRelatedTopicsInput {
  create?: Maybe<
    | GitHubTopicCreateWithoutRelatedTopicsInput[]
    | GitHubTopicCreateWithoutRelatedTopicsInput
  >;
  connect?: Maybe<GitHubTopicWhereUniqueInput[] | GitHubTopicWhereUniqueInput>;
}

export interface GitHubPullRequestReviewUpdateInput {
  createdAtExternal?: Maybe<DateTimeInput>;
  updatedAtExternal?: Maybe<DateTimeInput>;
  submittedAt?: Maybe<DateTimeInput>;
  lastEditedAt?: Maybe<DateTimeInput>;
  publishedAt?: Maybe<DateTimeInput>;
  author?: Maybe<GitHubUserUpdateOneRequiredInput>;
  comments?: Maybe<GitHubCommentUpdateManyInput>;
  commit?: Maybe<GitHubCommitUpdateManyInput>;
  pullRequest?: Maybe<GitHubPullRequestUpdateOneRequiredWithoutReviewsInput>;
  state?: Maybe<String>;
  bodyText?: Maybe<String>;
  url?: Maybe<String>;
}

export interface GitHubTopicCreateWithoutRelatedTopicsInput {
  id?: Maybe<ID_Input>;
  stargazers?: Maybe<GitHubUserCreateManyInput>;
  name: String;
}

export interface GitHubPullRequestCreateOneWithoutReviewsInput {
  create?: Maybe<GitHubPullRequestCreateWithoutReviewsInput>;
  connect?: Maybe<GitHubPullRequestWhereUniqueInput>;
}

export interface GitHubLabelCreateManyWithoutIssuesInput {
  create?: Maybe<
    GitHubLabelCreateWithoutIssuesInput[] | GitHubLabelCreateWithoutIssuesInput
  >;
  connect?: Maybe<GitHubLabelWhereUniqueInput[] | GitHubLabelWhereUniqueInput>;
}

export interface GitHubPullRequestReviewCreateInput {
  id?: Maybe<ID_Input>;
  createdAtExternal: DateTimeInput;
  updatedAtExternal: DateTimeInput;
  submittedAt: DateTimeInput;
  lastEditedAt: DateTimeInput;
  publishedAt: DateTimeInput;
  author: GitHubUserCreateOneInput;
  comments?: Maybe<GitHubCommentCreateManyInput>;
  commit?: Maybe<GitHubCommitCreateManyInput>;
  pullRequest: GitHubPullRequestCreateOneWithoutReviewsInput;
  state: String;
  bodyText: String;
  url: String;
}

export interface GitHubLabelCreateWithoutIssuesInput {
  id?: Maybe<ID_Input>;
  updatedAtExternal: DateTimeInput;
  createdAtExternal: DateTimeInput;
  pullRequests?: Maybe<GitHubPullRequestCreateManyWithoutLabelsInput>;
  color: String;
  description: String;
  name: String;
  url: String;
}

export interface GitHubPullRequestUpdateInput {
  createdAtExternal?: Maybe<DateTimeInput>;
  publishedAt?: Maybe<DateTimeInput>;
  closedAt?: Maybe<DateTimeInput>;
  mergedAt?: Maybe<DateTimeInput>;
  assignees?: Maybe<GitHubUserUpdateManyInput>;
  author?: Maybe<GitHubUserUpdateOneRequiredInput>;
  comments?: Maybe<GitHubCommentUpdateManyInput>;
  commits?: Maybe<GitHubCommitUpdateManyWithoutAssociatedPullRequestsInput>;
  files?: Maybe<GitHubFileDiffUpdateManyInput>;
  labels?: Maybe<GitHubLabelUpdateManyWithoutPullRequestsInput>;
  participants?: Maybe<GitHubUserUpdateManyInput>;
  reviewRequests?: Maybe<GitHubReviewRequestUpdateManyWithoutPullRequestInput>;
  reviews?: Maybe<GitHubPullRequestReviewUpdateManyWithoutPullRequestInput>;
  reviewThreads?: Maybe<GitHubReviewThreadUpdateManyWithoutPullRequestInput>;
  mergedBy?: Maybe<GitHubUserUpdateOneInput>;
  number?: Maybe<Int>;
  closed?: Maybe<Boolean>;
  isCrossRepository?: Maybe<Boolean>;
  locked?: Maybe<Boolean>;
  merged?: Maybe<Boolean>;
  additions?: Maybe<Int>;
  changedFiles?: Maybe<Int>;
  deletions?: Maybe<Int>;
  bodyText?: Maybe<String>;
}

export interface GitHubPullRequestCreateManyWithoutLabelsInput {
  create?: Maybe<
    | GitHubPullRequestCreateWithoutLabelsInput[]
    | GitHubPullRequestCreateWithoutLabelsInput
  >;
  connect?: Maybe<
    GitHubPullRequestWhereUniqueInput[] | GitHubPullRequestWhereUniqueInput
  >;
}

export interface GitHubLabelUpdateManyMutationInput {
  updatedAtExternal?: Maybe<DateTimeInput>;
  createdAtExternal?: Maybe<DateTimeInput>;
  color?: Maybe<String>;
  description?: Maybe<String>;
  name?: Maybe<String>;
  url?: Maybe<String>;
}

export interface GitHubPullRequestCreateWithoutLabelsInput {
  id?: Maybe<ID_Input>;
  createdAtExternal: DateTimeInput;
  publishedAt?: Maybe<DateTimeInput>;
  closedAt?: Maybe<DateTimeInput>;
  mergedAt?: Maybe<DateTimeInput>;
  assignees?: Maybe<GitHubUserCreateManyInput>;
  author: GitHubUserCreateOneInput;
  comments?: Maybe<GitHubCommentCreateManyInput>;
  commits?: Maybe<GitHubCommitCreateManyWithoutAssociatedPullRequestsInput>;
  files?: Maybe<GitHubFileDiffCreateManyInput>;
  participants?: Maybe<GitHubUserCreateManyInput>;
  reviewRequests?: Maybe<GitHubReviewRequestCreateManyWithoutPullRequestInput>;
  reviews?: Maybe<GitHubPullRequestReviewCreateManyWithoutPullRequestInput>;
  reviewThreads?: Maybe<GitHubReviewThreadCreateManyWithoutPullRequestInput>;
  mergedBy?: Maybe<GitHubUserCreateOneInput>;
  number: Int;
  closed: Boolean;
  isCrossRepository: Boolean;
  locked: Boolean;
  merged: Boolean;
  additions: Int;
  changedFiles: Int;
  deletions: Int;
  bodyText: String;
}

export interface GitHubLabelCreateInput {
  id?: Maybe<ID_Input>;
  updatedAtExternal: DateTimeInput;
  createdAtExternal: DateTimeInput;
  issues?: Maybe<GitHubIssueCreateManyWithoutLabelsInput>;
  pullRequests?: Maybe<GitHubPullRequestCreateManyWithoutLabelsInput>;
  color: String;
  description: String;
  name: String;
  url: String;
}

export interface GitHubPullRequestCreateManyWithoutCommitsInput {
  create?: Maybe<
    | GitHubPullRequestCreateWithoutCommitsInput[]
    | GitHubPullRequestCreateWithoutCommitsInput
  >;
  connect?: Maybe<
    GitHubPullRequestWhereUniqueInput[] | GitHubPullRequestWhereUniqueInput
  >;
}

export interface GitHubIssueUpdateManyMutationInput {
  createdAtExternal?: Maybe<DateTimeInput>;
  updatedAtExternal?: Maybe<DateTimeInput>;
  lastEditedAt?: Maybe<DateTimeInput>;
  bodyText?: Maybe<String>;
  closed?: Maybe<DateTimeInput>;
  locked?: Maybe<Boolean>;
  number?: Maybe<Int>;
  state?: Maybe<String>;
  title?: Maybe<String>;
  url?: Maybe<String>;
}

export interface GitHubPullRequestCreateWithoutCommitsInput {
  id?: Maybe<ID_Input>;
  createdAtExternal: DateTimeInput;
  publishedAt?: Maybe<DateTimeInput>;
  closedAt?: Maybe<DateTimeInput>;
  mergedAt?: Maybe<DateTimeInput>;
  assignees?: Maybe<GitHubUserCreateManyInput>;
  author: GitHubUserCreateOneInput;
  comments?: Maybe<GitHubCommentCreateManyInput>;
  files?: Maybe<GitHubFileDiffCreateManyInput>;
  labels?: Maybe<GitHubLabelCreateManyWithoutPullRequestsInput>;
  participants?: Maybe<GitHubUserCreateManyInput>;
  reviewRequests?: Maybe<GitHubReviewRequestCreateManyWithoutPullRequestInput>;
  reviews?: Maybe<GitHubPullRequestReviewCreateManyWithoutPullRequestInput>;
  reviewThreads?: Maybe<GitHubReviewThreadCreateManyWithoutPullRequestInput>;
  mergedBy?: Maybe<GitHubUserCreateOneInput>;
  number: Int;
  closed: Boolean;
  isCrossRepository: Boolean;
  locked: Boolean;
  merged: Boolean;
  additions: Int;
  changedFiles: Int;
  deletions: Int;
  bodyText: String;
}

export interface GitHubFileDiffUpdateManyMutationInput {
  additions?: Maybe<Int>;
  deletions?: Maybe<Int>;
  filepath?: Maybe<String>;
}

export interface GitHubPullRequestCreateOneInput {
  create?: Maybe<GitHubPullRequestCreateInput>;
  connect?: Maybe<GitHubPullRequestWhereUniqueInput>;
}

export interface UserCreateOneWithoutKeysInput {
  create?: Maybe<UserCreateWithoutKeysInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface GitHubCommentUpdateInput {
  createdAtExternal?: Maybe<DateTimeInput>;
  author?: Maybe<GitHubUserUpdateOneRequiredWithoutIssueCommentsInput>;
  bodyText?: Maybe<String>;
  url?: Maybe<String>;
}

export interface PostCreateManyWithoutAuthorInput {
  create?: Maybe<PostCreateWithoutAuthorInput[] | PostCreateWithoutAuthorInput>;
  connect?: Maybe<PostWhereUniqueInput[] | PostWhereUniqueInput>;
}

export interface GitHubCommitUpdateManyInput {
  create?: Maybe<GitHubCommitCreateInput[] | GitHubCommitCreateInput>;
  update?: Maybe<
    | GitHubCommitUpdateWithWhereUniqueNestedInput[]
    | GitHubCommitUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | GitHubCommitUpsertWithWhereUniqueNestedInput[]
    | GitHubCommitUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<GitHubCommitWhereUniqueInput[] | GitHubCommitWhereUniqueInput>;
  connect?: Maybe<
    GitHubCommitWhereUniqueInput[] | GitHubCommitWhereUniqueInput
  >;
  set?: Maybe<GitHubCommitWhereUniqueInput[] | GitHubCommitWhereUniqueInput>;
  disconnect?: Maybe<
    GitHubCommitWhereUniqueInput[] | GitHubCommitWhereUniqueInput
  >;
  deleteMany?: Maybe<
    GitHubCommitScalarWhereInput[] | GitHubCommitScalarWhereInput
  >;
  updateMany?: Maybe<
    | GitHubCommitUpdateManyWithWhereNestedInput[]
    | GitHubCommitUpdateManyWithWhereNestedInput
  >;
}

export interface RepositoryCreateManyWithoutAddedByInput {
  create?: Maybe<
    RepositoryCreateWithoutAddedByInput[] | RepositoryCreateWithoutAddedByInput
  >;
  connect?: Maybe<RepositoryWhereUniqueInput[] | RepositoryWhereUniqueInput>;
}

export interface GitHubCommitUpdateWithWhereUniqueNestedInput {
  where: GitHubCommitWhereUniqueInput;
  data: GitHubCommitUpdateDataInput;
}

export interface AppKeyCreateOneWithoutRepositoriesInput {
  create?: Maybe<AppKeyCreateWithoutRepositoriesInput>;
  connect?: Maybe<AppKeyWhereUniqueInput>;
}

export interface GitHubCommitUpdateDataInput {
  author?: Maybe<GitHubUserUpdateOneRequiredInput>;
  associatedPullRequests?: Maybe<
    GitHubPullRequestUpdateManyWithoutCommitsInput
  >;
  committer?: Maybe<GitHubUserUpdateOneRequiredInput>;
  additions?: Maybe<Int>;
  authedDate?: Maybe<DateTimeInput>;
  changedFiles?: Maybe<Int>;
  commitUrl?: Maybe<String>;
  deletions?: Maybe<Int>;
  message?: Maybe<String>;
  messageHeadline?: Maybe<String>;
  pushedDate?: Maybe<DateTimeInput>;
  treeUrl?: Maybe<String>;
  url?: Maybe<String>;
}

export interface GitHubWebhookEventCreateManyWithoutRepositoryInput {
  create?: Maybe<
    | GitHubWebhookEventCreateWithoutRepositoryInput[]
    | GitHubWebhookEventCreateWithoutRepositoryInput
  >;
  connect?: Maybe<
    GitHubWebhookEventWhereUniqueInput[] | GitHubWebhookEventWhereUniqueInput
  >;
}

export interface GitHubUserUpdateOneRequiredInput {
  create?: Maybe<GitHubUserCreateInput>;
  update?: Maybe<GitHubUserUpdateDataInput>;
  upsert?: Maybe<GitHubUserUpsertNestedInput>;
  connect?: Maybe<GitHubUserWhereUniqueInput>;
}

export interface GameCreateOneWithoutRepositoryInput {
  create?: Maybe<GameCreateWithoutRepositoryInput>;
  connect?: Maybe<GameWhereUniqueInput>;
}

export interface GitHubUserUpdateDataInput {
  createdAtExternal?: Maybe<DateTimeInput>;
  followers?: Maybe<GitHubUserUpdateManyWithoutFollowersInput>;
  following?: Maybe<GitHubUserUpdateManyWithoutFollowingInput>;
  issueComments?: Maybe<GitHubCommentUpdateManyWithoutAuthorInput>;
  issues?: Maybe<GitHubIssueUpdateManyInput>;
  pullRequests?: Maybe<GitHubPullRequestUpdateManyInput>;
  isBountyHunter?: Maybe<Boolean>;
  isCampusExpert?: Maybe<Boolean>;
  isDeveloperProgramMember?: Maybe<Boolean>;
  isEmployee?: Maybe<Boolean>;
  isHireable?: Maybe<Boolean>;
  isSiteAdmin?: Maybe<Boolean>;
  isViewer?: Maybe<Boolean>;
  url?: Maybe<String>;
  name?: Maybe<String>;
  login?: Maybe<String>;
  avatarUrl?: Maybe<String>;
  bio?: Maybe<String>;
  company?: Maybe<String>;
  email?: Maybe<String>;
}

export interface UserCreateOneInput {
  create?: Maybe<UserCreateInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface GitHubUserUpdateManyWithoutFollowersInput {
  create?: Maybe<
    | GitHubUserCreateWithoutFollowersInput[]
    | GitHubUserCreateWithoutFollowersInput
  >;
  delete?: Maybe<GitHubUserWhereUniqueInput[] | GitHubUserWhereUniqueInput>;
  connect?: Maybe<GitHubUserWhereUniqueInput[] | GitHubUserWhereUniqueInput>;
  set?: Maybe<GitHubUserWhereUniqueInput[] | GitHubUserWhereUniqueInput>;
  disconnect?: Maybe<GitHubUserWhereUniqueInput[] | GitHubUserWhereUniqueInput>;
  update?: Maybe<
    | GitHubUserUpdateWithWhereUniqueWithoutFollowersInput[]
    | GitHubUserUpdateWithWhereUniqueWithoutFollowersInput
  >;
  upsert?: Maybe<
    | GitHubUserUpsertWithWhereUniqueWithoutFollowersInput[]
    | GitHubUserUpsertWithWhereUniqueWithoutFollowersInput
  >;
  deleteMany?: Maybe<GitHubUserScalarWhereInput[] | GitHubUserScalarWhereInput>;
  updateMany?: Maybe<
    | GitHubUserUpdateManyWithWhereNestedInput[]
    | GitHubUserUpdateManyWithWhereNestedInput
  >;
}

export interface AppKeyCreateManyWithoutUserInput {
  create?: Maybe<AppKeyCreateWithoutUserInput[] | AppKeyCreateWithoutUserInput>;
  connect?: Maybe<AppKeyWhereUniqueInput[] | AppKeyWhereUniqueInput>;
}

export interface GitHubUserUpdateWithWhereUniqueWithoutFollowersInput {
  where: GitHubUserWhereUniqueInput;
  data: GitHubUserUpdateWithoutFollowersDataInput;
}

export interface RepositoryCreateManyWithoutAppKeyInput {
  create?: Maybe<
    RepositoryCreateWithoutAppKeyInput[] | RepositoryCreateWithoutAppKeyInput
  >;
  connect?: Maybe<RepositoryWhereUniqueInput[] | RepositoryWhereUniqueInput>;
}

export interface GitHubUserUpdateWithoutFollowersDataInput {
  createdAtExternal?: Maybe<DateTimeInput>;
  following?: Maybe<GitHubUserUpdateManyWithoutFollowingInput>;
  issueComments?: Maybe<GitHubCommentUpdateManyWithoutAuthorInput>;
  issues?: Maybe<GitHubIssueUpdateManyInput>;
  pullRequests?: Maybe<GitHubPullRequestUpdateManyInput>;
  isBountyHunter?: Maybe<Boolean>;
  isCampusExpert?: Maybe<Boolean>;
  isDeveloperProgramMember?: Maybe<Boolean>;
  isEmployee?: Maybe<Boolean>;
  isHireable?: Maybe<Boolean>;
  isSiteAdmin?: Maybe<Boolean>;
  isViewer?: Maybe<Boolean>;
  url?: Maybe<String>;
  name?: Maybe<String>;
  login?: Maybe<String>;
  avatarUrl?: Maybe<String>;
  bio?: Maybe<String>;
  company?: Maybe<String>;
  email?: Maybe<String>;
}

export interface UserCreateOneWithoutAddedRepositoriesInput {
  create?: Maybe<UserCreateWithoutAddedRepositoriesInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface GitHubUserUpdateManyWithoutFollowingInput {
  create?: Maybe<
    | GitHubUserCreateWithoutFollowingInput[]
    | GitHubUserCreateWithoutFollowingInput
  >;
  delete?: Maybe<GitHubUserWhereUniqueInput[] | GitHubUserWhereUniqueInput>;
  connect?: Maybe<GitHubUserWhereUniqueInput[] | GitHubUserWhereUniqueInput>;
  set?: Maybe<GitHubUserWhereUniqueInput[] | GitHubUserWhereUniqueInput>;
  disconnect?: Maybe<GitHubUserWhereUniqueInput[] | GitHubUserWhereUniqueInput>;
  update?: Maybe<
    | GitHubUserUpdateWithWhereUniqueWithoutFollowingInput[]
    | GitHubUserUpdateWithWhereUniqueWithoutFollowingInput
  >;
  upsert?: Maybe<
    | GitHubUserUpsertWithWhereUniqueWithoutFollowingInput[]
    | GitHubUserUpsertWithWhereUniqueWithoutFollowingInput
  >;
  deleteMany?: Maybe<GitHubUserScalarWhereInput[] | GitHubUserScalarWhereInput>;
  updateMany?: Maybe<
    | GitHubUserUpdateManyWithWhereNestedInput[]
    | GitHubUserUpdateManyWithWhereNestedInput
  >;
}

export interface AppKeyUpdateInput {
  user?: Maybe<UserUpdateOneRequiredWithoutKeysInput>;
  repositories?: Maybe<RepositoryUpdateManyWithoutAppKeyInput>;
  key?: Maybe<String>;
  name?: Maybe<String>;
}

export interface GitHubUserUpdateWithWhereUniqueWithoutFollowingInput {
  where: GitHubUserWhereUniqueInput;
  data: GitHubUserUpdateWithoutFollowingDataInput;
}

export interface UserUpdateWithoutKeysDataInput {
  posts?: Maybe<PostUpdateManyWithoutAuthorInput>;
  addedRepositories?: Maybe<RepositoryUpdateManyWithoutAddedByInput>;
  email?: Maybe<String>;
  name?: Maybe<String>;
  password?: Maybe<String>;
  role?: Maybe<Role>;
  gitLogin?: Maybe<String>;
}

export interface GitHubUserUpdateWithoutFollowingDataInput {
  createdAtExternal?: Maybe<DateTimeInput>;
  followers?: Maybe<GitHubUserUpdateManyWithoutFollowersInput>;
  issueComments?: Maybe<GitHubCommentUpdateManyWithoutAuthorInput>;
  issues?: Maybe<GitHubIssueUpdateManyInput>;
  pullRequests?: Maybe<GitHubPullRequestUpdateManyInput>;
  isBountyHunter?: Maybe<Boolean>;
  isCampusExpert?: Maybe<Boolean>;
  isDeveloperProgramMember?: Maybe<Boolean>;
  isEmployee?: Maybe<Boolean>;
  isHireable?: Maybe<Boolean>;
  isSiteAdmin?: Maybe<Boolean>;
  isViewer?: Maybe<Boolean>;
  url?: Maybe<String>;
  name?: Maybe<String>;
  login?: Maybe<String>;
  avatarUrl?: Maybe<String>;
  bio?: Maybe<String>;
  company?: Maybe<String>;
  email?: Maybe<String>;
}

export interface PostUpdateWithWhereUniqueWithoutAuthorInput {
  where: PostWhereUniqueInput;
  data: PostUpdateWithoutAuthorDataInput;
}

export interface GitHubCommentUpdateManyWithoutAuthorInput {
  create?: Maybe<
    | GitHubCommentCreateWithoutAuthorInput[]
    | GitHubCommentCreateWithoutAuthorInput
  >;
  delete?: Maybe<
    GitHubCommentWhereUniqueInput[] | GitHubCommentWhereUniqueInput
  >;
  connect?: Maybe<
    GitHubCommentWhereUniqueInput[] | GitHubCommentWhereUniqueInput
  >;
  set?: Maybe<GitHubCommentWhereUniqueInput[] | GitHubCommentWhereUniqueInput>;
  disconnect?: Maybe<
    GitHubCommentWhereUniqueInput[] | GitHubCommentWhereUniqueInput
  >;
  update?: Maybe<
    | GitHubCommentUpdateWithWhereUniqueWithoutAuthorInput[]
    | GitHubCommentUpdateWithWhereUniqueWithoutAuthorInput
  >;
  upsert?: Maybe<
    | GitHubCommentUpsertWithWhereUniqueWithoutAuthorInput[]
    | GitHubCommentUpsertWithWhereUniqueWithoutAuthorInput
  >;
  deleteMany?: Maybe<
    GitHubCommentScalarWhereInput[] | GitHubCommentScalarWhereInput
  >;
  updateMany?: Maybe<
    | GitHubCommentUpdateManyWithWhereNestedInput[]
    | GitHubCommentUpdateManyWithWhereNestedInput
  >;
}

export interface PostUpsertWithWhereUniqueWithoutAuthorInput {
  where: PostWhereUniqueInput;
  update: PostUpdateWithoutAuthorDataInput;
  create: PostCreateWithoutAuthorInput;
}

export interface GitHubCommentUpdateWithWhereUniqueWithoutAuthorInput {
  where: GitHubCommentWhereUniqueInput;
  data: GitHubCommentUpdateWithoutAuthorDataInput;
}

export interface PostUpdateManyWithWhereNestedInput {
  where: PostScalarWhereInput;
  data: PostUpdateManyDataInput;
}

export interface GitHubCommentUpdateWithoutAuthorDataInput {
  createdAtExternal?: Maybe<DateTimeInput>;
  bodyText?: Maybe<String>;
  url?: Maybe<String>;
}

export interface RepositoryUpdateManyWithoutAddedByInput {
  create?: Maybe<
    RepositoryCreateWithoutAddedByInput[] | RepositoryCreateWithoutAddedByInput
  >;
  delete?: Maybe<RepositoryWhereUniqueInput[] | RepositoryWhereUniqueInput>;
  connect?: Maybe<RepositoryWhereUniqueInput[] | RepositoryWhereUniqueInput>;
  set?: Maybe<RepositoryWhereUniqueInput[] | RepositoryWhereUniqueInput>;
  disconnect?: Maybe<RepositoryWhereUniqueInput[] | RepositoryWhereUniqueInput>;
  update?: Maybe<
    | RepositoryUpdateWithWhereUniqueWithoutAddedByInput[]
    | RepositoryUpdateWithWhereUniqueWithoutAddedByInput
  >;
  upsert?: Maybe<
    | RepositoryUpsertWithWhereUniqueWithoutAddedByInput[]
    | RepositoryUpsertWithWhereUniqueWithoutAddedByInput
  >;
  deleteMany?: Maybe<RepositoryScalarWhereInput[] | RepositoryScalarWhereInput>;
  updateMany?: Maybe<
    | RepositoryUpdateManyWithWhereNestedInput[]
    | RepositoryUpdateManyWithWhereNestedInput
  >;
}

export interface GitHubCommentUpsertWithWhereUniqueWithoutAuthorInput {
  where: GitHubCommentWhereUniqueInput;
  update: GitHubCommentUpdateWithoutAuthorDataInput;
  create: GitHubCommentCreateWithoutAuthorInput;
}

export interface RepositoryUpdateWithoutAddedByDataInput {
  idExternal?: Maybe<String>;
  createdAtExternal?: Maybe<DateTimeInput>;
  updatedAtExternal?: Maybe<DateTimeInput>;
  name?: Maybe<String>;
  description?: Maybe<String>;
  homepageUrl?: Maybe<String>;
  url?: Maybe<String>;
  owner?: Maybe<String>;
  isTracked?: Maybe<Boolean>;
  appKey?: Maybe<AppKeyUpdateOneRequiredWithoutRepositoriesInput>;
  isFork?: Maybe<Boolean>;
  isLocked?: Maybe<Boolean>;
  isPrivate?: Maybe<Boolean>;
  isArchived?: Maybe<Boolean>;
  isDisabled?: Maybe<Boolean>;
  sshUrl?: Maybe<String>;
  webhookEvents?: Maybe<GitHubWebhookEventUpdateManyWithoutRepositoryInput>;
  game?: Maybe<GameUpdateOneWithoutRepositoryInput>;
}

export interface GitHubCommentScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdAtExternal?: Maybe<DateTimeInput>;
  createdAtExternal_not?: Maybe<DateTimeInput>;
  createdAtExternal_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAtExternal_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAtExternal_lt?: Maybe<DateTimeInput>;
  createdAtExternal_lte?: Maybe<DateTimeInput>;
  createdAtExternal_gt?: Maybe<DateTimeInput>;
  createdAtExternal_gte?: Maybe<DateTimeInput>;
  bodyText?: Maybe<String>;
  bodyText_not?: Maybe<String>;
  bodyText_in?: Maybe<String[] | String>;
  bodyText_not_in?: Maybe<String[] | String>;
  bodyText_lt?: Maybe<String>;
  bodyText_lte?: Maybe<String>;
  bodyText_gt?: Maybe<String>;
  bodyText_gte?: Maybe<String>;
  bodyText_contains?: Maybe<String>;
  bodyText_not_contains?: Maybe<String>;
  bodyText_starts_with?: Maybe<String>;
  bodyText_not_starts_with?: Maybe<String>;
  bodyText_ends_with?: Maybe<String>;
  bodyText_not_ends_with?: Maybe<String>;
  url?: Maybe<String>;
  url_not?: Maybe<String>;
  url_in?: Maybe<String[] | String>;
  url_not_in?: Maybe<String[] | String>;
  url_lt?: Maybe<String>;
  url_lte?: Maybe<String>;
  url_gt?: Maybe<String>;
  url_gte?: Maybe<String>;
  url_contains?: Maybe<String>;
  url_not_contains?: Maybe<String>;
  url_starts_with?: Maybe<String>;
  url_not_starts_with?: Maybe<String>;
  url_ends_with?: Maybe<String>;
  url_not_ends_with?: Maybe<String>;
  AND?: Maybe<GitHubCommentScalarWhereInput[] | GitHubCommentScalarWhereInput>;
  OR?: Maybe<GitHubCommentScalarWhereInput[] | GitHubCommentScalarWhereInput>;
  NOT?: Maybe<GitHubCommentScalarWhereInput[] | GitHubCommentScalarWhereInput>;
}

export interface AppKeyUpdateWithoutRepositoriesDataInput {
  user?: Maybe<UserUpdateOneRequiredWithoutKeysInput>;
  key?: Maybe<String>;
  name?: Maybe<String>;
}

export interface GitHubCommentUpdateManyWithWhereNestedInput {
  where: GitHubCommentScalarWhereInput;
  data: GitHubCommentUpdateManyDataInput;
}

export interface GitHubWebhookEventUpdateManyWithoutRepositoryInput {
  create?: Maybe<
    | GitHubWebhookEventCreateWithoutRepositoryInput[]
    | GitHubWebhookEventCreateWithoutRepositoryInput
  >;
  delete?: Maybe<
    GitHubWebhookEventWhereUniqueInput[] | GitHubWebhookEventWhereUniqueInput
  >;
  connect?: Maybe<
    GitHubWebhookEventWhereUniqueInput[] | GitHubWebhookEventWhereUniqueInput
  >;
  set?: Maybe<
    GitHubWebhookEventWhereUniqueInput[] | GitHubWebhookEventWhereUniqueInput
  >;
  disconnect?: Maybe<
    GitHubWebhookEventWhereUniqueInput[] | GitHubWebhookEventWhereUniqueInput
  >;
  update?: Maybe<
    | GitHubWebhookEventUpdateWithWhereUniqueWithoutRepositoryInput[]
    | GitHubWebhookEventUpdateWithWhereUniqueWithoutRepositoryInput
  >;
  upsert?: Maybe<
    | GitHubWebhookEventUpsertWithWhereUniqueWithoutRepositoryInput[]
    | GitHubWebhookEventUpsertWithWhereUniqueWithoutRepositoryInput
  >;
  deleteMany?: Maybe<
    GitHubWebhookEventScalarWhereInput[] | GitHubWebhookEventScalarWhereInput
  >;
  updateMany?: Maybe<
    | GitHubWebhookEventUpdateManyWithWhereNestedInput[]
    | GitHubWebhookEventUpdateManyWithWhereNestedInput
  >;
}

export interface GitHubCommentUpdateManyDataInput {
  createdAtExternal?: Maybe<DateTimeInput>;
  bodyText?: Maybe<String>;
  url?: Maybe<String>;
}

export interface GitHubWebhookEventUpdateWithoutRepositoryDataInput {
  eventType?: Maybe<String>;
  action?: Maybe<String>;
  sender?: Maybe<String>;
}

export interface GitHubIssueUpdateManyInput {
  create?: Maybe<GitHubIssueCreateInput[] | GitHubIssueCreateInput>;
  update?: Maybe<
    | GitHubIssueUpdateWithWhereUniqueNestedInput[]
    | GitHubIssueUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | GitHubIssueUpsertWithWhereUniqueNestedInput[]
    | GitHubIssueUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<GitHubIssueWhereUniqueInput[] | GitHubIssueWhereUniqueInput>;
  connect?: Maybe<GitHubIssueWhereUniqueInput[] | GitHubIssueWhereUniqueInput>;
  set?: Maybe<GitHubIssueWhereUniqueInput[] | GitHubIssueWhereUniqueInput>;
  disconnect?: Maybe<
    GitHubIssueWhereUniqueInput[] | GitHubIssueWhereUniqueInput
  >;
  deleteMany?: Maybe<
    GitHubIssueScalarWhereInput[] | GitHubIssueScalarWhereInput
  >;
  updateMany?: Maybe<
    | GitHubIssueUpdateManyWithWhereNestedInput[]
    | GitHubIssueUpdateManyWithWhereNestedInput
  >;
}

export interface GitHubWebhookEventScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  eventType?: Maybe<String>;
  eventType_not?: Maybe<String>;
  eventType_in?: Maybe<String[] | String>;
  eventType_not_in?: Maybe<String[] | String>;
  eventType_lt?: Maybe<String>;
  eventType_lte?: Maybe<String>;
  eventType_gt?: Maybe<String>;
  eventType_gte?: Maybe<String>;
  eventType_contains?: Maybe<String>;
  eventType_not_contains?: Maybe<String>;
  eventType_starts_with?: Maybe<String>;
  eventType_not_starts_with?: Maybe<String>;
  eventType_ends_with?: Maybe<String>;
  eventType_not_ends_with?: Maybe<String>;
  action?: Maybe<String>;
  action_not?: Maybe<String>;
  action_in?: Maybe<String[] | String>;
  action_not_in?: Maybe<String[] | String>;
  action_lt?: Maybe<String>;
  action_lte?: Maybe<String>;
  action_gt?: Maybe<String>;
  action_gte?: Maybe<String>;
  action_contains?: Maybe<String>;
  action_not_contains?: Maybe<String>;
  action_starts_with?: Maybe<String>;
  action_not_starts_with?: Maybe<String>;
  action_ends_with?: Maybe<String>;
  action_not_ends_with?: Maybe<String>;
  sender?: Maybe<String>;
  sender_not?: Maybe<String>;
  sender_in?: Maybe<String[] | String>;
  sender_not_in?: Maybe<String[] | String>;
  sender_lt?: Maybe<String>;
  sender_lte?: Maybe<String>;
  sender_gt?: Maybe<String>;
  sender_gte?: Maybe<String>;
  sender_contains?: Maybe<String>;
  sender_not_contains?: Maybe<String>;
  sender_starts_with?: Maybe<String>;
  sender_not_starts_with?: Maybe<String>;
  sender_ends_with?: Maybe<String>;
  sender_not_ends_with?: Maybe<String>;
  AND?: Maybe<
    GitHubWebhookEventScalarWhereInput[] | GitHubWebhookEventScalarWhereInput
  >;
  OR?: Maybe<
    GitHubWebhookEventScalarWhereInput[] | GitHubWebhookEventScalarWhereInput
  >;
  NOT?: Maybe<
    GitHubWebhookEventScalarWhereInput[] | GitHubWebhookEventScalarWhereInput
  >;
}

export interface GitHubIssueUpdateWithWhereUniqueNestedInput {
  where: GitHubIssueWhereUniqueInput;
  data: GitHubIssueUpdateDataInput;
}

export interface GitHubWebhookEventUpdateManyDataInput {
  eventType?: Maybe<String>;
  action?: Maybe<String>;
  sender?: Maybe<String>;
}

export interface GitHubIssueUpdateDataInput {
  createdAtExternal?: Maybe<DateTimeInput>;
  updatedAtExternal?: Maybe<DateTimeInput>;
  lastEditedAt?: Maybe<DateTimeInput>;
  assignees?: Maybe<GitHubUserUpdateManyInput>;
  author?: Maybe<GitHubUserUpdateOneRequiredInput>;
  comments?: Maybe<GitHubCommentUpdateManyInput>;
  labels?: Maybe<GitHubLabelUpdateManyWithoutIssuesInput>;
  participants?: Maybe<GitHubUserUpdateManyInput>;
  bodyText?: Maybe<String>;
  closed?: Maybe<DateTimeInput>;
  locked?: Maybe<Boolean>;
  number?: Maybe<Int>;
  state?: Maybe<String>;
  title?: Maybe<String>;
  url?: Maybe<String>;
}

export interface GameUpdateWithoutRepositoryDataInput {
  title?: Maybe<String>;
  owner?: Maybe<UserUpdateOneRequiredInput>;
  type?: Maybe<String>;
}

export interface GitHubUserUpdateManyInput {
  create?: Maybe<GitHubUserCreateInput[] | GitHubUserCreateInput>;
  update?: Maybe<
    | GitHubUserUpdateWithWhereUniqueNestedInput[]
    | GitHubUserUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | GitHubUserUpsertWithWhereUniqueNestedInput[]
    | GitHubUserUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<GitHubUserWhereUniqueInput[] | GitHubUserWhereUniqueInput>;
  connect?: Maybe<GitHubUserWhereUniqueInput[] | GitHubUserWhereUniqueInput>;
  set?: Maybe<GitHubUserWhereUniqueInput[] | GitHubUserWhereUniqueInput>;
  disconnect?: Maybe<GitHubUserWhereUniqueInput[] | GitHubUserWhereUniqueInput>;
  deleteMany?: Maybe<GitHubUserScalarWhereInput[] | GitHubUserScalarWhereInput>;
  updateMany?: Maybe<
    | GitHubUserUpdateManyWithWhereNestedInput[]
    | GitHubUserUpdateManyWithWhereNestedInput
  >;
}

export interface UserUpdateDataInput {
  posts?: Maybe<PostUpdateManyWithoutAuthorInput>;
  keys?: Maybe<AppKeyUpdateManyWithoutUserInput>;
  addedRepositories?: Maybe<RepositoryUpdateManyWithoutAddedByInput>;
  email?: Maybe<String>;
  name?: Maybe<String>;
  password?: Maybe<String>;
  role?: Maybe<Role>;
  gitLogin?: Maybe<String>;
}

export interface GitHubUserUpdateWithWhereUniqueNestedInput {
  where: GitHubUserWhereUniqueInput;
  data: GitHubUserUpdateDataInput;
}

export interface AppKeyUpdateWithWhereUniqueWithoutUserInput {
  where: AppKeyWhereUniqueInput;
  data: AppKeyUpdateWithoutUserDataInput;
}

export interface GitHubUserUpsertWithWhereUniqueNestedInput {
  where: GitHubUserWhereUniqueInput;
  update: GitHubUserUpdateDataInput;
  create: GitHubUserCreateInput;
}

export interface RepositoryUpdateManyWithoutAppKeyInput {
  create?: Maybe<
    RepositoryCreateWithoutAppKeyInput[] | RepositoryCreateWithoutAppKeyInput
  >;
  delete?: Maybe<RepositoryWhereUniqueInput[] | RepositoryWhereUniqueInput>;
  connect?: Maybe<RepositoryWhereUniqueInput[] | RepositoryWhereUniqueInput>;
  set?: Maybe<RepositoryWhereUniqueInput[] | RepositoryWhereUniqueInput>;
  disconnect?: Maybe<RepositoryWhereUniqueInput[] | RepositoryWhereUniqueInput>;
  update?: Maybe<
    | RepositoryUpdateWithWhereUniqueWithoutAppKeyInput[]
    | RepositoryUpdateWithWhereUniqueWithoutAppKeyInput
  >;
  upsert?: Maybe<
    | RepositoryUpsertWithWhereUniqueWithoutAppKeyInput[]
    | RepositoryUpsertWithWhereUniqueWithoutAppKeyInput
  >;
  deleteMany?: Maybe<RepositoryScalarWhereInput[] | RepositoryScalarWhereInput>;
  updateMany?: Maybe<
    | RepositoryUpdateManyWithWhereNestedInput[]
    | RepositoryUpdateManyWithWhereNestedInput
  >;
}

export interface GitHubUserScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdAtExternal?: Maybe<DateTimeInput>;
  createdAtExternal_not?: Maybe<DateTimeInput>;
  createdAtExternal_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAtExternal_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAtExternal_lt?: Maybe<DateTimeInput>;
  createdAtExternal_lte?: Maybe<DateTimeInput>;
  createdAtExternal_gt?: Maybe<DateTimeInput>;
  createdAtExternal_gte?: Maybe<DateTimeInput>;
  isBountyHunter?: Maybe<Boolean>;
  isBountyHunter_not?: Maybe<Boolean>;
  isCampusExpert?: Maybe<Boolean>;
  isCampusExpert_not?: Maybe<Boolean>;
  isDeveloperProgramMember?: Maybe<Boolean>;
  isDeveloperProgramMember_not?: Maybe<Boolean>;
  isEmployee?: Maybe<Boolean>;
  isEmployee_not?: Maybe<Boolean>;
  isHireable?: Maybe<Boolean>;
  isHireable_not?: Maybe<Boolean>;
  isSiteAdmin?: Maybe<Boolean>;
  isSiteAdmin_not?: Maybe<Boolean>;
  isViewer?: Maybe<Boolean>;
  isViewer_not?: Maybe<Boolean>;
  url?: Maybe<String>;
  url_not?: Maybe<String>;
  url_in?: Maybe<String[] | String>;
  url_not_in?: Maybe<String[] | String>;
  url_lt?: Maybe<String>;
  url_lte?: Maybe<String>;
  url_gt?: Maybe<String>;
  url_gte?: Maybe<String>;
  url_contains?: Maybe<String>;
  url_not_contains?: Maybe<String>;
  url_starts_with?: Maybe<String>;
  url_not_starts_with?: Maybe<String>;
  url_ends_with?: Maybe<String>;
  url_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  login?: Maybe<String>;
  login_not?: Maybe<String>;
  login_in?: Maybe<String[] | String>;
  login_not_in?: Maybe<String[] | String>;
  login_lt?: Maybe<String>;
  login_lte?: Maybe<String>;
  login_gt?: Maybe<String>;
  login_gte?: Maybe<String>;
  login_contains?: Maybe<String>;
  login_not_contains?: Maybe<String>;
  login_starts_with?: Maybe<String>;
  login_not_starts_with?: Maybe<String>;
  login_ends_with?: Maybe<String>;
  login_not_ends_with?: Maybe<String>;
  avatarUrl?: Maybe<String>;
  avatarUrl_not?: Maybe<String>;
  avatarUrl_in?: Maybe<String[] | String>;
  avatarUrl_not_in?: Maybe<String[] | String>;
  avatarUrl_lt?: Maybe<String>;
  avatarUrl_lte?: Maybe<String>;
  avatarUrl_gt?: Maybe<String>;
  avatarUrl_gte?: Maybe<String>;
  avatarUrl_contains?: Maybe<String>;
  avatarUrl_not_contains?: Maybe<String>;
  avatarUrl_starts_with?: Maybe<String>;
  avatarUrl_not_starts_with?: Maybe<String>;
  avatarUrl_ends_with?: Maybe<String>;
  avatarUrl_not_ends_with?: Maybe<String>;
  bio?: Maybe<String>;
  bio_not?: Maybe<String>;
  bio_in?: Maybe<String[] | String>;
  bio_not_in?: Maybe<String[] | String>;
  bio_lt?: Maybe<String>;
  bio_lte?: Maybe<String>;
  bio_gt?: Maybe<String>;
  bio_gte?: Maybe<String>;
  bio_contains?: Maybe<String>;
  bio_not_contains?: Maybe<String>;
  bio_starts_with?: Maybe<String>;
  bio_not_starts_with?: Maybe<String>;
  bio_ends_with?: Maybe<String>;
  bio_not_ends_with?: Maybe<String>;
  company?: Maybe<String>;
  company_not?: Maybe<String>;
  company_in?: Maybe<String[] | String>;
  company_not_in?: Maybe<String[] | String>;
  company_lt?: Maybe<String>;
  company_lte?: Maybe<String>;
  company_gt?: Maybe<String>;
  company_gte?: Maybe<String>;
  company_contains?: Maybe<String>;
  company_not_contains?: Maybe<String>;
  company_starts_with?: Maybe<String>;
  company_not_starts_with?: Maybe<String>;
  company_ends_with?: Maybe<String>;
  company_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  AND?: Maybe<GitHubUserScalarWhereInput[] | GitHubUserScalarWhereInput>;
  OR?: Maybe<GitHubUserScalarWhereInput[] | GitHubUserScalarWhereInput>;
  NOT?: Maybe<GitHubUserScalarWhereInput[] | GitHubUserScalarWhereInput>;
}

export interface RepositoryUpdateWithoutAppKeyDataInput {
  idExternal?: Maybe<String>;
  createdAtExternal?: Maybe<DateTimeInput>;
  updatedAtExternal?: Maybe<DateTimeInput>;
  addedBy?: Maybe<UserUpdateOneRequiredWithoutAddedRepositoriesInput>;
  name?: Maybe<String>;
  description?: Maybe<String>;
  homepageUrl?: Maybe<String>;
  url?: Maybe<String>;
  owner?: Maybe<String>;
  isTracked?: Maybe<Boolean>;
  isFork?: Maybe<Boolean>;
  isLocked?: Maybe<Boolean>;
  isPrivate?: Maybe<Boolean>;
  isArchived?: Maybe<Boolean>;
  isDisabled?: Maybe<Boolean>;
  sshUrl?: Maybe<String>;
  webhookEvents?: Maybe<GitHubWebhookEventUpdateManyWithoutRepositoryInput>;
  game?: Maybe<GameUpdateOneWithoutRepositoryInput>;
}

export interface GitHubUserUpdateManyWithWhereNestedInput {
  where: GitHubUserScalarWhereInput;
  data: GitHubUserUpdateManyDataInput;
}

export interface UserUpdateWithoutAddedRepositoriesDataInput {
  posts?: Maybe<PostUpdateManyWithoutAuthorInput>;
  keys?: Maybe<AppKeyUpdateManyWithoutUserInput>;
  email?: Maybe<String>;
  name?: Maybe<String>;
  password?: Maybe<String>;
  role?: Maybe<Role>;
  gitLogin?: Maybe<String>;
}

export interface GitHubUserUpdateManyDataInput {
  createdAtExternal?: Maybe<DateTimeInput>;
  isBountyHunter?: Maybe<Boolean>;
  isCampusExpert?: Maybe<Boolean>;
  isDeveloperProgramMember?: Maybe<Boolean>;
  isEmployee?: Maybe<Boolean>;
  isHireable?: Maybe<Boolean>;
  isSiteAdmin?: Maybe<Boolean>;
  isViewer?: Maybe<Boolean>;
  url?: Maybe<String>;
  name?: Maybe<String>;
  login?: Maybe<String>;
  avatarUrl?: Maybe<String>;
  bio?: Maybe<String>;
  company?: Maybe<String>;
  email?: Maybe<String>;
}

export interface RepositoryUpsertWithWhereUniqueWithoutAppKeyInput {
  where: RepositoryWhereUniqueInput;
  update: RepositoryUpdateWithoutAppKeyDataInput;
  create: RepositoryCreateWithoutAppKeyInput;
}

export interface GitHubCommentUpdateManyInput {
  create?: Maybe<GitHubCommentCreateInput[] | GitHubCommentCreateInput>;
  update?: Maybe<
    | GitHubCommentUpdateWithWhereUniqueNestedInput[]
    | GitHubCommentUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | GitHubCommentUpsertWithWhereUniqueNestedInput[]
    | GitHubCommentUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<
    GitHubCommentWhereUniqueInput[] | GitHubCommentWhereUniqueInput
  >;
  connect?: Maybe<
    GitHubCommentWhereUniqueInput[] | GitHubCommentWhereUniqueInput
  >;
  set?: Maybe<GitHubCommentWhereUniqueInput[] | GitHubCommentWhereUniqueInput>;
  disconnect?: Maybe<
    GitHubCommentWhereUniqueInput[] | GitHubCommentWhereUniqueInput
  >;
  deleteMany?: Maybe<
    GitHubCommentScalarWhereInput[] | GitHubCommentScalarWhereInput
  >;
  updateMany?: Maybe<
    | GitHubCommentUpdateManyWithWhereNestedInput[]
    | GitHubCommentUpdateManyWithWhereNestedInput
  >;
}

export interface RepositoryUpdateManyWithWhereNestedInput {
  where: RepositoryScalarWhereInput;
  data: RepositoryUpdateManyDataInput;
}

export interface GitHubCommentUpdateWithWhereUniqueNestedInput {
  where: GitHubCommentWhereUniqueInput;
  data: GitHubCommentUpdateDataInput;
}

export interface AppKeyUpsertWithWhereUniqueWithoutUserInput {
  where: AppKeyWhereUniqueInput;
  update: AppKeyUpdateWithoutUserDataInput;
  create: AppKeyCreateWithoutUserInput;
}

export interface GitHubCommentUpdateDataInput {
  createdAtExternal?: Maybe<DateTimeInput>;
  author?: Maybe<GitHubUserUpdateOneRequiredWithoutIssueCommentsInput>;
  bodyText?: Maybe<String>;
  url?: Maybe<String>;
}

export interface AppKeyUpdateManyWithWhereNestedInput {
  where: AppKeyScalarWhereInput;
  data: AppKeyUpdateManyDataInput;
}

export interface GitHubUserUpdateOneRequiredWithoutIssueCommentsInput {
  create?: Maybe<GitHubUserCreateWithoutIssueCommentsInput>;
  update?: Maybe<GitHubUserUpdateWithoutIssueCommentsDataInput>;
  upsert?: Maybe<GitHubUserUpsertWithoutIssueCommentsInput>;
  connect?: Maybe<GitHubUserWhereUniqueInput>;
}

export interface UserUpsertNestedInput {
  update: UserUpdateDataInput;
  create: UserCreateInput;
}

export interface GitHubUserUpdateWithoutIssueCommentsDataInput {
  createdAtExternal?: Maybe<DateTimeInput>;
  followers?: Maybe<GitHubUserUpdateManyWithoutFollowersInput>;
  following?: Maybe<GitHubUserUpdateManyWithoutFollowingInput>;
  issues?: Maybe<GitHubIssueUpdateManyInput>;
  pullRequests?: Maybe<GitHubPullRequestUpdateManyInput>;
  isBountyHunter?: Maybe<Boolean>;
  isCampusExpert?: Maybe<Boolean>;
  isDeveloperProgramMember?: Maybe<Boolean>;
  isEmployee?: Maybe<Boolean>;
  isHireable?: Maybe<Boolean>;
  isSiteAdmin?: Maybe<Boolean>;
  isViewer?: Maybe<Boolean>;
  url?: Maybe<String>;
  name?: Maybe<String>;
  login?: Maybe<String>;
  avatarUrl?: Maybe<String>;
  bio?: Maybe<String>;
  company?: Maybe<String>;
  email?: Maybe<String>;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface GitHubPullRequestUpdateManyInput {
  create?: Maybe<GitHubPullRequestCreateInput[] | GitHubPullRequestCreateInput>;
  update?: Maybe<
    | GitHubPullRequestUpdateWithWhereUniqueNestedInput[]
    | GitHubPullRequestUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | GitHubPullRequestUpsertWithWhereUniqueNestedInput[]
    | GitHubPullRequestUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<
    GitHubPullRequestWhereUniqueInput[] | GitHubPullRequestWhereUniqueInput
  >;
  connect?: Maybe<
    GitHubPullRequestWhereUniqueInput[] | GitHubPullRequestWhereUniqueInput
  >;
  set?: Maybe<
    GitHubPullRequestWhereUniqueInput[] | GitHubPullRequestWhereUniqueInput
  >;
  disconnect?: Maybe<
    GitHubPullRequestWhereUniqueInput[] | GitHubPullRequestWhereUniqueInput
  >;
  deleteMany?: Maybe<
    GitHubPullRequestScalarWhereInput[] | GitHubPullRequestScalarWhereInput
  >;
  updateMany?: Maybe<
    | GitHubPullRequestUpdateManyWithWhereNestedInput[]
    | GitHubPullRequestUpdateManyWithWhereNestedInput
  >;
}

export interface GitHubWebhookEventSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<GitHubWebhookEventWhereInput>;
  AND?: Maybe<
    | GitHubWebhookEventSubscriptionWhereInput[]
    | GitHubWebhookEventSubscriptionWhereInput
  >;
}

export interface GitHubPullRequestUpdateWithWhereUniqueNestedInput {
  where: GitHubPullRequestWhereUniqueInput;
  data: GitHubPullRequestUpdateDataInput;
}

export interface GitHubReviewThreadSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<GitHubReviewThreadWhereInput>;
  AND?: Maybe<
    | GitHubReviewThreadSubscriptionWhereInput[]
    | GitHubReviewThreadSubscriptionWhereInput
  >;
}

export interface GitHubPullRequestUpdateDataInput {
  createdAtExternal?: Maybe<DateTimeInput>;
  publishedAt?: Maybe<DateTimeInput>;
  closedAt?: Maybe<DateTimeInput>;
  mergedAt?: Maybe<DateTimeInput>;
  assignees?: Maybe<GitHubUserUpdateManyInput>;
  author?: Maybe<GitHubUserUpdateOneRequiredInput>;
  comments?: Maybe<GitHubCommentUpdateManyInput>;
  commits?: Maybe<GitHubCommitUpdateManyWithoutAssociatedPullRequestsInput>;
  files?: Maybe<GitHubFileDiffUpdateManyInput>;
  labels?: Maybe<GitHubLabelUpdateManyWithoutPullRequestsInput>;
  participants?: Maybe<GitHubUserUpdateManyInput>;
  reviewRequests?: Maybe<GitHubReviewRequestUpdateManyWithoutPullRequestInput>;
  reviews?: Maybe<GitHubPullRequestReviewUpdateManyWithoutPullRequestInput>;
  reviewThreads?: Maybe<GitHubReviewThreadUpdateManyWithoutPullRequestInput>;
  mergedBy?: Maybe<GitHubUserUpdateOneInput>;
  number?: Maybe<Int>;
  closed?: Maybe<Boolean>;
  isCrossRepository?: Maybe<Boolean>;
  locked?: Maybe<Boolean>;
  merged?: Maybe<Boolean>;
  additions?: Maybe<Int>;
  changedFiles?: Maybe<Int>;
  deletions?: Maybe<Int>;
  bodyText?: Maybe<String>;
}

export interface GitHubIssueWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdAtExternal?: Maybe<DateTimeInput>;
  createdAtExternal_not?: Maybe<DateTimeInput>;
  createdAtExternal_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAtExternal_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAtExternal_lt?: Maybe<DateTimeInput>;
  createdAtExternal_lte?: Maybe<DateTimeInput>;
  createdAtExternal_gt?: Maybe<DateTimeInput>;
  createdAtExternal_gte?: Maybe<DateTimeInput>;
  updatedAtExternal?: Maybe<DateTimeInput>;
  updatedAtExternal_not?: Maybe<DateTimeInput>;
  updatedAtExternal_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAtExternal_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAtExternal_lt?: Maybe<DateTimeInput>;
  updatedAtExternal_lte?: Maybe<DateTimeInput>;
  updatedAtExternal_gt?: Maybe<DateTimeInput>;
  updatedAtExternal_gte?: Maybe<DateTimeInput>;
  lastEditedAt?: Maybe<DateTimeInput>;
  lastEditedAt_not?: Maybe<DateTimeInput>;
  lastEditedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  lastEditedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  lastEditedAt_lt?: Maybe<DateTimeInput>;
  lastEditedAt_lte?: Maybe<DateTimeInput>;
  lastEditedAt_gt?: Maybe<DateTimeInput>;
  lastEditedAt_gte?: Maybe<DateTimeInput>;
  assignees_some?: Maybe<GitHubUserWhereInput>;
  author?: Maybe<GitHubUserWhereInput>;
  comments_some?: Maybe<GitHubCommentWhereInput>;
  labels_some?: Maybe<GitHubLabelWhereInput>;
  participants_some?: Maybe<GitHubUserWhereInput>;
  bodyText?: Maybe<String>;
  bodyText_not?: Maybe<String>;
  bodyText_in?: Maybe<String[] | String>;
  bodyText_not_in?: Maybe<String[] | String>;
  bodyText_lt?: Maybe<String>;
  bodyText_lte?: Maybe<String>;
  bodyText_gt?: Maybe<String>;
  bodyText_gte?: Maybe<String>;
  bodyText_contains?: Maybe<String>;
  bodyText_not_contains?: Maybe<String>;
  bodyText_starts_with?: Maybe<String>;
  bodyText_not_starts_with?: Maybe<String>;
  bodyText_ends_with?: Maybe<String>;
  bodyText_not_ends_with?: Maybe<String>;
  closed?: Maybe<DateTimeInput>;
  closed_not?: Maybe<DateTimeInput>;
  closed_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  closed_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  closed_lt?: Maybe<DateTimeInput>;
  closed_lte?: Maybe<DateTimeInput>;
  closed_gt?: Maybe<DateTimeInput>;
  closed_gte?: Maybe<DateTimeInput>;
  locked?: Maybe<Boolean>;
  locked_not?: Maybe<Boolean>;
  number?: Maybe<Int>;
  number_not?: Maybe<Int>;
  number_in?: Maybe<Int[] | Int>;
  number_not_in?: Maybe<Int[] | Int>;
  number_lt?: Maybe<Int>;
  number_lte?: Maybe<Int>;
  number_gt?: Maybe<Int>;
  number_gte?: Maybe<Int>;
  state?: Maybe<String>;
  state_not?: Maybe<String>;
  state_in?: Maybe<String[] | String>;
  state_not_in?: Maybe<String[] | String>;
  state_lt?: Maybe<String>;
  state_lte?: Maybe<String>;
  state_gt?: Maybe<String>;
  state_gte?: Maybe<String>;
  state_contains?: Maybe<String>;
  state_not_contains?: Maybe<String>;
  state_starts_with?: Maybe<String>;
  state_not_starts_with?: Maybe<String>;
  state_ends_with?: Maybe<String>;
  state_not_ends_with?: Maybe<String>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  url?: Maybe<String>;
  url_not?: Maybe<String>;
  url_in?: Maybe<String[] | String>;
  url_not_in?: Maybe<String[] | String>;
  url_lt?: Maybe<String>;
  url_lte?: Maybe<String>;
  url_gt?: Maybe<String>;
  url_gte?: Maybe<String>;
  url_contains?: Maybe<String>;
  url_not_contains?: Maybe<String>;
  url_starts_with?: Maybe<String>;
  url_not_starts_with?: Maybe<String>;
  url_ends_with?: Maybe<String>;
  url_not_ends_with?: Maybe<String>;
  AND?: Maybe<GitHubIssueWhereInput[] | GitHubIssueWhereInput>;
}

export interface GitHubCommitUpdateManyWithoutAssociatedPullRequestsInput {
  create?: Maybe<
    | GitHubCommitCreateWithoutAssociatedPullRequestsInput[]
    | GitHubCommitCreateWithoutAssociatedPullRequestsInput
  >;
  delete?: Maybe<GitHubCommitWhereUniqueInput[] | GitHubCommitWhereUniqueInput>;
  connect?: Maybe<
    GitHubCommitWhereUniqueInput[] | GitHubCommitWhereUniqueInput
  >;
  set?: Maybe<GitHubCommitWhereUniqueInput[] | GitHubCommitWhereUniqueInput>;
  disconnect?: Maybe<
    GitHubCommitWhereUniqueInput[] | GitHubCommitWhereUniqueInput
  >;
  update?: Maybe<
    | GitHubCommitUpdateWithWhereUniqueWithoutAssociatedPullRequestsInput[]
    | GitHubCommitUpdateWithWhereUniqueWithoutAssociatedPullRequestsInput
  >;
  upsert?: Maybe<
    | GitHubCommitUpsertWithWhereUniqueWithoutAssociatedPullRequestsInput[]
    | GitHubCommitUpsertWithWhereUniqueWithoutAssociatedPullRequestsInput
  >;
  deleteMany?: Maybe<
    GitHubCommitScalarWhereInput[] | GitHubCommitScalarWhereInput
  >;
  updateMany?: Maybe<
    | GitHubCommitUpdateManyWithWhereNestedInput[]
    | GitHubCommitUpdateManyWithWhereNestedInput
  >;
}

export interface GitHubReviewRequestWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  pullRequest?: Maybe<GitHubPullRequestWhereInput>;
  requestedReviewer?: Maybe<GitHubUserWhereInput>;
  AND?: Maybe<GitHubReviewRequestWhereInput[] | GitHubReviewRequestWhereInput>;
}

export interface GitHubCommitUpdateWithWhereUniqueWithoutAssociatedPullRequestsInput {
  where: GitHubCommitWhereUniqueInput;
  data: GitHubCommitUpdateWithoutAssociatedPullRequestsDataInput;
}

export interface GitHubTopicWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  relatedTopics_some?: Maybe<GitHubTopicWhereInput>;
  stargazers_some?: Maybe<GitHubUserWhereInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<GitHubTopicWhereInput[] | GitHubTopicWhereInput>;
}

export interface GitHubCommitUpdateWithoutAssociatedPullRequestsDataInput {
  author?: Maybe<GitHubUserUpdateOneRequiredInput>;
  committer?: Maybe<GitHubUserUpdateOneRequiredInput>;
  additions?: Maybe<Int>;
  authedDate?: Maybe<DateTimeInput>;
  changedFiles?: Maybe<Int>;
  commitUrl?: Maybe<String>;
  deletions?: Maybe<Int>;
  message?: Maybe<String>;
  messageHeadline?: Maybe<String>;
  pushedDate?: Maybe<DateTimeInput>;
  treeUrl?: Maybe<String>;
  url?: Maybe<String>;
}

export interface GitHubPullRequestSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<GitHubPullRequestWhereInput>;
  AND?: Maybe<
    | GitHubPullRequestSubscriptionWhereInput[]
    | GitHubPullRequestSubscriptionWhereInput
  >;
}

export interface GitHubCommitUpsertWithWhereUniqueWithoutAssociatedPullRequestsInput {
  where: GitHubCommitWhereUniqueInput;
  update: GitHubCommitUpdateWithoutAssociatedPullRequestsDataInput;
  create: GitHubCommitCreateWithoutAssociatedPullRequestsInput;
}

export interface GitHubCommitSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<GitHubCommitWhereInput>;
  AND?: Maybe<
    GitHubCommitSubscriptionWhereInput[] | GitHubCommitSubscriptionWhereInput
  >;
}

export interface GitHubCommitScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  additions?: Maybe<Int>;
  additions_not?: Maybe<Int>;
  additions_in?: Maybe<Int[] | Int>;
  additions_not_in?: Maybe<Int[] | Int>;
  additions_lt?: Maybe<Int>;
  additions_lte?: Maybe<Int>;
  additions_gt?: Maybe<Int>;
  additions_gte?: Maybe<Int>;
  authedDate?: Maybe<DateTimeInput>;
  authedDate_not?: Maybe<DateTimeInput>;
  authedDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  authedDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  authedDate_lt?: Maybe<DateTimeInput>;
  authedDate_lte?: Maybe<DateTimeInput>;
  authedDate_gt?: Maybe<DateTimeInput>;
  authedDate_gte?: Maybe<DateTimeInput>;
  changedFiles?: Maybe<Int>;
  changedFiles_not?: Maybe<Int>;
  changedFiles_in?: Maybe<Int[] | Int>;
  changedFiles_not_in?: Maybe<Int[] | Int>;
  changedFiles_lt?: Maybe<Int>;
  changedFiles_lte?: Maybe<Int>;
  changedFiles_gt?: Maybe<Int>;
  changedFiles_gte?: Maybe<Int>;
  commitUrl?: Maybe<String>;
  commitUrl_not?: Maybe<String>;
  commitUrl_in?: Maybe<String[] | String>;
  commitUrl_not_in?: Maybe<String[] | String>;
  commitUrl_lt?: Maybe<String>;
  commitUrl_lte?: Maybe<String>;
  commitUrl_gt?: Maybe<String>;
  commitUrl_gte?: Maybe<String>;
  commitUrl_contains?: Maybe<String>;
  commitUrl_not_contains?: Maybe<String>;
  commitUrl_starts_with?: Maybe<String>;
  commitUrl_not_starts_with?: Maybe<String>;
  commitUrl_ends_with?: Maybe<String>;
  commitUrl_not_ends_with?: Maybe<String>;
  deletions?: Maybe<Int>;
  deletions_not?: Maybe<Int>;
  deletions_in?: Maybe<Int[] | Int>;
  deletions_not_in?: Maybe<Int[] | Int>;
  deletions_lt?: Maybe<Int>;
  deletions_lte?: Maybe<Int>;
  deletions_gt?: Maybe<Int>;
  deletions_gte?: Maybe<Int>;
  message?: Maybe<String>;
  message_not?: Maybe<String>;
  message_in?: Maybe<String[] | String>;
  message_not_in?: Maybe<String[] | String>;
  message_lt?: Maybe<String>;
  message_lte?: Maybe<String>;
  message_gt?: Maybe<String>;
  message_gte?: Maybe<String>;
  message_contains?: Maybe<String>;
  message_not_contains?: Maybe<String>;
  message_starts_with?: Maybe<String>;
  message_not_starts_with?: Maybe<String>;
  message_ends_with?: Maybe<String>;
  message_not_ends_with?: Maybe<String>;
  messageHeadline?: Maybe<String>;
  messageHeadline_not?: Maybe<String>;
  messageHeadline_in?: Maybe<String[] | String>;
  messageHeadline_not_in?: Maybe<String[] | String>;
  messageHeadline_lt?: Maybe<String>;
  messageHeadline_lte?: Maybe<String>;
  messageHeadline_gt?: Maybe<String>;
  messageHeadline_gte?: Maybe<String>;
  messageHeadline_contains?: Maybe<String>;
  messageHeadline_not_contains?: Maybe<String>;
  messageHeadline_starts_with?: Maybe<String>;
  messageHeadline_not_starts_with?: Maybe<String>;
  messageHeadline_ends_with?: Maybe<String>;
  messageHeadline_not_ends_with?: Maybe<String>;
  pushedDate?: Maybe<DateTimeInput>;
  pushedDate_not?: Maybe<DateTimeInput>;
  pushedDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  pushedDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  pushedDate_lt?: Maybe<DateTimeInput>;
  pushedDate_lte?: Maybe<DateTimeInput>;
  pushedDate_gt?: Maybe<DateTimeInput>;
  pushedDate_gte?: Maybe<DateTimeInput>;
  treeUrl?: Maybe<String>;
  treeUrl_not?: Maybe<String>;
  treeUrl_in?: Maybe<String[] | String>;
  treeUrl_not_in?: Maybe<String[] | String>;
  treeUrl_lt?: Maybe<String>;
  treeUrl_lte?: Maybe<String>;
  treeUrl_gt?: Maybe<String>;
  treeUrl_gte?: Maybe<String>;
  treeUrl_contains?: Maybe<String>;
  treeUrl_not_contains?: Maybe<String>;
  treeUrl_starts_with?: Maybe<String>;
  treeUrl_not_starts_with?: Maybe<String>;
  treeUrl_ends_with?: Maybe<String>;
  treeUrl_not_ends_with?: Maybe<String>;
  url?: Maybe<String>;
  url_not?: Maybe<String>;
  url_in?: Maybe<String[] | String>;
  url_not_in?: Maybe<String[] | String>;
  url_lt?: Maybe<String>;
  url_lte?: Maybe<String>;
  url_gt?: Maybe<String>;
  url_gte?: Maybe<String>;
  url_contains?: Maybe<String>;
  url_not_contains?: Maybe<String>;
  url_starts_with?: Maybe<String>;
  url_not_starts_with?: Maybe<String>;
  url_ends_with?: Maybe<String>;
  url_not_ends_with?: Maybe<String>;
  AND?: Maybe<GitHubCommitScalarWhereInput[] | GitHubCommitScalarWhereInput>;
  OR?: Maybe<GitHubCommitScalarWhereInput[] | GitHubCommitScalarWhereInput>;
  NOT?: Maybe<GitHubCommitScalarWhereInput[] | GitHubCommitScalarWhereInput>;
}

export interface GitHubBranchSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<GitHubBranchWhereInput>;
  AND?: Maybe<
    GitHubBranchSubscriptionWhereInput[] | GitHubBranchSubscriptionWhereInput
  >;
}

export interface GitHubCommitUpdateManyWithWhereNestedInput {
  where: GitHubCommitScalarWhereInput;
  data: GitHubCommitUpdateManyDataInput;
}

export interface AppKeySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<AppKeyWhereInput>;
  AND?: Maybe<AppKeySubscriptionWhereInput[] | AppKeySubscriptionWhereInput>;
}

export interface GitHubCommitUpdateManyDataInput {
  additions?: Maybe<Int>;
  authedDate?: Maybe<DateTimeInput>;
  changedFiles?: Maybe<Int>;
  commitUrl?: Maybe<String>;
  deletions?: Maybe<Int>;
  message?: Maybe<String>;
  messageHeadline?: Maybe<String>;
  pushedDate?: Maybe<DateTimeInput>;
  treeUrl?: Maybe<String>;
  url?: Maybe<String>;
}

export interface RepositoryUpdateManyMutationInput {
  idExternal?: Maybe<String>;
  createdAtExternal?: Maybe<DateTimeInput>;
  updatedAtExternal?: Maybe<DateTimeInput>;
  name?: Maybe<String>;
  description?: Maybe<String>;
  homepageUrl?: Maybe<String>;
  url?: Maybe<String>;
  owner?: Maybe<String>;
  isTracked?: Maybe<Boolean>;
  isFork?: Maybe<Boolean>;
  isLocked?: Maybe<Boolean>;
  isPrivate?: Maybe<Boolean>;
  isArchived?: Maybe<Boolean>;
  isDisabled?: Maybe<Boolean>;
  sshUrl?: Maybe<String>;
}

export interface GitHubFileDiffUpdateManyInput {
  create?: Maybe<GitHubFileDiffCreateInput[] | GitHubFileDiffCreateInput>;
  update?: Maybe<
    | GitHubFileDiffUpdateWithWhereUniqueNestedInput[]
    | GitHubFileDiffUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | GitHubFileDiffUpsertWithWhereUniqueNestedInput[]
    | GitHubFileDiffUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<
    GitHubFileDiffWhereUniqueInput[] | GitHubFileDiffWhereUniqueInput
  >;
  connect?: Maybe<
    GitHubFileDiffWhereUniqueInput[] | GitHubFileDiffWhereUniqueInput
  >;
  set?: Maybe<
    GitHubFileDiffWhereUniqueInput[] | GitHubFileDiffWhereUniqueInput
  >;
  disconnect?: Maybe<
    GitHubFileDiffWhereUniqueInput[] | GitHubFileDiffWhereUniqueInput
  >;
  deleteMany?: Maybe<
    GitHubFileDiffScalarWhereInput[] | GitHubFileDiffScalarWhereInput
  >;
  updateMany?: Maybe<
    | GitHubFileDiffUpdateManyWithWhereNestedInput[]
    | GitHubFileDiffUpdateManyWithWhereNestedInput
  >;
}

export interface GitHubBranchWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  commits_some?: Maybe<GitHubCommitWhereInput>;
  pullRequest?: Maybe<GitHubPullRequestWhereInput>;
  merged?: Maybe<Boolean>;
  merged_not?: Maybe<Boolean>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<GitHubBranchWhereInput[] | GitHubBranchWhereInput>;
}

export interface GitHubFileDiffUpdateWithWhereUniqueNestedInput {
  where: GitHubFileDiffWhereUniqueInput;
  data: GitHubFileDiffUpdateDataInput;
}

export interface UserUpdateOneWithoutPostsInput {
  create?: Maybe<UserCreateWithoutPostsInput>;
  update?: Maybe<UserUpdateWithoutPostsDataInput>;
  upsert?: Maybe<UserUpsertWithoutPostsInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface GitHubFileDiffUpdateDataInput {
  additions?: Maybe<Int>;
  deletions?: Maybe<Int>;
  filepath?: Maybe<String>;
}

export interface UserCreateOneWithoutPostsInput {
  create?: Maybe<UserCreateWithoutPostsInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface GitHubFileDiffUpsertWithWhereUniqueNestedInput {
  where: GitHubFileDiffWhereUniqueInput;
  update: GitHubFileDiffUpdateDataInput;
  create: GitHubFileDiffCreateInput;
}

export interface RepositoryUpsertWithoutWebhookEventsInput {
  update: RepositoryUpdateWithoutWebhookEventsDataInput;
  create: RepositoryCreateWithoutWebhookEventsInput;
}

export interface GitHubFileDiffScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  additions?: Maybe<Int>;
  additions_not?: Maybe<Int>;
  additions_in?: Maybe<Int[] | Int>;
  additions_not_in?: Maybe<Int[] | Int>;
  additions_lt?: Maybe<Int>;
  additions_lte?: Maybe<Int>;
  additions_gt?: Maybe<Int>;
  additions_gte?: Maybe<Int>;
  deletions?: Maybe<Int>;
  deletions_not?: Maybe<Int>;
  deletions_in?: Maybe<Int[] | Int>;
  deletions_not_in?: Maybe<Int[] | Int>;
  deletions_lt?: Maybe<Int>;
  deletions_lte?: Maybe<Int>;
  deletions_gt?: Maybe<Int>;
  deletions_gte?: Maybe<Int>;
  filepath?: Maybe<String>;
  filepath_not?: Maybe<String>;
  filepath_in?: Maybe<String[] | String>;
  filepath_not_in?: Maybe<String[] | String>;
  filepath_lt?: Maybe<String>;
  filepath_lte?: Maybe<String>;
  filepath_gt?: Maybe<String>;
  filepath_gte?: Maybe<String>;
  filepath_contains?: Maybe<String>;
  filepath_not_contains?: Maybe<String>;
  filepath_starts_with?: Maybe<String>;
  filepath_not_starts_with?: Maybe<String>;
  filepath_ends_with?: Maybe<String>;
  filepath_not_ends_with?: Maybe<String>;
  AND?: Maybe<
    GitHubFileDiffScalarWhereInput[] | GitHubFileDiffScalarWhereInput
  >;
  OR?: Maybe<GitHubFileDiffScalarWhereInput[] | GitHubFileDiffScalarWhereInput>;
  NOT?: Maybe<
    GitHubFileDiffScalarWhereInput[] | GitHubFileDiffScalarWhereInput
  >;
}

export interface GitHubWebhookEventUpdateInput {
  repository?: Maybe<RepositoryUpdateOneRequiredWithoutWebhookEventsInput>;
  eventType?: Maybe<String>;
  action?: Maybe<String>;
  sender?: Maybe<String>;
}

export interface GitHubFileDiffUpdateManyWithWhereNestedInput {
  where: GitHubFileDiffScalarWhereInput;
  data: GitHubFileDiffUpdateManyDataInput;
}

export interface GitHubWebhookEventCreateInput {
  id?: Maybe<ID_Input>;
  repository: RepositoryCreateOneWithoutWebhookEventsInput;
  eventType: String;
  action?: Maybe<String>;
  sender: String;
}

export interface GitHubFileDiffUpdateManyDataInput {
  additions?: Maybe<Int>;
  deletions?: Maybe<Int>;
  filepath?: Maybe<String>;
}

export interface GitHubTopicUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface GitHubLabelUpdateManyWithoutPullRequestsInput {
  create?: Maybe<
    | GitHubLabelCreateWithoutPullRequestsInput[]
    | GitHubLabelCreateWithoutPullRequestsInput
  >;
  delete?: Maybe<GitHubLabelWhereUniqueInput[] | GitHubLabelWhereUniqueInput>;
  connect?: Maybe<GitHubLabelWhereUniqueInput[] | GitHubLabelWhereUniqueInput>;
  set?: Maybe<GitHubLabelWhereUniqueInput[] | GitHubLabelWhereUniqueInput>;
  disconnect?: Maybe<
    GitHubLabelWhereUniqueInput[] | GitHubLabelWhereUniqueInput
  >;
  update?: Maybe<
    | GitHubLabelUpdateWithWhereUniqueWithoutPullRequestsInput[]
    | GitHubLabelUpdateWithWhereUniqueWithoutPullRequestsInput
  >;
  upsert?: Maybe<
    | GitHubLabelUpsertWithWhereUniqueWithoutPullRequestsInput[]
    | GitHubLabelUpsertWithWhereUniqueWithoutPullRequestsInput
  >;
  deleteMany?: Maybe<
    GitHubLabelScalarWhereInput[] | GitHubLabelScalarWhereInput
  >;
  updateMany?: Maybe<
    | GitHubLabelUpdateManyWithWhereNestedInput[]
    | GitHubLabelUpdateManyWithWhereNestedInput
  >;
}

export interface GitHubPullRequestUpsertWithoutReviewThreadsInput {
  update: GitHubPullRequestUpdateWithoutReviewThreadsDataInput;
  create: GitHubPullRequestCreateWithoutReviewThreadsInput;
}

export interface GitHubLabelUpdateWithWhereUniqueWithoutPullRequestsInput {
  where: GitHubLabelWhereUniqueInput;
  data: GitHubLabelUpdateWithoutPullRequestsDataInput;
}

export interface GitHubReviewThreadUpdateInput {
  comments?: Maybe<GitHubCommentUpdateManyInput>;
  pullRequest?: Maybe<
    GitHubPullRequestUpdateOneRequiredWithoutReviewThreadsInput
  >;
  repository?: Maybe<GitHubRepositoryUpdateOneRequiredInput>;
  resolvedBy?: Maybe<GitHubUserUpdateOneRequiredInput>;
  isResolved?: Maybe<Boolean>;
}

export interface GitHubLabelUpdateWithoutPullRequestsDataInput {
  updatedAtExternal?: Maybe<DateTimeInput>;
  createdAtExternal?: Maybe<DateTimeInput>;
  issues?: Maybe<GitHubIssueUpdateManyWithoutLabelsInput>;
  color?: Maybe<String>;
  description?: Maybe<String>;
  name?: Maybe<String>;
  url?: Maybe<String>;
}

export interface GitHubReviewThreadCreateInput {
  id?: Maybe<ID_Input>;
  comments?: Maybe<GitHubCommentCreateManyInput>;
  pullRequest: GitHubPullRequestCreateOneWithoutReviewThreadsInput;
  repository: GitHubRepositoryCreateOneInput;
  resolvedBy: GitHubUserCreateOneInput;
  isResolved: Boolean;
}

export interface GitHubIssueUpdateManyWithoutLabelsInput {
  create?: Maybe<
    GitHubIssueCreateWithoutLabelsInput[] | GitHubIssueCreateWithoutLabelsInput
  >;
  delete?: Maybe<GitHubIssueWhereUniqueInput[] | GitHubIssueWhereUniqueInput>;
  connect?: Maybe<GitHubIssueWhereUniqueInput[] | GitHubIssueWhereUniqueInput>;
  set?: Maybe<GitHubIssueWhereUniqueInput[] | GitHubIssueWhereUniqueInput>;
  disconnect?: Maybe<
    GitHubIssueWhereUniqueInput[] | GitHubIssueWhereUniqueInput
  >;
  update?: Maybe<
    | GitHubIssueUpdateWithWhereUniqueWithoutLabelsInput[]
    | GitHubIssueUpdateWithWhereUniqueWithoutLabelsInput
  >;
  upsert?: Maybe<
    | GitHubIssueUpsertWithWhereUniqueWithoutLabelsInput[]
    | GitHubIssueUpsertWithWhereUniqueWithoutLabelsInput
  >;
  deleteMany?: Maybe<
    GitHubIssueScalarWhereInput[] | GitHubIssueScalarWhereInput
  >;
  updateMany?: Maybe<
    | GitHubIssueUpdateManyWithWhereNestedInput[]
    | GitHubIssueUpdateManyWithWhereNestedInput
  >;
}

export interface GitHubPullRequestUpdateOneRequiredWithoutReviewRequestsInput {
  create?: Maybe<GitHubPullRequestCreateWithoutReviewRequestsInput>;
  update?: Maybe<GitHubPullRequestUpdateWithoutReviewRequestsDataInput>;
  upsert?: Maybe<GitHubPullRequestUpsertWithoutReviewRequestsInput>;
  connect?: Maybe<GitHubPullRequestWhereUniqueInput>;
}

export interface GitHubIssueUpdateWithWhereUniqueWithoutLabelsInput {
  where: GitHubIssueWhereUniqueInput;
  data: GitHubIssueUpdateWithoutLabelsDataInput;
}

export interface GitHubPullRequestCreateOneWithoutReviewRequestsInput {
  create?: Maybe<GitHubPullRequestCreateWithoutReviewRequestsInput>;
  connect?: Maybe<GitHubPullRequestWhereUniqueInput>;
}

export interface GitHubIssueUpdateWithoutLabelsDataInput {
  createdAtExternal?: Maybe<DateTimeInput>;
  updatedAtExternal?: Maybe<DateTimeInput>;
  lastEditedAt?: Maybe<DateTimeInput>;
  assignees?: Maybe<GitHubUserUpdateManyInput>;
  author?: Maybe<GitHubUserUpdateOneRequiredInput>;
  comments?: Maybe<GitHubCommentUpdateManyInput>;
  participants?: Maybe<GitHubUserUpdateManyInput>;
  bodyText?: Maybe<String>;
  closed?: Maybe<DateTimeInput>;
  locked?: Maybe<Boolean>;
  number?: Maybe<Int>;
  state?: Maybe<String>;
  title?: Maybe<String>;
  url?: Maybe<String>;
}

export interface GitHubRepositoryUpdateInput {
  updatedAtExternal?: Maybe<DateTimeInput>;
  collaborators?: Maybe<GitHubUserUpdateManyInput>;
  owner?: Maybe<GitHubUserUpdateOneRequiredInput>;
  repositoryTopics?: Maybe<GitHubTopicUpdateManyInput>;
  stargazers?: Maybe<GitHubUserUpdateManyInput>;
  watchers?: Maybe<GitHubUserUpdateManyInput>;
  hasBranchRules?: Maybe<Boolean>;
  hasContributingGuidelines?: Maybe<Boolean>;
  hasPullRequestTemplate?: Maybe<Boolean>;
  hasReadMe?: Maybe<Boolean>;
  hasWiki?: Maybe<Boolean>;
  isArchived?: Maybe<Boolean>;
  isDisabled?: Maybe<Boolean>;
  isFork?: Maybe<Boolean>;
  isLocked?: Maybe<Boolean>;
  isPrivate?: Maybe<Boolean>;
  description?: Maybe<String>;
  license?: Maybe<String>;
  name?: Maybe<String>;
  primaryLanguage?: Maybe<String>;
  sshUrl?: Maybe<String>;
  url?: Maybe<String>;
}

export interface GitHubIssueUpsertWithWhereUniqueWithoutLabelsInput {
  where: GitHubIssueWhereUniqueInput;
  update: GitHubIssueUpdateWithoutLabelsDataInput;
  create: GitHubIssueCreateWithoutLabelsInput;
}

export interface GitHubPullRequestUpdateWithoutReviewsDataInput {
  createdAtExternal?: Maybe<DateTimeInput>;
  publishedAt?: Maybe<DateTimeInput>;
  closedAt?: Maybe<DateTimeInput>;
  mergedAt?: Maybe<DateTimeInput>;
  assignees?: Maybe<GitHubUserUpdateManyInput>;
  author?: Maybe<GitHubUserUpdateOneRequiredInput>;
  comments?: Maybe<GitHubCommentUpdateManyInput>;
  commits?: Maybe<GitHubCommitUpdateManyWithoutAssociatedPullRequestsInput>;
  files?: Maybe<GitHubFileDiffUpdateManyInput>;
  labels?: Maybe<GitHubLabelUpdateManyWithoutPullRequestsInput>;
  participants?: Maybe<GitHubUserUpdateManyInput>;
  reviewRequests?: Maybe<GitHubReviewRequestUpdateManyWithoutPullRequestInput>;
  reviewThreads?: Maybe<GitHubReviewThreadUpdateManyWithoutPullRequestInput>;
  mergedBy?: Maybe<GitHubUserUpdateOneInput>;
  number?: Maybe<Int>;
  closed?: Maybe<Boolean>;
  isCrossRepository?: Maybe<Boolean>;
  locked?: Maybe<Boolean>;
  merged?: Maybe<Boolean>;
  additions?: Maybe<Int>;
  changedFiles?: Maybe<Int>;
  deletions?: Maybe<Int>;
  bodyText?: Maybe<String>;
}

export interface GitHubIssueScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdAtExternal?: Maybe<DateTimeInput>;
  createdAtExternal_not?: Maybe<DateTimeInput>;
  createdAtExternal_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAtExternal_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAtExternal_lt?: Maybe<DateTimeInput>;
  createdAtExternal_lte?: Maybe<DateTimeInput>;
  createdAtExternal_gt?: Maybe<DateTimeInput>;
  createdAtExternal_gte?: Maybe<DateTimeInput>;
  updatedAtExternal?: Maybe<DateTimeInput>;
  updatedAtExternal_not?: Maybe<DateTimeInput>;
  updatedAtExternal_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAtExternal_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAtExternal_lt?: Maybe<DateTimeInput>;
  updatedAtExternal_lte?: Maybe<DateTimeInput>;
  updatedAtExternal_gt?: Maybe<DateTimeInput>;
  updatedAtExternal_gte?: Maybe<DateTimeInput>;
  lastEditedAt?: Maybe<DateTimeInput>;
  lastEditedAt_not?: Maybe<DateTimeInput>;
  lastEditedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  lastEditedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  lastEditedAt_lt?: Maybe<DateTimeInput>;
  lastEditedAt_lte?: Maybe<DateTimeInput>;
  lastEditedAt_gt?: Maybe<DateTimeInput>;
  lastEditedAt_gte?: Maybe<DateTimeInput>;
  bodyText?: Maybe<String>;
  bodyText_not?: Maybe<String>;
  bodyText_in?: Maybe<String[] | String>;
  bodyText_not_in?: Maybe<String[] | String>;
  bodyText_lt?: Maybe<String>;
  bodyText_lte?: Maybe<String>;
  bodyText_gt?: Maybe<String>;
  bodyText_gte?: Maybe<String>;
  bodyText_contains?: Maybe<String>;
  bodyText_not_contains?: Maybe<String>;
  bodyText_starts_with?: Maybe<String>;
  bodyText_not_starts_with?: Maybe<String>;
  bodyText_ends_with?: Maybe<String>;
  bodyText_not_ends_with?: Maybe<String>;
  closed?: Maybe<DateTimeInput>;
  closed_not?: Maybe<DateTimeInput>;
  closed_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  closed_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  closed_lt?: Maybe<DateTimeInput>;
  closed_lte?: Maybe<DateTimeInput>;
  closed_gt?: Maybe<DateTimeInput>;
  closed_gte?: Maybe<DateTimeInput>;
  locked?: Maybe<Boolean>;
  locked_not?: Maybe<Boolean>;
  number?: Maybe<Int>;
  number_not?: Maybe<Int>;
  number_in?: Maybe<Int[] | Int>;
  number_not_in?: Maybe<Int[] | Int>;
  number_lt?: Maybe<Int>;
  number_lte?: Maybe<Int>;
  number_gt?: Maybe<Int>;
  number_gte?: Maybe<Int>;
  state?: Maybe<String>;
  state_not?: Maybe<String>;
  state_in?: Maybe<String[] | String>;
  state_not_in?: Maybe<String[] | String>;
  state_lt?: Maybe<String>;
  state_lte?: Maybe<String>;
  state_gt?: Maybe<String>;
  state_gte?: Maybe<String>;
  state_contains?: Maybe<String>;
  state_not_contains?: Maybe<String>;
  state_starts_with?: Maybe<String>;
  state_not_starts_with?: Maybe<String>;
  state_ends_with?: Maybe<String>;
  state_not_ends_with?: Maybe<String>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  url?: Maybe<String>;
  url_not?: Maybe<String>;
  url_in?: Maybe<String[] | String>;
  url_not_in?: Maybe<String[] | String>;
  url_lt?: Maybe<String>;
  url_lte?: Maybe<String>;
  url_gt?: Maybe<String>;
  url_gte?: Maybe<String>;
  url_contains?: Maybe<String>;
  url_not_contains?: Maybe<String>;
  url_starts_with?: Maybe<String>;
  url_not_starts_with?: Maybe<String>;
  url_ends_with?: Maybe<String>;
  url_not_ends_with?: Maybe<String>;
  AND?: Maybe<GitHubIssueScalarWhereInput[] | GitHubIssueScalarWhereInput>;
  OR?: Maybe<GitHubIssueScalarWhereInput[] | GitHubIssueScalarWhereInput>;
  NOT?: Maybe<GitHubIssueScalarWhereInput[] | GitHubIssueScalarWhereInput>;
}

export interface GitHubPullRequestCreateWithoutReviewsInput {
  id?: Maybe<ID_Input>;
  createdAtExternal: DateTimeInput;
  publishedAt?: Maybe<DateTimeInput>;
  closedAt?: Maybe<DateTimeInput>;
  mergedAt?: Maybe<DateTimeInput>;
  assignees?: Maybe<GitHubUserCreateManyInput>;
  author: GitHubUserCreateOneInput;
  comments?: Maybe<GitHubCommentCreateManyInput>;
  commits?: Maybe<GitHubCommitCreateManyWithoutAssociatedPullRequestsInput>;
  files?: Maybe<GitHubFileDiffCreateManyInput>;
  labels?: Maybe<GitHubLabelCreateManyWithoutPullRequestsInput>;
  participants?: Maybe<GitHubUserCreateManyInput>;
  reviewRequests?: Maybe<GitHubReviewRequestCreateManyWithoutPullRequestInput>;
  reviewThreads?: Maybe<GitHubReviewThreadCreateManyWithoutPullRequestInput>;
  mergedBy?: Maybe<GitHubUserCreateOneInput>;
  number: Int;
  closed: Boolean;
  isCrossRepository: Boolean;
  locked: Boolean;
  merged: Boolean;
  additions: Int;
  changedFiles: Int;
  deletions: Int;
  bodyText: String;
}

export interface GitHubIssueUpdateManyWithWhereNestedInput {
  where: GitHubIssueScalarWhereInput;
  data: GitHubIssueUpdateManyDataInput;
}

export interface GitHubPullRequestUpdateManyMutationInput {
  createdAtExternal?: Maybe<DateTimeInput>;
  publishedAt?: Maybe<DateTimeInput>;
  closedAt?: Maybe<DateTimeInput>;
  mergedAt?: Maybe<DateTimeInput>;
  number?: Maybe<Int>;
  closed?: Maybe<Boolean>;
  isCrossRepository?: Maybe<Boolean>;
  locked?: Maybe<Boolean>;
  merged?: Maybe<Boolean>;
  additions?: Maybe<Int>;
  changedFiles?: Maybe<Int>;
  deletions?: Maybe<Int>;
  bodyText?: Maybe<String>;
}

export interface GitHubIssueUpdateManyDataInput {
  createdAtExternal?: Maybe<DateTimeInput>;
  updatedAtExternal?: Maybe<DateTimeInput>;
  lastEditedAt?: Maybe<DateTimeInput>;
  bodyText?: Maybe<String>;
  closed?: Maybe<DateTimeInput>;
  locked?: Maybe<Boolean>;
  number?: Maybe<Int>;
  state?: Maybe<String>;
  title?: Maybe<String>;
  url?: Maybe<String>;
}

export interface GitHubLabelUpdateInput {
  updatedAtExternal?: Maybe<DateTimeInput>;
  createdAtExternal?: Maybe<DateTimeInput>;
  issues?: Maybe<GitHubIssueUpdateManyWithoutLabelsInput>;
  pullRequests?: Maybe<GitHubPullRequestUpdateManyWithoutLabelsInput>;
  color?: Maybe<String>;
  description?: Maybe<String>;
  name?: Maybe<String>;
  url?: Maybe<String>;
}

export interface GitHubLabelUpsertWithWhereUniqueWithoutPullRequestsInput {
  where: GitHubLabelWhereUniqueInput;
  update: GitHubLabelUpdateWithoutPullRequestsDataInput;
  create: GitHubLabelCreateWithoutPullRequestsInput;
}

export interface GitHubIssueUpdateInput {
  createdAtExternal?: Maybe<DateTimeInput>;
  updatedAtExternal?: Maybe<DateTimeInput>;
  lastEditedAt?: Maybe<DateTimeInput>;
  assignees?: Maybe<GitHubUserUpdateManyInput>;
  author?: Maybe<GitHubUserUpdateOneRequiredInput>;
  comments?: Maybe<GitHubCommentUpdateManyInput>;
  labels?: Maybe<GitHubLabelUpdateManyWithoutIssuesInput>;
  participants?: Maybe<GitHubUserUpdateManyInput>;
  bodyText?: Maybe<String>;
  closed?: Maybe<DateTimeInput>;
  locked?: Maybe<Boolean>;
  number?: Maybe<Int>;
  state?: Maybe<String>;
  title?: Maybe<String>;
  url?: Maybe<String>;
}

export interface GitHubLabelScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  updatedAtExternal?: Maybe<DateTimeInput>;
  updatedAtExternal_not?: Maybe<DateTimeInput>;
  updatedAtExternal_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAtExternal_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAtExternal_lt?: Maybe<DateTimeInput>;
  updatedAtExternal_lte?: Maybe<DateTimeInput>;
  updatedAtExternal_gt?: Maybe<DateTimeInput>;
  updatedAtExternal_gte?: Maybe<DateTimeInput>;
  createdAtExternal?: Maybe<DateTimeInput>;
  createdAtExternal_not?: Maybe<DateTimeInput>;
  createdAtExternal_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAtExternal_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAtExternal_lt?: Maybe<DateTimeInput>;
  createdAtExternal_lte?: Maybe<DateTimeInput>;
  createdAtExternal_gt?: Maybe<DateTimeInput>;
  createdAtExternal_gte?: Maybe<DateTimeInput>;
  color?: Maybe<String>;
  color_not?: Maybe<String>;
  color_in?: Maybe<String[] | String>;
  color_not_in?: Maybe<String[] | String>;
  color_lt?: Maybe<String>;
  color_lte?: Maybe<String>;
  color_gt?: Maybe<String>;
  color_gte?: Maybe<String>;
  color_contains?: Maybe<String>;
  color_not_contains?: Maybe<String>;
  color_starts_with?: Maybe<String>;
  color_not_starts_with?: Maybe<String>;
  color_ends_with?: Maybe<String>;
  color_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  url?: Maybe<String>;
  url_not?: Maybe<String>;
  url_in?: Maybe<String[] | String>;
  url_not_in?: Maybe<String[] | String>;
  url_lt?: Maybe<String>;
  url_lte?: Maybe<String>;
  url_gt?: Maybe<String>;
  url_gte?: Maybe<String>;
  url_contains?: Maybe<String>;
  url_not_contains?: Maybe<String>;
  url_starts_with?: Maybe<String>;
  url_not_starts_with?: Maybe<String>;
  url_ends_with?: Maybe<String>;
  url_not_ends_with?: Maybe<String>;
  AND?: Maybe<GitHubLabelScalarWhereInput[] | GitHubLabelScalarWhereInput>;
  OR?: Maybe<GitHubLabelScalarWhereInput[] | GitHubLabelScalarWhereInput>;
  NOT?: Maybe<GitHubLabelScalarWhereInput[] | GitHubLabelScalarWhereInput>;
}

export interface AppKeyCreateInput {
  id?: Maybe<ID_Input>;
  user: UserCreateOneWithoutKeysInput;
  repositories?: Maybe<RepositoryCreateManyWithoutAppKeyInput>;
  key: String;
  name?: Maybe<String>;
}

export interface GitHubLabelUpdateManyWithWhereNestedInput {
  where: GitHubLabelScalarWhereInput;
  data: GitHubLabelUpdateManyDataInput;
}

export interface PostCreateWithoutAuthorInput {
  id?: Maybe<ID_Input>;
  title: String;
  published?: Maybe<Boolean>;
}

export interface GitHubLabelUpdateManyDataInput {
  updatedAtExternal?: Maybe<DateTimeInput>;
  createdAtExternal?: Maybe<DateTimeInput>;
  color?: Maybe<String>;
  description?: Maybe<String>;
  name?: Maybe<String>;
  url?: Maybe<String>;
}

export interface AppKeyCreateWithoutRepositoriesInput {
  id?: Maybe<ID_Input>;
  user: UserCreateOneWithoutKeysInput;
  key: String;
  name?: Maybe<String>;
}

export interface GitHubReviewRequestUpdateManyWithoutPullRequestInput {
  create?: Maybe<
    | GitHubReviewRequestCreateWithoutPullRequestInput[]
    | GitHubReviewRequestCreateWithoutPullRequestInput
  >;
  delete?: Maybe<
    GitHubReviewRequestWhereUniqueInput[] | GitHubReviewRequestWhereUniqueInput
  >;
  connect?: Maybe<
    GitHubReviewRequestWhereUniqueInput[] | GitHubReviewRequestWhereUniqueInput
  >;
  set?: Maybe<
    GitHubReviewRequestWhereUniqueInput[] | GitHubReviewRequestWhereUniqueInput
  >;
  disconnect?: Maybe<
    GitHubReviewRequestWhereUniqueInput[] | GitHubReviewRequestWhereUniqueInput
  >;
  update?: Maybe<
    | GitHubReviewRequestUpdateWithWhereUniqueWithoutPullRequestInput[]
    | GitHubReviewRequestUpdateWithWhereUniqueWithoutPullRequestInput
  >;
  upsert?: Maybe<
    | GitHubReviewRequestUpsertWithWhereUniqueWithoutPullRequestInput[]
    | GitHubReviewRequestUpsertWithWhereUniqueWithoutPullRequestInput
  >;
  deleteMany?: Maybe<
    GitHubReviewRequestScalarWhereInput[] | GitHubReviewRequestScalarWhereInput
  >;
}

export interface GameCreateWithoutRepositoryInput {
  id?: Maybe<ID_Input>;
  title: String;
  owner: UserCreateOneInput;
  type: String;
}

export interface GitHubReviewRequestUpdateWithWhereUniqueWithoutPullRequestInput {
  where: GitHubReviewRequestWhereUniqueInput;
  data: GitHubReviewRequestUpdateWithoutPullRequestDataInput;
}

export interface AppKeyCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  repositories?: Maybe<RepositoryCreateManyWithoutAppKeyInput>;
  key: String;
  name?: Maybe<String>;
}

export interface GitHubReviewRequestUpdateWithoutPullRequestDataInput {
  requestedReviewer?: Maybe<GitHubUserUpdateOneRequiredInput>;
}

export interface UserCreateWithoutAddedRepositoriesInput {
  id?: Maybe<ID_Input>;
  posts?: Maybe<PostCreateManyWithoutAuthorInput>;
  keys?: Maybe<AppKeyCreateManyWithoutUserInput>;
  email: String;
  name?: Maybe<String>;
  password: String;
  role?: Maybe<Role>;
  gitLogin: String;
}

export interface GitHubReviewRequestUpsertWithWhereUniqueWithoutPullRequestInput {
  where: GitHubReviewRequestWhereUniqueInput;
  update: GitHubReviewRequestUpdateWithoutPullRequestDataInput;
  create: GitHubReviewRequestCreateWithoutPullRequestInput;
}

export interface PostUpdateManyWithoutAuthorInput {
  create?: Maybe<PostCreateWithoutAuthorInput[] | PostCreateWithoutAuthorInput>;
  delete?: Maybe<PostWhereUniqueInput[] | PostWhereUniqueInput>;
  connect?: Maybe<PostWhereUniqueInput[] | PostWhereUniqueInput>;
  set?: Maybe<PostWhereUniqueInput[] | PostWhereUniqueInput>;
  disconnect?: Maybe<PostWhereUniqueInput[] | PostWhereUniqueInput>;
  update?: Maybe<
    | PostUpdateWithWhereUniqueWithoutAuthorInput[]
    | PostUpdateWithWhereUniqueWithoutAuthorInput
  >;
  upsert?: Maybe<
    | PostUpsertWithWhereUniqueWithoutAuthorInput[]
    | PostUpsertWithWhereUniqueWithoutAuthorInput
  >;
  deleteMany?: Maybe<PostScalarWhereInput[] | PostScalarWhereInput>;
  updateMany?: Maybe<
    PostUpdateManyWithWhereNestedInput[] | PostUpdateManyWithWhereNestedInput
  >;
}

export interface GitHubReviewRequestScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<
    GitHubReviewRequestScalarWhereInput[] | GitHubReviewRequestScalarWhereInput
  >;
  OR?: Maybe<
    GitHubReviewRequestScalarWhereInput[] | GitHubReviewRequestScalarWhereInput
  >;
  NOT?: Maybe<
    GitHubReviewRequestScalarWhereInput[] | GitHubReviewRequestScalarWhereInput
  >;
}

export interface PostScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  published?: Maybe<Boolean>;
  published_not?: Maybe<Boolean>;
  AND?: Maybe<PostScalarWhereInput[] | PostScalarWhereInput>;
  OR?: Maybe<PostScalarWhereInput[] | PostScalarWhereInput>;
  NOT?: Maybe<PostScalarWhereInput[] | PostScalarWhereInput>;
}

export interface GitHubPullRequestReviewUpdateManyWithoutPullRequestInput {
  create?: Maybe<
    | GitHubPullRequestReviewCreateWithoutPullRequestInput[]
    | GitHubPullRequestReviewCreateWithoutPullRequestInput
  >;
  delete?: Maybe<
    | GitHubPullRequestReviewWhereUniqueInput[]
    | GitHubPullRequestReviewWhereUniqueInput
  >;
  connect?: Maybe<
    | GitHubPullRequestReviewWhereUniqueInput[]
    | GitHubPullRequestReviewWhereUniqueInput
  >;
  set?: Maybe<
    | GitHubPullRequestReviewWhereUniqueInput[]
    | GitHubPullRequestReviewWhereUniqueInput
  >;
  disconnect?: Maybe<
    | GitHubPullRequestReviewWhereUniqueInput[]
    | GitHubPullRequestReviewWhereUniqueInput
  >;
  update?: Maybe<
    | GitHubPullRequestReviewUpdateWithWhereUniqueWithoutPullRequestInput[]
    | GitHubPullRequestReviewUpdateWithWhereUniqueWithoutPullRequestInput
  >;
  upsert?: Maybe<
    | GitHubPullRequestReviewUpsertWithWhereUniqueWithoutPullRequestInput[]
    | GitHubPullRequestReviewUpsertWithWhereUniqueWithoutPullRequestInput
  >;
  deleteMany?: Maybe<
    | GitHubPullRequestReviewScalarWhereInput[]
    | GitHubPullRequestReviewScalarWhereInput
  >;
  updateMany?: Maybe<
    | GitHubPullRequestReviewUpdateManyWithWhereNestedInput[]
    | GitHubPullRequestReviewUpdateManyWithWhereNestedInput
  >;
}

export interface RepositoryUpdateWithWhereUniqueWithoutAddedByInput {
  where: RepositoryWhereUniqueInput;
  data: RepositoryUpdateWithoutAddedByDataInput;
}

export interface GitHubPullRequestReviewUpdateWithWhereUniqueWithoutPullRequestInput {
  where: GitHubPullRequestReviewWhereUniqueInput;
  data: GitHubPullRequestReviewUpdateWithoutPullRequestDataInput;
}

export interface AppKeyUpsertWithoutRepositoriesInput {
  update: AppKeyUpdateWithoutRepositoriesDataInput;
  create: AppKeyCreateWithoutRepositoriesInput;
}

export interface GitHubPullRequestReviewUpdateWithoutPullRequestDataInput {
  createdAtExternal?: Maybe<DateTimeInput>;
  updatedAtExternal?: Maybe<DateTimeInput>;
  submittedAt?: Maybe<DateTimeInput>;
  lastEditedAt?: Maybe<DateTimeInput>;
  publishedAt?: Maybe<DateTimeInput>;
  author?: Maybe<GitHubUserUpdateOneRequiredInput>;
  comments?: Maybe<GitHubCommentUpdateManyInput>;
  commit?: Maybe<GitHubCommitUpdateManyInput>;
  state?: Maybe<String>;
  bodyText?: Maybe<String>;
  url?: Maybe<String>;
}

export interface GitHubWebhookEventUpsertWithWhereUniqueWithoutRepositoryInput {
  where: GitHubWebhookEventWhereUniqueInput;
  update: GitHubWebhookEventUpdateWithoutRepositoryDataInput;
  create: GitHubWebhookEventCreateWithoutRepositoryInput;
}

export interface GitHubPullRequestReviewUpsertWithWhereUniqueWithoutPullRequestInput {
  where: GitHubPullRequestReviewWhereUniqueInput;
  update: GitHubPullRequestReviewUpdateWithoutPullRequestDataInput;
  create: GitHubPullRequestReviewCreateWithoutPullRequestInput;
}

export interface GameUpdateOneWithoutRepositoryInput {
  create?: Maybe<GameCreateWithoutRepositoryInput>;
  update?: Maybe<GameUpdateWithoutRepositoryDataInput>;
  upsert?: Maybe<GameUpsertWithoutRepositoryInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<GameWhereUniqueInput>;
}

export interface GitHubPullRequestReviewScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdAtExternal?: Maybe<DateTimeInput>;
  createdAtExternal_not?: Maybe<DateTimeInput>;
  createdAtExternal_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAtExternal_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAtExternal_lt?: Maybe<DateTimeInput>;
  createdAtExternal_lte?: Maybe<DateTimeInput>;
  createdAtExternal_gt?: Maybe<DateTimeInput>;
  createdAtExternal_gte?: Maybe<DateTimeInput>;
  updatedAtExternal?: Maybe<DateTimeInput>;
  updatedAtExternal_not?: Maybe<DateTimeInput>;
  updatedAtExternal_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAtExternal_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAtExternal_lt?: Maybe<DateTimeInput>;
  updatedAtExternal_lte?: Maybe<DateTimeInput>;
  updatedAtExternal_gt?: Maybe<DateTimeInput>;
  updatedAtExternal_gte?: Maybe<DateTimeInput>;
  submittedAt?: Maybe<DateTimeInput>;
  submittedAt_not?: Maybe<DateTimeInput>;
  submittedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  submittedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  submittedAt_lt?: Maybe<DateTimeInput>;
  submittedAt_lte?: Maybe<DateTimeInput>;
  submittedAt_gt?: Maybe<DateTimeInput>;
  submittedAt_gte?: Maybe<DateTimeInput>;
  lastEditedAt?: Maybe<DateTimeInput>;
  lastEditedAt_not?: Maybe<DateTimeInput>;
  lastEditedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  lastEditedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  lastEditedAt_lt?: Maybe<DateTimeInput>;
  lastEditedAt_lte?: Maybe<DateTimeInput>;
  lastEditedAt_gt?: Maybe<DateTimeInput>;
  lastEditedAt_gte?: Maybe<DateTimeInput>;
  publishedAt?: Maybe<DateTimeInput>;
  publishedAt_not?: Maybe<DateTimeInput>;
  publishedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  publishedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  publishedAt_lt?: Maybe<DateTimeInput>;
  publishedAt_lte?: Maybe<DateTimeInput>;
  publishedAt_gt?: Maybe<DateTimeInput>;
  publishedAt_gte?: Maybe<DateTimeInput>;
  state?: Maybe<String>;
  state_not?: Maybe<String>;
  state_in?: Maybe<String[] | String>;
  state_not_in?: Maybe<String[] | String>;
  state_lt?: Maybe<String>;
  state_lte?: Maybe<String>;
  state_gt?: Maybe<String>;
  state_gte?: Maybe<String>;
  state_contains?: Maybe<String>;
  state_not_contains?: Maybe<String>;
  state_starts_with?: Maybe<String>;
  state_not_starts_with?: Maybe<String>;
  state_ends_with?: Maybe<String>;
  state_not_ends_with?: Maybe<String>;
  bodyText?: Maybe<String>;
  bodyText_not?: Maybe<String>;
  bodyText_in?: Maybe<String[] | String>;
  bodyText_not_in?: Maybe<String[] | String>;
  bodyText_lt?: Maybe<String>;
  bodyText_lte?: Maybe<String>;
  bodyText_gt?: Maybe<String>;
  bodyText_gte?: Maybe<String>;
  bodyText_contains?: Maybe<String>;
  bodyText_not_contains?: Maybe<String>;
  bodyText_starts_with?: Maybe<String>;
  bodyText_not_starts_with?: Maybe<String>;
  bodyText_ends_with?: Maybe<String>;
  bodyText_not_ends_with?: Maybe<String>;
  url?: Maybe<String>;
  url_not?: Maybe<String>;
  url_in?: Maybe<String[] | String>;
  url_not_in?: Maybe<String[] | String>;
  url_lt?: Maybe<String>;
  url_lte?: Maybe<String>;
  url_gt?: Maybe<String>;
  url_gte?: Maybe<String>;
  url_contains?: Maybe<String>;
  url_not_contains?: Maybe<String>;
  url_starts_with?: Maybe<String>;
  url_not_starts_with?: Maybe<String>;
  url_ends_with?: Maybe<String>;
  url_not_ends_with?: Maybe<String>;
  AND?: Maybe<
    | GitHubPullRequestReviewScalarWhereInput[]
    | GitHubPullRequestReviewScalarWhereInput
  >;
  OR?: Maybe<
    | GitHubPullRequestReviewScalarWhereInput[]
    | GitHubPullRequestReviewScalarWhereInput
  >;
  NOT?: Maybe<
    | GitHubPullRequestReviewScalarWhereInput[]
    | GitHubPullRequestReviewScalarWhereInput
  >;
}

export interface AppKeyUpdateManyWithoutUserInput {
  create?: Maybe<AppKeyCreateWithoutUserInput[] | AppKeyCreateWithoutUserInput>;
  delete?: Maybe<AppKeyWhereUniqueInput[] | AppKeyWhereUniqueInput>;
  connect?: Maybe<AppKeyWhereUniqueInput[] | AppKeyWhereUniqueInput>;
  set?: Maybe<AppKeyWhereUniqueInput[] | AppKeyWhereUniqueInput>;
  disconnect?: Maybe<AppKeyWhereUniqueInput[] | AppKeyWhereUniqueInput>;
  update?: Maybe<
    | AppKeyUpdateWithWhereUniqueWithoutUserInput[]
    | AppKeyUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | AppKeyUpsertWithWhereUniqueWithoutUserInput[]
    | AppKeyUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<AppKeyScalarWhereInput[] | AppKeyScalarWhereInput>;
  updateMany?: Maybe<
    | AppKeyUpdateManyWithWhereNestedInput[]
    | AppKeyUpdateManyWithWhereNestedInput
  >;
}

export interface GitHubPullRequestReviewUpdateManyWithWhereNestedInput {
  where: GitHubPullRequestReviewScalarWhereInput;
  data: GitHubPullRequestReviewUpdateManyDataInput;
}

export interface RepositoryUpdateWithWhereUniqueWithoutAppKeyInput {
  where: RepositoryWhereUniqueInput;
  data: RepositoryUpdateWithoutAppKeyDataInput;
}

export interface GitHubPullRequestReviewUpdateManyDataInput {
  createdAtExternal?: Maybe<DateTimeInput>;
  updatedAtExternal?: Maybe<DateTimeInput>;
  submittedAt?: Maybe<DateTimeInput>;
  lastEditedAt?: Maybe<DateTimeInput>;
  publishedAt?: Maybe<DateTimeInput>;
  state?: Maybe<String>;
  bodyText?: Maybe<String>;
  url?: Maybe<String>;
}

export interface UserUpsertWithoutAddedRepositoriesInput {
  update: UserUpdateWithoutAddedRepositoriesDataInput;
  create: UserCreateWithoutAddedRepositoriesInput;
}

export interface GitHubReviewThreadUpdateManyWithoutPullRequestInput {
  create?: Maybe<
    | GitHubReviewThreadCreateWithoutPullRequestInput[]
    | GitHubReviewThreadCreateWithoutPullRequestInput
  >;
  delete?: Maybe<
    GitHubReviewThreadWhereUniqueInput[] | GitHubReviewThreadWhereUniqueInput
  >;
  connect?: Maybe<
    GitHubReviewThreadWhereUniqueInput[] | GitHubReviewThreadWhereUniqueInput
  >;
  set?: Maybe<
    GitHubReviewThreadWhereUniqueInput[] | GitHubReviewThreadWhereUniqueInput
  >;
  disconnect?: Maybe<
    GitHubReviewThreadWhereUniqueInput[] | GitHubReviewThreadWhereUniqueInput
  >;
  update?: Maybe<
    | GitHubReviewThreadUpdateWithWhereUniqueWithoutPullRequestInput[]
    | GitHubReviewThreadUpdateWithWhereUniqueWithoutPullRequestInput
  >;
  upsert?: Maybe<
    | GitHubReviewThreadUpsertWithWhereUniqueWithoutPullRequestInput[]
    | GitHubReviewThreadUpsertWithWhereUniqueWithoutPullRequestInput
  >;
  deleteMany?: Maybe<
    GitHubReviewThreadScalarWhereInput[] | GitHubReviewThreadScalarWhereInput
  >;
  updateMany?: Maybe<
    | GitHubReviewThreadUpdateManyWithWhereNestedInput[]
    | GitHubReviewThreadUpdateManyWithWhereNestedInput
  >;
}

export interface RepositoryUpdateManyDataInput {
  idExternal?: Maybe<String>;
  createdAtExternal?: Maybe<DateTimeInput>;
  updatedAtExternal?: Maybe<DateTimeInput>;
  name?: Maybe<String>;
  description?: Maybe<String>;
  homepageUrl?: Maybe<String>;
  url?: Maybe<String>;
  owner?: Maybe<String>;
  isTracked?: Maybe<Boolean>;
  isFork?: Maybe<Boolean>;
  isLocked?: Maybe<Boolean>;
  isPrivate?: Maybe<Boolean>;
  isArchived?: Maybe<Boolean>;
  isDisabled?: Maybe<Boolean>;
  sshUrl?: Maybe<String>;
}

export interface GitHubReviewThreadUpdateWithWhereUniqueWithoutPullRequestInput {
  where: GitHubReviewThreadWhereUniqueInput;
  data: GitHubReviewThreadUpdateWithoutPullRequestDataInput;
}

export interface AppKeyUpdateManyDataInput {
  key?: Maybe<String>;
  name?: Maybe<String>;
}

export interface GitHubReviewThreadUpdateWithoutPullRequestDataInput {
  comments?: Maybe<GitHubCommentUpdateManyInput>;
  repository?: Maybe<GitHubRepositoryUpdateOneRequiredInput>;
  resolvedBy?: Maybe<GitHubUserUpdateOneRequiredInput>;
  isResolved?: Maybe<Boolean>;
}

export type GameWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface GitHubRepositoryUpdateOneRequiredInput {
  create?: Maybe<GitHubRepositoryCreateInput>;
  update?: Maybe<GitHubRepositoryUpdateDataInput>;
  upsert?: Maybe<GitHubRepositoryUpsertNestedInput>;
  connect?: Maybe<GitHubRepositoryWhereUniqueInput>;
}

export interface GitHubUserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdAtExternal?: Maybe<DateTimeInput>;
  createdAtExternal_not?: Maybe<DateTimeInput>;
  createdAtExternal_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAtExternal_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAtExternal_lt?: Maybe<DateTimeInput>;
  createdAtExternal_lte?: Maybe<DateTimeInput>;
  createdAtExternal_gt?: Maybe<DateTimeInput>;
  createdAtExternal_gte?: Maybe<DateTimeInput>;
  followers_some?: Maybe<GitHubUserWhereInput>;
  following_some?: Maybe<GitHubUserWhereInput>;
  issueComments_some?: Maybe<GitHubCommentWhereInput>;
  issues_some?: Maybe<GitHubIssueWhereInput>;
  pullRequests_some?: Maybe<GitHubPullRequestWhereInput>;
  isBountyHunter?: Maybe<Boolean>;
  isBountyHunter_not?: Maybe<Boolean>;
  isCampusExpert?: Maybe<Boolean>;
  isCampusExpert_not?: Maybe<Boolean>;
  isDeveloperProgramMember?: Maybe<Boolean>;
  isDeveloperProgramMember_not?: Maybe<Boolean>;
  isEmployee?: Maybe<Boolean>;
  isEmployee_not?: Maybe<Boolean>;
  isHireable?: Maybe<Boolean>;
  isHireable_not?: Maybe<Boolean>;
  isSiteAdmin?: Maybe<Boolean>;
  isSiteAdmin_not?: Maybe<Boolean>;
  isViewer?: Maybe<Boolean>;
  isViewer_not?: Maybe<Boolean>;
  url?: Maybe<String>;
  url_not?: Maybe<String>;
  url_in?: Maybe<String[] | String>;
  url_not_in?: Maybe<String[] | String>;
  url_lt?: Maybe<String>;
  url_lte?: Maybe<String>;
  url_gt?: Maybe<String>;
  url_gte?: Maybe<String>;
  url_contains?: Maybe<String>;
  url_not_contains?: Maybe<String>;
  url_starts_with?: Maybe<String>;
  url_not_starts_with?: Maybe<String>;
  url_ends_with?: Maybe<String>;
  url_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  login?: Maybe<String>;
  login_not?: Maybe<String>;
  login_in?: Maybe<String[] | String>;
  login_not_in?: Maybe<String[] | String>;
  login_lt?: Maybe<String>;
  login_lte?: Maybe<String>;
  login_gt?: Maybe<String>;
  login_gte?: Maybe<String>;
  login_contains?: Maybe<String>;
  login_not_contains?: Maybe<String>;
  login_starts_with?: Maybe<String>;
  login_not_starts_with?: Maybe<String>;
  login_ends_with?: Maybe<String>;
  login_not_ends_with?: Maybe<String>;
  avatarUrl?: Maybe<String>;
  avatarUrl_not?: Maybe<String>;
  avatarUrl_in?: Maybe<String[] | String>;
  avatarUrl_not_in?: Maybe<String[] | String>;
  avatarUrl_lt?: Maybe<String>;
  avatarUrl_lte?: Maybe<String>;
  avatarUrl_gt?: Maybe<String>;
  avatarUrl_gte?: Maybe<String>;
  avatarUrl_contains?: Maybe<String>;
  avatarUrl_not_contains?: Maybe<String>;
  avatarUrl_starts_with?: Maybe<String>;
  avatarUrl_not_starts_with?: Maybe<String>;
  avatarUrl_ends_with?: Maybe<String>;
  avatarUrl_not_ends_with?: Maybe<String>;
  bio?: Maybe<String>;
  bio_not?: Maybe<String>;
  bio_in?: Maybe<String[] | String>;
  bio_not_in?: Maybe<String[] | String>;
  bio_lt?: Maybe<String>;
  bio_lte?: Maybe<String>;
  bio_gt?: Maybe<String>;
  bio_gte?: Maybe<String>;
  bio_contains?: Maybe<String>;
  bio_not_contains?: Maybe<String>;
  bio_starts_with?: Maybe<String>;
  bio_not_starts_with?: Maybe<String>;
  bio_ends_with?: Maybe<String>;
  bio_not_ends_with?: Maybe<String>;
  company?: Maybe<String>;
  company_not?: Maybe<String>;
  company_in?: Maybe<String[] | String>;
  company_not_in?: Maybe<String[] | String>;
  company_lt?: Maybe<String>;
  company_lte?: Maybe<String>;
  company_gt?: Maybe<String>;
  company_gte?: Maybe<String>;
  company_contains?: Maybe<String>;
  company_not_contains?: Maybe<String>;
  company_starts_with?: Maybe<String>;
  company_not_starts_with?: Maybe<String>;
  company_ends_with?: Maybe<String>;
  company_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  AND?: Maybe<GitHubUserWhereInput[] | GitHubUserWhereInput>;
}

export interface GitHubRepositoryUpdateDataInput {
  updatedAtExternal?: Maybe<DateTimeInput>;
  collaborators?: Maybe<GitHubUserUpdateManyInput>;
  owner?: Maybe<GitHubUserUpdateOneRequiredInput>;
  repositoryTopics?: Maybe<GitHubTopicUpdateManyInput>;
  stargazers?: Maybe<GitHubUserUpdateManyInput>;
  watchers?: Maybe<GitHubUserUpdateManyInput>;
  hasBranchRules?: Maybe<Boolean>;
  hasContributingGuidelines?: Maybe<Boolean>;
  hasPullRequestTemplate?: Maybe<Boolean>;
  hasReadMe?: Maybe<Boolean>;
  hasWiki?: Maybe<Boolean>;
  isArchived?: Maybe<Boolean>;
  isDisabled?: Maybe<Boolean>;
  isFork?: Maybe<Boolean>;
  isLocked?: Maybe<Boolean>;
  isPrivate?: Maybe<Boolean>;
  description?: Maybe<String>;
  license?: Maybe<String>;
  name?: Maybe<String>;
  primaryLanguage?: Maybe<String>;
  sshUrl?: Maybe<String>;
  url?: Maybe<String>;
}

export interface GitHubReviewThreadWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  comments_some?: Maybe<GitHubCommentWhereInput>;
  pullRequest?: Maybe<GitHubPullRequestWhereInput>;
  repository?: Maybe<GitHubRepositoryWhereInput>;
  resolvedBy?: Maybe<GitHubUserWhereInput>;
  isResolved?: Maybe<Boolean>;
  isResolved_not?: Maybe<Boolean>;
  AND?: Maybe<GitHubReviewThreadWhereInput[] | GitHubReviewThreadWhereInput>;
}

export interface GitHubTopicUpdateManyInput {
  create?: Maybe<GitHubTopicCreateInput[] | GitHubTopicCreateInput>;
  update?: Maybe<
    | GitHubTopicUpdateWithWhereUniqueNestedInput[]
    | GitHubTopicUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | GitHubTopicUpsertWithWhereUniqueNestedInput[]
    | GitHubTopicUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<GitHubTopicWhereUniqueInput[] | GitHubTopicWhereUniqueInput>;
  connect?: Maybe<GitHubTopicWhereUniqueInput[] | GitHubTopicWhereUniqueInput>;
  set?: Maybe<GitHubTopicWhereUniqueInput[] | GitHubTopicWhereUniqueInput>;
  disconnect?: Maybe<
    GitHubTopicWhereUniqueInput[] | GitHubTopicWhereUniqueInput
  >;
  deleteMany?: Maybe<
    GitHubTopicScalarWhereInput[] | GitHubTopicScalarWhereInput
  >;
  updateMany?: Maybe<
    | GitHubTopicUpdateManyWithWhereNestedInput[]
    | GitHubTopicUpdateManyWithWhereNestedInput
  >;
}

export interface GitHubIssueSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<GitHubIssueWhereInput>;
  AND?: Maybe<
    GitHubIssueSubscriptionWhereInput[] | GitHubIssueSubscriptionWhereInput
  >;
}

export interface GitHubTopicUpdateWithWhereUniqueNestedInput {
  where: GitHubTopicWhereUniqueInput;
  data: GitHubTopicUpdateDataInput;
}

export interface GameSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<GameWhereInput>;
  AND?: Maybe<GameSubscriptionWhereInput[] | GameSubscriptionWhereInput>;
}

export interface GitHubTopicUpdateDataInput {
  relatedTopics?: Maybe<GitHubTopicUpdateManyWithoutRelatedTopicsInput>;
  stargazers?: Maybe<GitHubUserUpdateManyInput>;
  name?: Maybe<String>;
}

export interface PostWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  published?: Maybe<Boolean>;
  published_not?: Maybe<Boolean>;
  author?: Maybe<UserWhereInput>;
  AND?: Maybe<PostWhereInput[] | PostWhereInput>;
}

export interface GitHubTopicUpdateManyWithoutRelatedTopicsInput {
  create?: Maybe<
    | GitHubTopicCreateWithoutRelatedTopicsInput[]
    | GitHubTopicCreateWithoutRelatedTopicsInput
  >;
  delete?: Maybe<GitHubTopicWhereUniqueInput[] | GitHubTopicWhereUniqueInput>;
  connect?: Maybe<GitHubTopicWhereUniqueInput[] | GitHubTopicWhereUniqueInput>;
  set?: Maybe<GitHubTopicWhereUniqueInput[] | GitHubTopicWhereUniqueInput>;
  disconnect?: Maybe<
    GitHubTopicWhereUniqueInput[] | GitHubTopicWhereUniqueInput
  >;
  update?: Maybe<
    | GitHubTopicUpdateWithWhereUniqueWithoutRelatedTopicsInput[]
    | GitHubTopicUpdateWithWhereUniqueWithoutRelatedTopicsInput
  >;
  upsert?: Maybe<
    | GitHubTopicUpsertWithWhereUniqueWithoutRelatedTopicsInput[]
    | GitHubTopicUpsertWithWhereUniqueWithoutRelatedTopicsInput
  >;
  deleteMany?: Maybe<
    GitHubTopicScalarWhereInput[] | GitHubTopicScalarWhereInput
  >;
  updateMany?: Maybe<
    | GitHubTopicUpdateManyWithWhereNestedInput[]
    | GitHubTopicUpdateManyWithWhereNestedInput
  >;
}

export interface PostUpdateInput {
  title?: Maybe<String>;
  published?: Maybe<Boolean>;
  author?: Maybe<UserUpdateOneWithoutPostsInput>;
}

export interface GitHubTopicUpdateWithWhereUniqueWithoutRelatedTopicsInput {
  where: GitHubTopicWhereUniqueInput;
  data: GitHubTopicUpdateWithoutRelatedTopicsDataInput;
}

export interface RepositoryUpdateWithoutWebhookEventsDataInput {
  idExternal?: Maybe<String>;
  createdAtExternal?: Maybe<DateTimeInput>;
  updatedAtExternal?: Maybe<DateTimeInput>;
  addedBy?: Maybe<UserUpdateOneRequiredWithoutAddedRepositoriesInput>;
  name?: Maybe<String>;
  description?: Maybe<String>;
  homepageUrl?: Maybe<String>;
  url?: Maybe<String>;
  owner?: Maybe<String>;
  isTracked?: Maybe<Boolean>;
  appKey?: Maybe<AppKeyUpdateOneRequiredWithoutRepositoriesInput>;
  isFork?: Maybe<Boolean>;
  isLocked?: Maybe<Boolean>;
  isPrivate?: Maybe<Boolean>;
  isArchived?: Maybe<Boolean>;
  isDisabled?: Maybe<Boolean>;
  sshUrl?: Maybe<String>;
  game?: Maybe<GameUpdateOneWithoutRepositoryInput>;
}

export interface GitHubTopicUpdateWithoutRelatedTopicsDataInput {
  stargazers?: Maybe<GitHubUserUpdateManyInput>;
  name?: Maybe<String>;
}

export interface GitHubUserUpdateManyMutationInput {
  createdAtExternal?: Maybe<DateTimeInput>;
  isBountyHunter?: Maybe<Boolean>;
  isCampusExpert?: Maybe<Boolean>;
  isDeveloperProgramMember?: Maybe<Boolean>;
  isEmployee?: Maybe<Boolean>;
  isHireable?: Maybe<Boolean>;
  isSiteAdmin?: Maybe<Boolean>;
  isViewer?: Maybe<Boolean>;
  url?: Maybe<String>;
  name?: Maybe<String>;
  login?: Maybe<String>;
  avatarUrl?: Maybe<String>;
  bio?: Maybe<String>;
  company?: Maybe<String>;
  email?: Maybe<String>;
}

export interface GitHubTopicUpsertWithWhereUniqueWithoutRelatedTopicsInput {
  where: GitHubTopicWhereUniqueInput;
  update: GitHubTopicUpdateWithoutRelatedTopicsDataInput;
  create: GitHubTopicCreateWithoutRelatedTopicsInput;
}

export interface GitHubPullRequestUpdateWithoutReviewThreadsDataInput {
  createdAtExternal?: Maybe<DateTimeInput>;
  publishedAt?: Maybe<DateTimeInput>;
  closedAt?: Maybe<DateTimeInput>;
  mergedAt?: Maybe<DateTimeInput>;
  assignees?: Maybe<GitHubUserUpdateManyInput>;
  author?: Maybe<GitHubUserUpdateOneRequiredInput>;
  comments?: Maybe<GitHubCommentUpdateManyInput>;
  commits?: Maybe<GitHubCommitUpdateManyWithoutAssociatedPullRequestsInput>;
  files?: Maybe<GitHubFileDiffUpdateManyInput>;
  labels?: Maybe<GitHubLabelUpdateManyWithoutPullRequestsInput>;
  participants?: Maybe<GitHubUserUpdateManyInput>;
  reviewRequests?: Maybe<GitHubReviewRequestUpdateManyWithoutPullRequestInput>;
  reviews?: Maybe<GitHubPullRequestReviewUpdateManyWithoutPullRequestInput>;
  mergedBy?: Maybe<GitHubUserUpdateOneInput>;
  number?: Maybe<Int>;
  closed?: Maybe<Boolean>;
  isCrossRepository?: Maybe<Boolean>;
  locked?: Maybe<Boolean>;
  merged?: Maybe<Boolean>;
  additions?: Maybe<Int>;
  changedFiles?: Maybe<Int>;
  deletions?: Maybe<Int>;
  bodyText?: Maybe<String>;
}

export interface GitHubTopicScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<GitHubTopicScalarWhereInput[] | GitHubTopicScalarWhereInput>;
  OR?: Maybe<GitHubTopicScalarWhereInput[] | GitHubTopicScalarWhereInput>;
  NOT?: Maybe<GitHubTopicScalarWhereInput[] | GitHubTopicScalarWhereInput>;
}

export type GitHubReviewRequestWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface GitHubTopicUpdateManyWithWhereNestedInput {
  where: GitHubTopicScalarWhereInput;
  data: GitHubTopicUpdateManyDataInput;
}

export type GitHubTopicWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface GitHubTopicUpdateManyDataInput {
  name?: Maybe<String>;
}

export type GitHubWebhookEventWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface GitHubTopicUpsertWithWhereUniqueNestedInput {
  where: GitHubTopicWhereUniqueInput;
  update: GitHubTopicUpdateDataInput;
  create: GitHubTopicCreateInput;
}

export type RepositoryWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  idExternal?: Maybe<String>;
  name?: Maybe<String>;
}>;

export interface GitHubRepositoryUpsertNestedInput {
  update: GitHubRepositoryUpdateDataInput;
  create: GitHubRepositoryCreateInput;
}

export interface GitHubFileDiffUpdateInput {
  additions?: Maybe<Int>;
  deletions?: Maybe<Int>;
  filepath?: Maybe<String>;
}

export interface GitHubReviewThreadUpsertWithWhereUniqueWithoutPullRequestInput {
  where: GitHubReviewThreadWhereUniqueInput;
  update: GitHubReviewThreadUpdateWithoutPullRequestDataInput;
  create: GitHubReviewThreadCreateWithoutPullRequestInput;
}

export interface RepositoryCreateWithoutAddedByInput {
  id?: Maybe<ID_Input>;
  idExternal: String;
  createdAtExternal: DateTimeInput;
  updatedAtExternal: DateTimeInput;
  name: String;
  description?: Maybe<String>;
  homepageUrl?: Maybe<String>;
  url: String;
  owner: String;
  isTracked: Boolean;
  appKey: AppKeyCreateOneWithoutRepositoriesInput;
  isFork: Boolean;
  isLocked: Boolean;
  isPrivate: Boolean;
  isArchived: Boolean;
  isDisabled: Boolean;
  sshUrl?: Maybe<String>;
  webhookEvents?: Maybe<GitHubWebhookEventCreateManyWithoutRepositoryInput>;
  game?: Maybe<GameCreateOneWithoutRepositoryInput>;
}

export interface GitHubReviewThreadScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  isResolved?: Maybe<Boolean>;
  isResolved_not?: Maybe<Boolean>;
  AND?: Maybe<
    GitHubReviewThreadScalarWhereInput[] | GitHubReviewThreadScalarWhereInput
  >;
  OR?: Maybe<
    GitHubReviewThreadScalarWhereInput[] | GitHubReviewThreadScalarWhereInput
  >;
  NOT?: Maybe<
    GitHubReviewThreadScalarWhereInput[] | GitHubReviewThreadScalarWhereInput
  >;
}

export interface UserCreateInput {
  id?: Maybe<ID_Input>;
  posts?: Maybe<PostCreateManyWithoutAuthorInput>;
  keys?: Maybe<AppKeyCreateManyWithoutUserInput>;
  addedRepositories?: Maybe<RepositoryCreateManyWithoutAddedByInput>;
  email: String;
  name?: Maybe<String>;
  password: String;
  role?: Maybe<Role>;
  gitLogin: String;
}

export interface GitHubReviewThreadUpdateManyWithWhereNestedInput {
  where: GitHubReviewThreadScalarWhereInput;
  data: GitHubReviewThreadUpdateManyDataInput;
}

export interface UserUpdateOneRequiredWithoutKeysInput {
  create?: Maybe<UserCreateWithoutKeysInput>;
  update?: Maybe<UserUpdateWithoutKeysDataInput>;
  upsert?: Maybe<UserUpsertWithoutKeysInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface GitHubReviewThreadUpdateManyDataInput {
  isResolved?: Maybe<Boolean>;
}

export interface PostUpdateManyDataInput {
  title?: Maybe<String>;
  published?: Maybe<Boolean>;
}

export interface GitHubUserUpdateOneInput {
  create?: Maybe<GitHubUserCreateInput>;
  update?: Maybe<GitHubUserUpdateDataInput>;
  upsert?: Maybe<GitHubUserUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<GitHubUserWhereUniqueInput>;
}

export interface GitHubWebhookEventUpdateWithWhereUniqueWithoutRepositoryInput {
  where: GitHubWebhookEventWhereUniqueInput;
  data: GitHubWebhookEventUpdateWithoutRepositoryDataInput;
}

export interface GitHubUserUpsertNestedInput {
  update: GitHubUserUpdateDataInput;
  create: GitHubUserCreateInput;
}

export interface UserUpdateOneRequiredInput {
  create?: Maybe<UserCreateInput>;
  update?: Maybe<UserUpdateDataInput>;
  upsert?: Maybe<UserUpsertNestedInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface GitHubPullRequestUpsertWithWhereUniqueNestedInput {
  where: GitHubPullRequestWhereUniqueInput;
  update: GitHubPullRequestUpdateDataInput;
  create: GitHubPullRequestCreateInput;
}

export interface UserUpdateOneRequiredWithoutAddedRepositoriesInput {
  create?: Maybe<UserCreateWithoutAddedRepositoriesInput>;
  update?: Maybe<UserUpdateWithoutAddedRepositoriesDataInput>;
  upsert?: Maybe<UserUpsertWithoutAddedRepositoriesInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface GitHubPullRequestScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdAtExternal?: Maybe<DateTimeInput>;
  createdAtExternal_not?: Maybe<DateTimeInput>;
  createdAtExternal_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAtExternal_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAtExternal_lt?: Maybe<DateTimeInput>;
  createdAtExternal_lte?: Maybe<DateTimeInput>;
  createdAtExternal_gt?: Maybe<DateTimeInput>;
  createdAtExternal_gte?: Maybe<DateTimeInput>;
  publishedAt?: Maybe<DateTimeInput>;
  publishedAt_not?: Maybe<DateTimeInput>;
  publishedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  publishedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  publishedAt_lt?: Maybe<DateTimeInput>;
  publishedAt_lte?: Maybe<DateTimeInput>;
  publishedAt_gt?: Maybe<DateTimeInput>;
  publishedAt_gte?: Maybe<DateTimeInput>;
  closedAt?: Maybe<DateTimeInput>;
  closedAt_not?: Maybe<DateTimeInput>;
  closedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  closedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  closedAt_lt?: Maybe<DateTimeInput>;
  closedAt_lte?: Maybe<DateTimeInput>;
  closedAt_gt?: Maybe<DateTimeInput>;
  closedAt_gte?: Maybe<DateTimeInput>;
  mergedAt?: Maybe<DateTimeInput>;
  mergedAt_not?: Maybe<DateTimeInput>;
  mergedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  mergedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  mergedAt_lt?: Maybe<DateTimeInput>;
  mergedAt_lte?: Maybe<DateTimeInput>;
  mergedAt_gt?: Maybe<DateTimeInput>;
  mergedAt_gte?: Maybe<DateTimeInput>;
  number?: Maybe<Int>;
  number_not?: Maybe<Int>;
  number_in?: Maybe<Int[] | Int>;
  number_not_in?: Maybe<Int[] | Int>;
  number_lt?: Maybe<Int>;
  number_lte?: Maybe<Int>;
  number_gt?: Maybe<Int>;
  number_gte?: Maybe<Int>;
  closed?: Maybe<Boolean>;
  closed_not?: Maybe<Boolean>;
  isCrossRepository?: Maybe<Boolean>;
  isCrossRepository_not?: Maybe<Boolean>;
  locked?: Maybe<Boolean>;
  locked_not?: Maybe<Boolean>;
  merged?: Maybe<Boolean>;
  merged_not?: Maybe<Boolean>;
  additions?: Maybe<Int>;
  additions_not?: Maybe<Int>;
  additions_in?: Maybe<Int[] | Int>;
  additions_not_in?: Maybe<Int[] | Int>;
  additions_lt?: Maybe<Int>;
  additions_lte?: Maybe<Int>;
  additions_gt?: Maybe<Int>;
  additions_gte?: Maybe<Int>;
  changedFiles?: Maybe<Int>;
  changedFiles_not?: Maybe<Int>;
  changedFiles_in?: Maybe<Int[] | Int>;
  changedFiles_not_in?: Maybe<Int[] | Int>;
  changedFiles_lt?: Maybe<Int>;
  changedFiles_lte?: Maybe<Int>;
  changedFiles_gt?: Maybe<Int>;
  changedFiles_gte?: Maybe<Int>;
  deletions?: Maybe<Int>;
  deletions_not?: Maybe<Int>;
  deletions_in?: Maybe<Int[] | Int>;
  deletions_not_in?: Maybe<Int[] | Int>;
  deletions_lt?: Maybe<Int>;
  deletions_lte?: Maybe<Int>;
  deletions_gt?: Maybe<Int>;
  deletions_gte?: Maybe<Int>;
  bodyText?: Maybe<String>;
  bodyText_not?: Maybe<String>;
  bodyText_in?: Maybe<String[] | String>;
  bodyText_not_in?: Maybe<String[] | String>;
  bodyText_lt?: Maybe<String>;
  bodyText_lte?: Maybe<String>;
  bodyText_gt?: Maybe<String>;
  bodyText_gte?: Maybe<String>;
  bodyText_contains?: Maybe<String>;
  bodyText_not_contains?: Maybe<String>;
  bodyText_starts_with?: Maybe<String>;
  bodyText_not_starts_with?: Maybe<String>;
  bodyText_ends_with?: Maybe<String>;
  bodyText_not_ends_with?: Maybe<String>;
  AND?: Maybe<
    GitHubPullRequestScalarWhereInput[] | GitHubPullRequestScalarWhereInput
  >;
  OR?: Maybe<
    GitHubPullRequestScalarWhereInput[] | GitHubPullRequestScalarWhereInput
  >;
  NOT?: Maybe<
    GitHubPullRequestScalarWhereInput[] | GitHubPullRequestScalarWhereInput
  >;
}

export interface AppKeyScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  key?: Maybe<String>;
  key_not?: Maybe<String>;
  key_in?: Maybe<String[] | String>;
  key_not_in?: Maybe<String[] | String>;
  key_lt?: Maybe<String>;
  key_lte?: Maybe<String>;
  key_gt?: Maybe<String>;
  key_gte?: Maybe<String>;
  key_contains?: Maybe<String>;
  key_not_contains?: Maybe<String>;
  key_starts_with?: Maybe<String>;
  key_not_starts_with?: Maybe<String>;
  key_ends_with?: Maybe<String>;
  key_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<AppKeyScalarWhereInput[] | AppKeyScalarWhereInput>;
  OR?: Maybe<AppKeyScalarWhereInput[] | AppKeyScalarWhereInput>;
  NOT?: Maybe<AppKeyScalarWhereInput[] | AppKeyScalarWhereInput>;
}

export interface GitHubPullRequestUpdateManyWithWhereNestedInput {
  where: GitHubPullRequestScalarWhereInput;
  data: GitHubPullRequestUpdateManyDataInput;
}

export interface GitHubTopicSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<GitHubTopicWhereInput>;
  AND?: Maybe<
    GitHubTopicSubscriptionWhereInput[] | GitHubTopicSubscriptionWhereInput
  >;
}

export interface GitHubPullRequestUpdateManyDataInput {
  createdAtExternal?: Maybe<DateTimeInput>;
  publishedAt?: Maybe<DateTimeInput>;
  closedAt?: Maybe<DateTimeInput>;
  mergedAt?: Maybe<DateTimeInput>;
  number?: Maybe<Int>;
  closed?: Maybe<Boolean>;
  isCrossRepository?: Maybe<Boolean>;
  locked?: Maybe<Boolean>;
  merged?: Maybe<Boolean>;
  additions?: Maybe<Int>;
  changedFiles?: Maybe<Int>;
  deletions?: Maybe<Int>;
  bodyText?: Maybe<String>;
}

export interface GitHubRepositorySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<GitHubRepositoryWhereInput>;
  AND?: Maybe<
    | GitHubRepositorySubscriptionWhereInput[]
    | GitHubRepositorySubscriptionWhereInput
  >;
}

export interface GitHubUserUpsertWithoutIssueCommentsInput {
  update: GitHubUserUpdateWithoutIssueCommentsDataInput;
  create: GitHubUserCreateWithoutIssueCommentsInput;
}

export interface UserUpdateManyMutationInput {
  email?: Maybe<String>;
  name?: Maybe<String>;
  password?: Maybe<String>;
  role?: Maybe<Role>;
  gitLogin?: Maybe<String>;
}

export interface GitHubCommentUpsertWithWhereUniqueNestedInput {
  where: GitHubCommentWhereUniqueInput;
  update: GitHubCommentUpdateDataInput;
  create: GitHubCommentCreateInput;
}

export interface PostCreateInput {
  id?: Maybe<ID_Input>;
  title: String;
  published?: Maybe<Boolean>;
  author?: Maybe<UserCreateOneWithoutPostsInput>;
}

export interface GitHubLabelUpdateManyWithoutIssuesInput {
  create?: Maybe<
    GitHubLabelCreateWithoutIssuesInput[] | GitHubLabelCreateWithoutIssuesInput
  >;
  delete?: Maybe<GitHubLabelWhereUniqueInput[] | GitHubLabelWhereUniqueInput>;
  connect?: Maybe<GitHubLabelWhereUniqueInput[] | GitHubLabelWhereUniqueInput>;
  set?: Maybe<GitHubLabelWhereUniqueInput[] | GitHubLabelWhereUniqueInput>;
  disconnect?: Maybe<
    GitHubLabelWhereUniqueInput[] | GitHubLabelWhereUniqueInput
  >;
  update?: Maybe<
    | GitHubLabelUpdateWithWhereUniqueWithoutIssuesInput[]
    | GitHubLabelUpdateWithWhereUniqueWithoutIssuesInput
  >;
  upsert?: Maybe<
    | GitHubLabelUpsertWithWhereUniqueWithoutIssuesInput[]
    | GitHubLabelUpsertWithWhereUniqueWithoutIssuesInput
  >;
  deleteMany?: Maybe<
    GitHubLabelScalarWhereInput[] | GitHubLabelScalarWhereInput
  >;
  updateMany?: Maybe<
    | GitHubLabelUpdateManyWithWhereNestedInput[]
    | GitHubLabelUpdateManyWithWhereNestedInput
  >;
}

export interface GitHubTopicUpdateInput {
  relatedTopics?: Maybe<GitHubTopicUpdateManyWithoutRelatedTopicsInput>;
  stargazers?: Maybe<GitHubUserUpdateManyInput>;
  name?: Maybe<String>;
}

export interface GitHubLabelUpdateWithWhereUniqueWithoutIssuesInput {
  where: GitHubLabelWhereUniqueInput;
  data: GitHubLabelUpdateWithoutIssuesDataInput;
}

export type GitHubReviewThreadWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface GitHubLabelUpdateWithoutIssuesDataInput {
  updatedAtExternal?: Maybe<DateTimeInput>;
  createdAtExternal?: Maybe<DateTimeInput>;
  pullRequests?: Maybe<GitHubPullRequestUpdateManyWithoutLabelsInput>;
  color?: Maybe<String>;
  description?: Maybe<String>;
  name?: Maybe<String>;
  url?: Maybe<String>;
}

export type PostWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface GitHubPullRequestUpdateManyWithoutLabelsInput {
  create?: Maybe<
    | GitHubPullRequestCreateWithoutLabelsInput[]
    | GitHubPullRequestCreateWithoutLabelsInput
  >;
  delete?: Maybe<
    GitHubPullRequestWhereUniqueInput[] | GitHubPullRequestWhereUniqueInput
  >;
  connect?: Maybe<
    GitHubPullRequestWhereUniqueInput[] | GitHubPullRequestWhereUniqueInput
  >;
  set?: Maybe<
    GitHubPullRequestWhereUniqueInput[] | GitHubPullRequestWhereUniqueInput
  >;
  disconnect?: Maybe<
    GitHubPullRequestWhereUniqueInput[] | GitHubPullRequestWhereUniqueInput
  >;
  update?: Maybe<
    | GitHubPullRequestUpdateWithWhereUniqueWithoutLabelsInput[]
    | GitHubPullRequestUpdateWithWhereUniqueWithoutLabelsInput
  >;
  upsert?: Maybe<
    | GitHubPullRequestUpsertWithWhereUniqueWithoutLabelsInput[]
    | GitHubPullRequestUpsertWithWhereUniqueWithoutLabelsInput
  >;
  deleteMany?: Maybe<
    GitHubPullRequestScalarWhereInput[] | GitHubPullRequestScalarWhereInput
  >;
  updateMany?: Maybe<
    | GitHubPullRequestUpdateManyWithWhereNestedInput[]
    | GitHubPullRequestUpdateManyWithWhereNestedInput
  >;
}

export interface UserCreateWithoutKeysInput {
  id?: Maybe<ID_Input>;
  posts?: Maybe<PostCreateManyWithoutAuthorInput>;
  addedRepositories?: Maybe<RepositoryCreateManyWithoutAddedByInput>;
  email: String;
  name?: Maybe<String>;
  password: String;
  role?: Maybe<Role>;
  gitLogin: String;
}

export interface GitHubPullRequestUpdateWithWhereUniqueWithoutLabelsInput {
  where: GitHubPullRequestWhereUniqueInput;
  data: GitHubPullRequestUpdateWithoutLabelsDataInput;
}

export interface RepositoryCreateWithoutAppKeyInput {
  id?: Maybe<ID_Input>;
  idExternal: String;
  createdAtExternal: DateTimeInput;
  updatedAtExternal: DateTimeInput;
  addedBy: UserCreateOneWithoutAddedRepositoriesInput;
  name: String;
  description?: Maybe<String>;
  homepageUrl?: Maybe<String>;
  url: String;
  owner: String;
  isTracked: Boolean;
  isFork: Boolean;
  isLocked: Boolean;
  isPrivate: Boolean;
  isArchived: Boolean;
  isDisabled: Boolean;
  sshUrl?: Maybe<String>;
  webhookEvents?: Maybe<GitHubWebhookEventCreateManyWithoutRepositoryInput>;
  game?: Maybe<GameCreateOneWithoutRepositoryInput>;
}

export interface GitHubPullRequestUpdateWithoutLabelsDataInput {
  createdAtExternal?: Maybe<DateTimeInput>;
  publishedAt?: Maybe<DateTimeInput>;
  closedAt?: Maybe<DateTimeInput>;
  mergedAt?: Maybe<DateTimeInput>;
  assignees?: Maybe<GitHubUserUpdateManyInput>;
  author?: Maybe<GitHubUserUpdateOneRequiredInput>;
  comments?: Maybe<GitHubCommentUpdateManyInput>;
  commits?: Maybe<GitHubCommitUpdateManyWithoutAssociatedPullRequestsInput>;
  files?: Maybe<GitHubFileDiffUpdateManyInput>;
  participants?: Maybe<GitHubUserUpdateManyInput>;
  reviewRequests?: Maybe<GitHubReviewRequestUpdateManyWithoutPullRequestInput>;
  reviews?: Maybe<GitHubPullRequestReviewUpdateManyWithoutPullRequestInput>;
  reviewThreads?: Maybe<GitHubReviewThreadUpdateManyWithoutPullRequestInput>;
  mergedBy?: Maybe<GitHubUserUpdateOneInput>;
  number?: Maybe<Int>;
  closed?: Maybe<Boolean>;
  isCrossRepository?: Maybe<Boolean>;
  locked?: Maybe<Boolean>;
  merged?: Maybe<Boolean>;
  additions?: Maybe<Int>;
  changedFiles?: Maybe<Int>;
  deletions?: Maybe<Int>;
  bodyText?: Maybe<String>;
}

export interface AppKeyUpdateOneRequiredWithoutRepositoriesInput {
  create?: Maybe<AppKeyCreateWithoutRepositoriesInput>;
  update?: Maybe<AppKeyUpdateWithoutRepositoriesDataInput>;
  upsert?: Maybe<AppKeyUpsertWithoutRepositoriesInput>;
  connect?: Maybe<AppKeyWhereUniqueInput>;
}

export interface GitHubPullRequestUpsertWithWhereUniqueWithoutLabelsInput {
  where: GitHubPullRequestWhereUniqueInput;
  update: GitHubPullRequestUpdateWithoutLabelsDataInput;
  create: GitHubPullRequestCreateWithoutLabelsInput;
}

export interface AppKeyUpdateWithoutUserDataInput {
  repositories?: Maybe<RepositoryUpdateManyWithoutAppKeyInput>;
  key?: Maybe<String>;
  name?: Maybe<String>;
}

export interface GitHubLabelUpsertWithWhereUniqueWithoutIssuesInput {
  where: GitHubLabelWhereUniqueInput;
  update: GitHubLabelUpdateWithoutIssuesDataInput;
  create: GitHubLabelCreateWithoutIssuesInput;
}

export interface GameUpsertWithoutRepositoryInput {
  update: GameUpdateWithoutRepositoryDataInput;
  create: GameCreateWithoutRepositoryInput;
}

export interface GitHubIssueUpsertWithWhereUniqueNestedInput {
  where: GitHubIssueWhereUniqueInput;
  update: GitHubIssueUpdateDataInput;
  create: GitHubIssueCreateInput;
}

export interface GitHubCommentSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<GitHubCommentWhereInput>;
  AND?: Maybe<
    GitHubCommentSubscriptionWhereInput[] | GitHubCommentSubscriptionWhereInput
  >;
}

export interface GitHubUserUpsertWithWhereUniqueWithoutFollowingInput {
  where: GitHubUserWhereUniqueInput;
  update: GitHubUserUpdateWithoutFollowingDataInput;
  create: GitHubUserCreateWithoutFollowingInput;
}

export interface RepositoryCreateWithoutWebhookEventsInput {
  id?: Maybe<ID_Input>;
  idExternal: String;
  createdAtExternal: DateTimeInput;
  updatedAtExternal: DateTimeInput;
  addedBy: UserCreateOneWithoutAddedRepositoriesInput;
  name: String;
  description?: Maybe<String>;
  homepageUrl?: Maybe<String>;
  url: String;
  owner: String;
  isTracked: Boolean;
  appKey: AppKeyCreateOneWithoutRepositoriesInput;
  isFork: Boolean;
  isLocked: Boolean;
  isPrivate: Boolean;
  isArchived: Boolean;
  isDisabled: Boolean;
  sshUrl?: Maybe<String>;
  game?: Maybe<GameCreateOneWithoutRepositoryInput>;
}

export interface GitHubUserUpsertWithWhereUniqueWithoutFollowersInput {
  where: GitHubUserWhereUniqueInput;
  update: GitHubUserUpdateWithoutFollowersDataInput;
  create: GitHubUserCreateWithoutFollowersInput;
}

export type GitHubUserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface GitHubPullRequestUpdateManyWithoutCommitsInput {
  create?: Maybe<
    | GitHubPullRequestCreateWithoutCommitsInput[]
    | GitHubPullRequestCreateWithoutCommitsInput
  >;
  delete?: Maybe<
    GitHubPullRequestWhereUniqueInput[] | GitHubPullRequestWhereUniqueInput
  >;
  connect?: Maybe<
    GitHubPullRequestWhereUniqueInput[] | GitHubPullRequestWhereUniqueInput
  >;
  set?: Maybe<
    GitHubPullRequestWhereUniqueInput[] | GitHubPullRequestWhereUniqueInput
  >;
  disconnect?: Maybe<
    GitHubPullRequestWhereUniqueInput[] | GitHubPullRequestWhereUniqueInput
  >;
  update?: Maybe<
    | GitHubPullRequestUpdateWithWhereUniqueWithoutCommitsInput[]
    | GitHubPullRequestUpdateWithWhereUniqueWithoutCommitsInput
  >;
  upsert?: Maybe<
    | GitHubPullRequestUpsertWithWhereUniqueWithoutCommitsInput[]
    | GitHubPullRequestUpsertWithWhereUniqueWithoutCommitsInput
  >;
  deleteMany?: Maybe<
    GitHubPullRequestScalarWhereInput[] | GitHubPullRequestScalarWhereInput
  >;
  updateMany?: Maybe<
    | GitHubPullRequestUpdateManyWithWhereNestedInput[]
    | GitHubPullRequestUpdateManyWithWhereNestedInput
  >;
}

export interface GitHubWebhookEventCreateWithoutRepositoryInput {
  id?: Maybe<ID_Input>;
  eventType: String;
  action?: Maybe<String>;
  sender: String;
}

export interface GitHubPullRequestUpdateWithWhereUniqueWithoutCommitsInput {
  where: GitHubPullRequestWhereUniqueInput;
  data: GitHubPullRequestUpdateWithoutCommitsDataInput;
}

export interface GitHubWebhookEventUpdateManyWithWhereNestedInput {
  where: GitHubWebhookEventScalarWhereInput;
  data: GitHubWebhookEventUpdateManyDataInput;
}

export interface GitHubPullRequestUpdateWithoutCommitsDataInput {
  createdAtExternal?: Maybe<DateTimeInput>;
  publishedAt?: Maybe<DateTimeInput>;
  closedAt?: Maybe<DateTimeInput>;
  mergedAt?: Maybe<DateTimeInput>;
  assignees?: Maybe<GitHubUserUpdateManyInput>;
  author?: Maybe<GitHubUserUpdateOneRequiredInput>;
  comments?: Maybe<GitHubCommentUpdateManyInput>;
  files?: Maybe<GitHubFileDiffUpdateManyInput>;
  labels?: Maybe<GitHubLabelUpdateManyWithoutPullRequestsInput>;
  participants?: Maybe<GitHubUserUpdateManyInput>;
  reviewRequests?: Maybe<GitHubReviewRequestUpdateManyWithoutPullRequestInput>;
  reviews?: Maybe<GitHubPullRequestReviewUpdateManyWithoutPullRequestInput>;
  reviewThreads?: Maybe<GitHubReviewThreadUpdateManyWithoutPullRequestInput>;
  mergedBy?: Maybe<GitHubUserUpdateOneInput>;
  number?: Maybe<Int>;
  closed?: Maybe<Boolean>;
  isCrossRepository?: Maybe<Boolean>;
  locked?: Maybe<Boolean>;
  merged?: Maybe<Boolean>;
  additions?: Maybe<Int>;
  changedFiles?: Maybe<Int>;
  deletions?: Maybe<Int>;
  bodyText?: Maybe<String>;
}

export interface GitHubPullRequestWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  createdAtExternal?: Maybe<DateTimeInput>;
  createdAtExternal_not?: Maybe<DateTimeInput>;
  createdAtExternal_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAtExternal_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAtExternal_lt?: Maybe<DateTimeInput>;
  createdAtExternal_lte?: Maybe<DateTimeInput>;
  createdAtExternal_gt?: Maybe<DateTimeInput>;
  createdAtExternal_gte?: Maybe<DateTimeInput>;
  publishedAt?: Maybe<DateTimeInput>;
  publishedAt_not?: Maybe<DateTimeInput>;
  publishedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  publishedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  publishedAt_lt?: Maybe<DateTimeInput>;
  publishedAt_lte?: Maybe<DateTimeInput>;
  publishedAt_gt?: Maybe<DateTimeInput>;
  publishedAt_gte?: Maybe<DateTimeInput>;
  closedAt?: Maybe<DateTimeInput>;
  closedAt_not?: Maybe<DateTimeInput>;
  closedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  closedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  closedAt_lt?: Maybe<DateTimeInput>;
  closedAt_lte?: Maybe<DateTimeInput>;
  closedAt_gt?: Maybe<DateTimeInput>;
  closedAt_gte?: Maybe<DateTimeInput>;
  mergedAt?: Maybe<DateTimeInput>;
  mergedAt_not?: Maybe<DateTimeInput>;
  mergedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  mergedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  mergedAt_lt?: Maybe<DateTimeInput>;
  mergedAt_lte?: Maybe<DateTimeInput>;
  mergedAt_gt?: Maybe<DateTimeInput>;
  mergedAt_gte?: Maybe<DateTimeInput>;
  assignees_some?: Maybe<GitHubUserWhereInput>;
  author?: Maybe<GitHubUserWhereInput>;
  comments_some?: Maybe<GitHubCommentWhereInput>;
  commits_some?: Maybe<GitHubCommitWhereInput>;
  files_some?: Maybe<GitHubFileDiffWhereInput>;
  labels_some?: Maybe<GitHubLabelWhereInput>;
  participants_some?: Maybe<GitHubUserWhereInput>;
  reviewRequests_some?: Maybe<GitHubReviewRequestWhereInput>;
  reviews_some?: Maybe<GitHubPullRequestReviewWhereInput>;
  reviewThreads_some?: Maybe<GitHubReviewThreadWhereInput>;
  mergedBy?: Maybe<GitHubUserWhereInput>;
  number?: Maybe<Int>;
  number_not?: Maybe<Int>;
  number_in?: Maybe<Int[] | Int>;
  number_not_in?: Maybe<Int[] | Int>;
  number_lt?: Maybe<Int>;
  number_lte?: Maybe<Int>;
  number_gt?: Maybe<Int>;
  number_gte?: Maybe<Int>;
  closed?: Maybe<Boolean>;
  closed_not?: Maybe<Boolean>;
  isCrossRepository?: Maybe<Boolean>;
  isCrossRepository_not?: Maybe<Boolean>;
  locked?: Maybe<Boolean>;
  locked_not?: Maybe<Boolean>;
  merged?: Maybe<Boolean>;
  merged_not?: Maybe<Boolean>;
  additions?: Maybe<Int>;
  additions_not?: Maybe<Int>;
  additions_in?: Maybe<Int[] | Int>;
  additions_not_in?: Maybe<Int[] | Int>;
  additions_lt?: Maybe<Int>;
  additions_lte?: Maybe<Int>;
  additions_gt?: Maybe<Int>;
  additions_gte?: Maybe<Int>;
  changedFiles?: Maybe<Int>;
  changedFiles_not?: Maybe<Int>;
  changedFiles_in?: Maybe<Int[] | Int>;
  changedFiles_not_in?: Maybe<Int[] | Int>;
  changedFiles_lt?: Maybe<Int>;
  changedFiles_lte?: Maybe<Int>;
  changedFiles_gt?: Maybe<Int>;
  changedFiles_gte?: Maybe<Int>;
  deletions?: Maybe<Int>;
  deletions_not?: Maybe<Int>;
  deletions_in?: Maybe<Int[] | Int>;
  deletions_not_in?: Maybe<Int[] | Int>;
  deletions_lt?: Maybe<Int>;
  deletions_lte?: Maybe<Int>;
  deletions_gt?: Maybe<Int>;
  deletions_gte?: Maybe<Int>;
  bodyText?: Maybe<String>;
  bodyText_not?: Maybe<String>;
  bodyText_in?: Maybe<String[] | String>;
  bodyText_not_in?: Maybe<String[] | String>;
  bodyText_lt?: Maybe<String>;
  bodyText_lte?: Maybe<String>;
  bodyText_gt?: Maybe<String>;
  bodyText_gte?: Maybe<String>;
  bodyText_contains?: Maybe<String>;
  bodyText_not_contains?: Maybe<String>;
  bodyText_starts_with?: Maybe<String>;
  bodyText_not_starts_with?: Maybe<String>;
  bodyText_ends_with?: Maybe<String>;
  bodyText_not_ends_with?: Maybe<String>;
  AND?: Maybe<GitHubPullRequestWhereInput[] | GitHubPullRequestWhereInput>;
}

export interface GitHubPullRequestUpsertNestedInput {
  update: GitHubPullRequestUpdateDataInput;
  create: GitHubPullRequestCreateInput;
}

export interface GitHubPullRequestUpdateOneInput {
  create?: Maybe<GitHubPullRequestCreateInput>;
  update?: Maybe<GitHubPullRequestUpdateDataInput>;
  upsert?: Maybe<GitHubPullRequestUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<GitHubPullRequestWhereUniqueInput>;
}

export interface GitHubCommitUpsertWithWhereUniqueNestedInput {
  where: GitHubCommitWhereUniqueInput;
  update: GitHubCommitUpdateDataInput;
  create: GitHubCommitCreateInput;
}

export interface GitHubPullRequestUpsertWithWhereUniqueWithoutCommitsInput {
  where: GitHubPullRequestWhereUniqueInput;
  update: GitHubPullRequestUpdateWithoutCommitsDataInput;
  create: GitHubPullRequestCreateWithoutCommitsInput;
}

export interface UserUpsertWithoutPostsInput {
  update: UserUpdateWithoutPostsDataInput;
  create: UserCreateWithoutPostsInput;
}

export interface RepositoryScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  idExternal?: Maybe<String>;
  idExternal_not?: Maybe<String>;
  idExternal_in?: Maybe<String[] | String>;
  idExternal_not_in?: Maybe<String[] | String>;
  idExternal_lt?: Maybe<String>;
  idExternal_lte?: Maybe<String>;
  idExternal_gt?: Maybe<String>;
  idExternal_gte?: Maybe<String>;
  idExternal_contains?: Maybe<String>;
  idExternal_not_contains?: Maybe<String>;
  idExternal_starts_with?: Maybe<String>;
  idExternal_not_starts_with?: Maybe<String>;
  idExternal_ends_with?: Maybe<String>;
  idExternal_not_ends_with?: Maybe<String>;
  createdAtExternal?: Maybe<DateTimeInput>;
  createdAtExternal_not?: Maybe<DateTimeInput>;
  createdAtExternal_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAtExternal_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAtExternal_lt?: Maybe<DateTimeInput>;
  createdAtExternal_lte?: Maybe<DateTimeInput>;
  createdAtExternal_gt?: Maybe<DateTimeInput>;
  createdAtExternal_gte?: Maybe<DateTimeInput>;
  updatedAtExternal?: Maybe<DateTimeInput>;
  updatedAtExternal_not?: Maybe<DateTimeInput>;
  updatedAtExternal_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAtExternal_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAtExternal_lt?: Maybe<DateTimeInput>;
  updatedAtExternal_lte?: Maybe<DateTimeInput>;
  updatedAtExternal_gt?: Maybe<DateTimeInput>;
  updatedAtExternal_gte?: Maybe<DateTimeInput>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  homepageUrl?: Maybe<String>;
  homepageUrl_not?: Maybe<String>;
  homepageUrl_in?: Maybe<String[] | String>;
  homepageUrl_not_in?: Maybe<String[] | String>;
  homepageUrl_lt?: Maybe<String>;
  homepageUrl_lte?: Maybe<String>;
  homepageUrl_gt?: Maybe<String>;
  homepageUrl_gte?: Maybe<String>;
  homepageUrl_contains?: Maybe<String>;
  homepageUrl_not_contains?: Maybe<String>;
  homepageUrl_starts_with?: Maybe<String>;
  homepageUrl_not_starts_with?: Maybe<String>;
  homepageUrl_ends_with?: Maybe<String>;
  homepageUrl_not_ends_with?: Maybe<String>;
  url?: Maybe<String>;
  url_not?: Maybe<String>;
  url_in?: Maybe<String[] | String>;
  url_not_in?: Maybe<String[] | String>;
  url_lt?: Maybe<String>;
  url_lte?: Maybe<String>;
  url_gt?: Maybe<String>;
  url_gte?: Maybe<String>;
  url_contains?: Maybe<String>;
  url_not_contains?: Maybe<String>;
  url_starts_with?: Maybe<String>;
  url_not_starts_with?: Maybe<String>;
  url_ends_with?: Maybe<String>;
  url_not_ends_with?: Maybe<String>;
  owner?: Maybe<String>;
  owner_not?: Maybe<String>;
  owner_in?: Maybe<String[] | String>;
  owner_not_in?: Maybe<String[] | String>;
  owner_lt?: Maybe<String>;
  owner_lte?: Maybe<String>;
  owner_gt?: Maybe<String>;
  owner_gte?: Maybe<String>;
  owner_contains?: Maybe<String>;
  owner_not_contains?: Maybe<String>;
  owner_starts_with?: Maybe<String>;
  owner_not_starts_with?: Maybe<String>;
  owner_ends_with?: Maybe<String>;
  owner_not_ends_with?: Maybe<String>;
  isTracked?: Maybe<Boolean>;
  isTracked_not?: Maybe<Boolean>;
  isFork?: Maybe<Boolean>;
  isFork_not?: Maybe<Boolean>;
  isLocked?: Maybe<Boolean>;
  isLocked_not?: Maybe<Boolean>;
  isPrivate?: Maybe<Boolean>;
  isPrivate_not?: Maybe<Boolean>;
  isArchived?: Maybe<Boolean>;
  isArchived_not?: Maybe<Boolean>;
  isDisabled?: Maybe<Boolean>;
  isDisabled_not?: Maybe<Boolean>;
  sshUrl?: Maybe<String>;
  sshUrl_not?: Maybe<String>;
  sshUrl_in?: Maybe<String[] | String>;
  sshUrl_not_in?: Maybe<String[] | String>;
  sshUrl_lt?: Maybe<String>;
  sshUrl_lte?: Maybe<String>;
  sshUrl_gt?: Maybe<String>;
  sshUrl_gte?: Maybe<String>;
  sshUrl_contains?: Maybe<String>;
  sshUrl_not_contains?: Maybe<String>;
  sshUrl_starts_with?: Maybe<String>;
  sshUrl_not_starts_with?: Maybe<String>;
  sshUrl_ends_with?: Maybe<String>;
  sshUrl_not_ends_with?: Maybe<String>;
  AND?: Maybe<RepositoryScalarWhereInput[] | RepositoryScalarWhereInput>;
  OR?: Maybe<RepositoryScalarWhereInput[] | RepositoryScalarWhereInput>;
  NOT?: Maybe<RepositoryScalarWhereInput[] | RepositoryScalarWhereInput>;
}

export interface PostUpdateWithoutAuthorDataInput {
  title?: Maybe<String>;
  published?: Maybe<Boolean>;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  email?: Maybe<String>;
}>;

export interface GitHubPullRequestCreateWithoutReviewThreadsInput {
  id?: Maybe<ID_Input>;
  createdAtExternal: DateTimeInput;
  publishedAt?: Maybe<DateTimeInput>;
  closedAt?: Maybe<DateTimeInput>;
  mergedAt?: Maybe<DateTimeInput>;
  assignees?: Maybe<GitHubUserCreateManyInput>;
  author: GitHubUserCreateOneInput;
  comments?: Maybe<GitHubCommentCreateManyInput>;
  commits?: Maybe<GitHubCommitCreateManyWithoutAssociatedPullRequestsInput>;
  files?: Maybe<GitHubFileDiffCreateManyInput>;
  labels?: Maybe<GitHubLabelCreateManyWithoutPullRequestsInput>;
  participants?: Maybe<GitHubUserCreateManyInput>;
  reviewRequests?: Maybe<GitHubReviewRequestCreateManyWithoutPullRequestInput>;
  reviews?: Maybe<GitHubPullRequestReviewCreateManyWithoutPullRequestInput>;
  mergedBy?: Maybe<GitHubUserCreateOneInput>;
  number: Int;
  closed: Boolean;
  isCrossRepository: Boolean;
  locked: Boolean;
  merged: Boolean;
  additions: Int;
  changedFiles: Int;
  deletions: Int;
  bodyText: String;
}

export interface NodeNode {
  id: ID_Output;
}

export interface UserPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  email: String;
  name?: String;
  password: String;
  role: Role;
  gitLogin: String;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  email: () => Promise<String>;
  name: () => Promise<String>;
  password: () => Promise<String>;
  role: () => Promise<Role>;
  gitLogin: () => Promise<String>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  email: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  role: () => Promise<AsyncIterator<Role>>;
  gitLogin: () => Promise<AsyncIterator<String>>;
}

export interface GitHubReviewThread {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  isResolved: Boolean;
}

export interface GitHubReviewThreadPromise
  extends Promise<GitHubReviewThread>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  comments: <T = FragmentableArray<GitHubComment>>(args?: {
    where?: GitHubCommentWhereInput;
    orderBy?: GitHubCommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  pullRequest: <T = GitHubPullRequestPromise>() => T;
  repository: <T = GitHubRepositoryPromise>() => T;
  resolvedBy: <T = GitHubUserPromise>() => T;
  isResolved: () => Promise<Boolean>;
}

export interface GitHubReviewThreadSubscription
  extends Promise<AsyncIterator<GitHubReviewThread>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  comments: <T = Promise<AsyncIterator<GitHubCommentSubscription>>>(args?: {
    where?: GitHubCommentWhereInput;
    orderBy?: GitHubCommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  pullRequest: <T = GitHubPullRequestSubscription>() => T;
  repository: <T = GitHubRepositorySubscription>() => T;
  resolvedBy: <T = GitHubUserSubscription>() => T;
  isResolved: () => Promise<AsyncIterator<Boolean>>;
}

export interface GitHubReviewThreadNullablePromise
  extends Promise<GitHubReviewThread | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  comments: <T = FragmentableArray<GitHubComment>>(args?: {
    where?: GitHubCommentWhereInput;
    orderBy?: GitHubCommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  pullRequest: <T = GitHubPullRequestPromise>() => T;
  repository: <T = GitHubRepositoryPromise>() => T;
  resolvedBy: <T = GitHubUserPromise>() => T;
  isResolved: () => Promise<Boolean>;
}

export interface AppKeyConnection {
  pageInfo: PageInfo;
  edges: AppKeyEdge[];
}

export interface AppKeyConnectionPromise
  extends Promise<AppKeyConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AppKeyEdge>>() => T;
  aggregate: <T = AggregateAppKeyPromise>() => T;
}

export interface AppKeyConnectionSubscription
  extends Promise<AsyncIterator<AppKeyConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AppKeyEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAppKeySubscription>() => T;
}

export interface GitHubRepository {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  updatedAtExternal: DateTimeOutput;
  hasBranchRules: Boolean;
  hasContributingGuidelines: Boolean;
  hasPullRequestTemplate: Boolean;
  hasReadMe: Boolean;
  hasWiki: Boolean;
  isArchived: Boolean;
  isDisabled: Boolean;
  isFork: Boolean;
  isLocked: Boolean;
  isPrivate: Boolean;
  description: String;
  license?: String;
  name: String;
  primaryLanguage?: String;
  sshUrl: String;
  url: String;
}

export interface GitHubRepositoryPromise
  extends Promise<GitHubRepository>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  updatedAtExternal: () => Promise<DateTimeOutput>;
  collaborators: <T = FragmentableArray<GitHubUser>>(args?: {
    where?: GitHubUserWhereInput;
    orderBy?: GitHubUserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  owner: <T = GitHubUserPromise>() => T;
  repositoryTopics: <T = FragmentableArray<GitHubTopic>>(args?: {
    where?: GitHubTopicWhereInput;
    orderBy?: GitHubTopicOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  stargazers: <T = FragmentableArray<GitHubUser>>(args?: {
    where?: GitHubUserWhereInput;
    orderBy?: GitHubUserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  watchers: <T = FragmentableArray<GitHubUser>>(args?: {
    where?: GitHubUserWhereInput;
    orderBy?: GitHubUserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  hasBranchRules: () => Promise<Boolean>;
  hasContributingGuidelines: () => Promise<Boolean>;
  hasPullRequestTemplate: () => Promise<Boolean>;
  hasReadMe: () => Promise<Boolean>;
  hasWiki: () => Promise<Boolean>;
  isArchived: () => Promise<Boolean>;
  isDisabled: () => Promise<Boolean>;
  isFork: () => Promise<Boolean>;
  isLocked: () => Promise<Boolean>;
  isPrivate: () => Promise<Boolean>;
  description: () => Promise<String>;
  license: () => Promise<String>;
  name: () => Promise<String>;
  primaryLanguage: () => Promise<String>;
  sshUrl: () => Promise<String>;
  url: () => Promise<String>;
}

export interface GitHubRepositorySubscription
  extends Promise<AsyncIterator<GitHubRepository>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAtExternal: () => Promise<AsyncIterator<DateTimeOutput>>;
  collaborators: <T = Promise<AsyncIterator<GitHubUserSubscription>>>(args?: {
    where?: GitHubUserWhereInput;
    orderBy?: GitHubUserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  owner: <T = GitHubUserSubscription>() => T;
  repositoryTopics: <
    T = Promise<AsyncIterator<GitHubTopicSubscription>>
  >(args?: {
    where?: GitHubTopicWhereInput;
    orderBy?: GitHubTopicOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  stargazers: <T = Promise<AsyncIterator<GitHubUserSubscription>>>(args?: {
    where?: GitHubUserWhereInput;
    orderBy?: GitHubUserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  watchers: <T = Promise<AsyncIterator<GitHubUserSubscription>>>(args?: {
    where?: GitHubUserWhereInput;
    orderBy?: GitHubUserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  hasBranchRules: () => Promise<AsyncIterator<Boolean>>;
  hasContributingGuidelines: () => Promise<AsyncIterator<Boolean>>;
  hasPullRequestTemplate: () => Promise<AsyncIterator<Boolean>>;
  hasReadMe: () => Promise<AsyncIterator<Boolean>>;
  hasWiki: () => Promise<AsyncIterator<Boolean>>;
  isArchived: () => Promise<AsyncIterator<Boolean>>;
  isDisabled: () => Promise<AsyncIterator<Boolean>>;
  isFork: () => Promise<AsyncIterator<Boolean>>;
  isLocked: () => Promise<AsyncIterator<Boolean>>;
  isPrivate: () => Promise<AsyncIterator<Boolean>>;
  description: () => Promise<AsyncIterator<String>>;
  license: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  primaryLanguage: () => Promise<AsyncIterator<String>>;
  sshUrl: () => Promise<AsyncIterator<String>>;
  url: () => Promise<AsyncIterator<String>>;
}

export interface GitHubRepositoryNullablePromise
  extends Promise<GitHubRepository | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  updatedAtExternal: () => Promise<DateTimeOutput>;
  collaborators: <T = FragmentableArray<GitHubUser>>(args?: {
    where?: GitHubUserWhereInput;
    orderBy?: GitHubUserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  owner: <T = GitHubUserPromise>() => T;
  repositoryTopics: <T = FragmentableArray<GitHubTopic>>(args?: {
    where?: GitHubTopicWhereInput;
    orderBy?: GitHubTopicOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  stargazers: <T = FragmentableArray<GitHubUser>>(args?: {
    where?: GitHubUserWhereInput;
    orderBy?: GitHubUserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  watchers: <T = FragmentableArray<GitHubUser>>(args?: {
    where?: GitHubUserWhereInput;
    orderBy?: GitHubUserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  hasBranchRules: () => Promise<Boolean>;
  hasContributingGuidelines: () => Promise<Boolean>;
  hasPullRequestTemplate: () => Promise<Boolean>;
  hasReadMe: () => Promise<Boolean>;
  hasWiki: () => Promise<Boolean>;
  isArchived: () => Promise<Boolean>;
  isDisabled: () => Promise<Boolean>;
  isFork: () => Promise<Boolean>;
  isLocked: () => Promise<Boolean>;
  isPrivate: () => Promise<Boolean>;
  description: () => Promise<String>;
  license: () => Promise<String>;
  name: () => Promise<String>;
  primaryLanguage: () => Promise<String>;
  sshUrl: () => Promise<String>;
  url: () => Promise<String>;
}

export interface AggregateAppKey {
  count: Int;
}

export interface AggregateAppKeyPromise
  extends Promise<AggregateAppKey>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAppKeySubscription
  extends Promise<AsyncIterator<AggregateAppKey>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AppKeyEdge {
  node: AppKey;
  cursor: String;
}

export interface AppKeyEdgePromise extends Promise<AppKeyEdge>, Fragmentable {
  node: <T = AppKeyPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AppKeyEdgeSubscription
  extends Promise<AsyncIterator<AppKeyEdge>>,
    Fragmentable {
  node: <T = AppKeySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface GitHubPullRequestReview {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  createdAtExternal: DateTimeOutput;
  updatedAtExternal: DateTimeOutput;
  submittedAt: DateTimeOutput;
  lastEditedAt: DateTimeOutput;
  publishedAt: DateTimeOutput;
  state: String;
  bodyText: String;
  url: String;
}

export interface GitHubPullRequestReviewPromise
  extends Promise<GitHubPullRequestReview>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAtExternal: () => Promise<DateTimeOutput>;
  updatedAtExternal: () => Promise<DateTimeOutput>;
  submittedAt: () => Promise<DateTimeOutput>;
  lastEditedAt: () => Promise<DateTimeOutput>;
  publishedAt: () => Promise<DateTimeOutput>;
  author: <T = GitHubUserPromise>() => T;
  comments: <T = FragmentableArray<GitHubComment>>(args?: {
    where?: GitHubCommentWhereInput;
    orderBy?: GitHubCommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  commit: <T = FragmentableArray<GitHubCommit>>(args?: {
    where?: GitHubCommitWhereInput;
    orderBy?: GitHubCommitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  pullRequest: <T = GitHubPullRequestPromise>() => T;
  state: () => Promise<String>;
  bodyText: () => Promise<String>;
  url: () => Promise<String>;
}

export interface GitHubPullRequestReviewSubscription
  extends Promise<AsyncIterator<GitHubPullRequestReview>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAtExternal: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAtExternal: () => Promise<AsyncIterator<DateTimeOutput>>;
  submittedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  lastEditedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  publishedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  author: <T = GitHubUserSubscription>() => T;
  comments: <T = Promise<AsyncIterator<GitHubCommentSubscription>>>(args?: {
    where?: GitHubCommentWhereInput;
    orderBy?: GitHubCommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  commit: <T = Promise<AsyncIterator<GitHubCommitSubscription>>>(args?: {
    where?: GitHubCommitWhereInput;
    orderBy?: GitHubCommitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  pullRequest: <T = GitHubPullRequestSubscription>() => T;
  state: () => Promise<AsyncIterator<String>>;
  bodyText: () => Promise<AsyncIterator<String>>;
  url: () => Promise<AsyncIterator<String>>;
}

export interface GitHubPullRequestReviewNullablePromise
  extends Promise<GitHubPullRequestReview | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAtExternal: () => Promise<DateTimeOutput>;
  updatedAtExternal: () => Promise<DateTimeOutput>;
  submittedAt: () => Promise<DateTimeOutput>;
  lastEditedAt: () => Promise<DateTimeOutput>;
  publishedAt: () => Promise<DateTimeOutput>;
  author: <T = GitHubUserPromise>() => T;
  comments: <T = FragmentableArray<GitHubComment>>(args?: {
    where?: GitHubCommentWhereInput;
    orderBy?: GitHubCommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  commit: <T = FragmentableArray<GitHubCommit>>(args?: {
    where?: GitHubCommitWhereInput;
    orderBy?: GitHubCommitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  pullRequest: <T = GitHubPullRequestPromise>() => T;
  state: () => Promise<String>;
  bodyText: () => Promise<String>;
  url: () => Promise<String>;
}

export interface AppKey {
  id: ID_Output;
  key: String;
  name?: String;
}

export interface AppKeyPromise extends Promise<AppKey>, Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  repositories: <T = FragmentableArray<Repository>>(args?: {
    where?: RepositoryWhereInput;
    orderBy?: RepositoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  key: () => Promise<String>;
  name: () => Promise<String>;
}

export interface AppKeySubscription
  extends Promise<AsyncIterator<AppKey>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  user: <T = UserSubscription>() => T;
  repositories: <T = Promise<AsyncIterator<RepositorySubscription>>>(args?: {
    where?: RepositoryWhereInput;
    orderBy?: RepositoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  key: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface AppKeyNullablePromise
  extends Promise<AppKey | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  repositories: <T = FragmentableArray<Repository>>(args?: {
    where?: RepositoryWhereInput;
    orderBy?: RepositoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  key: () => Promise<String>;
  name: () => Promise<String>;
}

export interface GitHubReviewRequest {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface GitHubReviewRequestPromise
  extends Promise<GitHubReviewRequest>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  pullRequest: <T = GitHubPullRequestPromise>() => T;
  requestedReviewer: <T = GitHubUserPromise>() => T;
}

export interface GitHubReviewRequestSubscription
  extends Promise<AsyncIterator<GitHubReviewRequest>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  pullRequest: <T = GitHubPullRequestSubscription>() => T;
  requestedReviewer: <T = GitHubUserSubscription>() => T;
}

export interface GitHubReviewRequestNullablePromise
  extends Promise<GitHubReviewRequest | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  pullRequest: <T = GitHubPullRequestPromise>() => T;
  requestedReviewer: <T = GitHubUserPromise>() => T;
}

export interface RepositoryEdge {
  node: Repository;
  cursor: String;
}

export interface RepositoryEdgePromise
  extends Promise<RepositoryEdge>,
    Fragmentable {
  node: <T = RepositoryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface RepositoryEdgeSubscription
  extends Promise<AsyncIterator<RepositoryEdge>>,
    Fragmentable {
  node: <T = RepositorySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface RepositoryPreviousValues {
  id: ID_Output;
  idExternal: String;
  createdAtExternal: DateTimeOutput;
  updatedAtExternal: DateTimeOutput;
  name: String;
  description: String;
  homepageUrl?: String;
  url: String;
  owner: String;
  isTracked: Boolean;
  isFork: Boolean;
  isLocked: Boolean;
  isPrivate: Boolean;
  isArchived: Boolean;
  isDisabled: Boolean;
  sshUrl?: String;
}

export interface RepositoryPreviousValuesPromise
  extends Promise<RepositoryPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  idExternal: () => Promise<String>;
  createdAtExternal: () => Promise<DateTimeOutput>;
  updatedAtExternal: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  homepageUrl: () => Promise<String>;
  url: () => Promise<String>;
  owner: () => Promise<String>;
  isTracked: () => Promise<Boolean>;
  isFork: () => Promise<Boolean>;
  isLocked: () => Promise<Boolean>;
  isPrivate: () => Promise<Boolean>;
  isArchived: () => Promise<Boolean>;
  isDisabled: () => Promise<Boolean>;
  sshUrl: () => Promise<String>;
}

export interface RepositoryPreviousValuesSubscription
  extends Promise<AsyncIterator<RepositoryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  idExternal: () => Promise<AsyncIterator<String>>;
  createdAtExternal: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAtExternal: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  homepageUrl: () => Promise<AsyncIterator<String>>;
  url: () => Promise<AsyncIterator<String>>;
  owner: () => Promise<AsyncIterator<String>>;
  isTracked: () => Promise<AsyncIterator<Boolean>>;
  isFork: () => Promise<AsyncIterator<Boolean>>;
  isLocked: () => Promise<AsyncIterator<Boolean>>;
  isPrivate: () => Promise<AsyncIterator<Boolean>>;
  isArchived: () => Promise<AsyncIterator<Boolean>>;
  isDisabled: () => Promise<AsyncIterator<Boolean>>;
  sshUrl: () => Promise<AsyncIterator<String>>;
}

export interface AggregatePost {
  count: Int;
}

export interface AggregatePostPromise
  extends Promise<AggregatePost>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePostSubscription
  extends Promise<AsyncIterator<AggregatePost>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AppKeySubscriptionPayload {
  mutation: MutationType;
  node: AppKey;
  updatedFields: String[];
  previousValues: AppKeyPreviousValues;
}

export interface AppKeySubscriptionPayloadPromise
  extends Promise<AppKeySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AppKeyPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AppKeyPreviousValuesPromise>() => T;
}

export interface AppKeySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AppKeySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AppKeySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AppKeyPreviousValuesSubscription>() => T;
}

export interface PostConnection {
  pageInfo: PageInfo;
  edges: PostEdge[];
}

export interface PostConnectionPromise
  extends Promise<PostConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PostEdge>>() => T;
  aggregate: <T = AggregatePostPromise>() => T;
}

export interface PostConnectionSubscription
  extends Promise<AsyncIterator<PostConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PostEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePostSubscription>() => T;
}

export interface AppKeyPreviousValues {
  id: ID_Output;
  key: String;
  name?: String;
}

export interface AppKeyPreviousValuesPromise
  extends Promise<AppKeyPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  key: () => Promise<String>;
  name: () => Promise<String>;
}

export interface AppKeyPreviousValuesSubscription
  extends Promise<AsyncIterator<AppKeyPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  key: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface GitHubWebhookEventEdge {
  node: GitHubWebhookEvent;
  cursor: String;
}

export interface GitHubWebhookEventEdgePromise
  extends Promise<GitHubWebhookEventEdge>,
    Fragmentable {
  node: <T = GitHubWebhookEventPromise>() => T;
  cursor: () => Promise<String>;
}

export interface GitHubWebhookEventEdgeSubscription
  extends Promise<AsyncIterator<GitHubWebhookEventEdge>>,
    Fragmentable {
  node: <T = GitHubWebhookEventSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface GitHubFileDiff {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  additions: Int;
  deletions: Int;
  filepath: String;
}

export interface GitHubFileDiffPromise
  extends Promise<GitHubFileDiff>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  additions: () => Promise<Int>;
  deletions: () => Promise<Int>;
  filepath: () => Promise<String>;
}

export interface GitHubFileDiffSubscription
  extends Promise<AsyncIterator<GitHubFileDiff>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  additions: () => Promise<AsyncIterator<Int>>;
  deletions: () => Promise<AsyncIterator<Int>>;
  filepath: () => Promise<AsyncIterator<String>>;
}

export interface GitHubFileDiffNullablePromise
  extends Promise<GitHubFileDiff | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  additions: () => Promise<Int>;
  deletions: () => Promise<Int>;
  filepath: () => Promise<String>;
}

export interface AggregateGitHubUser {
  count: Int;
}

export interface AggregateGitHubUserPromise
  extends Promise<AggregateGitHubUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGitHubUserSubscription
  extends Promise<AsyncIterator<AggregateGitHubUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface GameSubscriptionPayload {
  mutation: MutationType;
  node: Game;
  updatedFields: String[];
  previousValues: GamePreviousValues;
}

export interface GameSubscriptionPayloadPromise
  extends Promise<GameSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GamePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GamePreviousValuesPromise>() => T;
}

export interface GameSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GameSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GameSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GamePreviousValuesSubscription>() => T;
}

export interface GitHubUserConnection {
  pageInfo: PageInfo;
  edges: GitHubUserEdge[];
}

export interface GitHubUserConnectionPromise
  extends Promise<GitHubUserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GitHubUserEdge>>() => T;
  aggregate: <T = AggregateGitHubUserPromise>() => T;
}

export interface GitHubUserConnectionSubscription
  extends Promise<AsyncIterator<GitHubUserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<GitHubUserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateGitHubUserSubscription>() => T;
}

export interface GamePreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  title: String;
  type: String;
}

export interface GamePreviousValuesPromise
  extends Promise<GamePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  title: () => Promise<String>;
  type: () => Promise<String>;
}

export interface GamePreviousValuesSubscription
  extends Promise<AsyncIterator<GamePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  title: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<String>>;
}

export interface GitHubTopicEdge {
  node: GitHubTopic;
  cursor: String;
}

export interface GitHubTopicEdgePromise
  extends Promise<GitHubTopicEdge>,
    Fragmentable {
  node: <T = GitHubTopicPromise>() => T;
  cursor: () => Promise<String>;
}

export interface GitHubTopicEdgeSubscription
  extends Promise<AsyncIterator<GitHubTopicEdge>>,
    Fragmentable {
  node: <T = GitHubTopicSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface GitHubPullRequest {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  createdAtExternal: DateTimeOutput;
  publishedAt?: DateTimeOutput;
  closedAt?: DateTimeOutput;
  mergedAt?: DateTimeOutput;
  number: Int;
  closed: Boolean;
  isCrossRepository: Boolean;
  locked: Boolean;
  merged: Boolean;
  additions: Int;
  changedFiles: Int;
  deletions: Int;
  bodyText: String;
}

export interface GitHubPullRequestPromise
  extends Promise<GitHubPullRequest>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAtExternal: () => Promise<DateTimeOutput>;
  publishedAt: () => Promise<DateTimeOutput>;
  closedAt: () => Promise<DateTimeOutput>;
  mergedAt: () => Promise<DateTimeOutput>;
  assignees: <T = FragmentableArray<GitHubUser>>(args?: {
    where?: GitHubUserWhereInput;
    orderBy?: GitHubUserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  author: <T = GitHubUserPromise>() => T;
  comments: <T = FragmentableArray<GitHubComment>>(args?: {
    where?: GitHubCommentWhereInput;
    orderBy?: GitHubCommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  commits: <T = FragmentableArray<GitHubCommit>>(args?: {
    where?: GitHubCommitWhereInput;
    orderBy?: GitHubCommitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  files: <T = FragmentableArray<GitHubFileDiff>>(args?: {
    where?: GitHubFileDiffWhereInput;
    orderBy?: GitHubFileDiffOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  labels: <T = FragmentableArray<GitHubLabel>>(args?: {
    where?: GitHubLabelWhereInput;
    orderBy?: GitHubLabelOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  participants: <T = FragmentableArray<GitHubUser>>(args?: {
    where?: GitHubUserWhereInput;
    orderBy?: GitHubUserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  reviewRequests: <T = FragmentableArray<GitHubReviewRequest>>(args?: {
    where?: GitHubReviewRequestWhereInput;
    orderBy?: GitHubReviewRequestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  reviews: <T = FragmentableArray<GitHubPullRequestReview>>(args?: {
    where?: GitHubPullRequestReviewWhereInput;
    orderBy?: GitHubPullRequestReviewOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  reviewThreads: <T = FragmentableArray<GitHubReviewThread>>(args?: {
    where?: GitHubReviewThreadWhereInput;
    orderBy?: GitHubReviewThreadOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  mergedBy: <T = GitHubUserPromise>() => T;
  number: () => Promise<Int>;
  closed: () => Promise<Boolean>;
  isCrossRepository: () => Promise<Boolean>;
  locked: () => Promise<Boolean>;
  merged: () => Promise<Boolean>;
  additions: () => Promise<Int>;
  changedFiles: () => Promise<Int>;
  deletions: () => Promise<Int>;
  bodyText: () => Promise<String>;
}

export interface GitHubPullRequestSubscription
  extends Promise<AsyncIterator<GitHubPullRequest>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAtExternal: () => Promise<AsyncIterator<DateTimeOutput>>;
  publishedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  closedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  mergedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  assignees: <T = Promise<AsyncIterator<GitHubUserSubscription>>>(args?: {
    where?: GitHubUserWhereInput;
    orderBy?: GitHubUserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  author: <T = GitHubUserSubscription>() => T;
  comments: <T = Promise<AsyncIterator<GitHubCommentSubscription>>>(args?: {
    where?: GitHubCommentWhereInput;
    orderBy?: GitHubCommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  commits: <T = Promise<AsyncIterator<GitHubCommitSubscription>>>(args?: {
    where?: GitHubCommitWhereInput;
    orderBy?: GitHubCommitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  files: <T = Promise<AsyncIterator<GitHubFileDiffSubscription>>>(args?: {
    where?: GitHubFileDiffWhereInput;
    orderBy?: GitHubFileDiffOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  labels: <T = Promise<AsyncIterator<GitHubLabelSubscription>>>(args?: {
    where?: GitHubLabelWhereInput;
    orderBy?: GitHubLabelOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  participants: <T = Promise<AsyncIterator<GitHubUserSubscription>>>(args?: {
    where?: GitHubUserWhereInput;
    orderBy?: GitHubUserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  reviewRequests: <
    T = Promise<AsyncIterator<GitHubReviewRequestSubscription>>
  >(args?: {
    where?: GitHubReviewRequestWhereInput;
    orderBy?: GitHubReviewRequestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  reviews: <
    T = Promise<AsyncIterator<GitHubPullRequestReviewSubscription>>
  >(args?: {
    where?: GitHubPullRequestReviewWhereInput;
    orderBy?: GitHubPullRequestReviewOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  reviewThreads: <
    T = Promise<AsyncIterator<GitHubReviewThreadSubscription>>
  >(args?: {
    where?: GitHubReviewThreadWhereInput;
    orderBy?: GitHubReviewThreadOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  mergedBy: <T = GitHubUserSubscription>() => T;
  number: () => Promise<AsyncIterator<Int>>;
  closed: () => Promise<AsyncIterator<Boolean>>;
  isCrossRepository: () => Promise<AsyncIterator<Boolean>>;
  locked: () => Promise<AsyncIterator<Boolean>>;
  merged: () => Promise<AsyncIterator<Boolean>>;
  additions: () => Promise<AsyncIterator<Int>>;
  changedFiles: () => Promise<AsyncIterator<Int>>;
  deletions: () => Promise<AsyncIterator<Int>>;
  bodyText: () => Promise<AsyncIterator<String>>;
}

export interface GitHubPullRequestNullablePromise
  extends Promise<GitHubPullRequest | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAtExternal: () => Promise<DateTimeOutput>;
  publishedAt: () => Promise<DateTimeOutput>;
  closedAt: () => Promise<DateTimeOutput>;
  mergedAt: () => Promise<DateTimeOutput>;
  assignees: <T = FragmentableArray<GitHubUser>>(args?: {
    where?: GitHubUserWhereInput;
    orderBy?: GitHubUserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  author: <T = GitHubUserPromise>() => T;
  comments: <T = FragmentableArray<GitHubComment>>(args?: {
    where?: GitHubCommentWhereInput;
    orderBy?: GitHubCommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  commits: <T = FragmentableArray<GitHubCommit>>(args?: {
    where?: GitHubCommitWhereInput;
    orderBy?: GitHubCommitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  files: <T = FragmentableArray<GitHubFileDiff>>(args?: {
    where?: GitHubFileDiffWhereInput;
    orderBy?: GitHubFileDiffOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  labels: <T = FragmentableArray<GitHubLabel>>(args?: {
    where?: GitHubLabelWhereInput;
    orderBy?: GitHubLabelOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  participants: <T = FragmentableArray<GitHubUser>>(args?: {
    where?: GitHubUserWhereInput;
    orderBy?: GitHubUserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  reviewRequests: <T = FragmentableArray<GitHubReviewRequest>>(args?: {
    where?: GitHubReviewRequestWhereInput;
    orderBy?: GitHubReviewRequestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  reviews: <T = FragmentableArray<GitHubPullRequestReview>>(args?: {
    where?: GitHubPullRequestReviewWhereInput;
    orderBy?: GitHubPullRequestReviewOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  reviewThreads: <T = FragmentableArray<GitHubReviewThread>>(args?: {
    where?: GitHubReviewThreadWhereInput;
    orderBy?: GitHubReviewThreadOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  mergedBy: <T = GitHubUserPromise>() => T;
  number: () => Promise<Int>;
  closed: () => Promise<Boolean>;
  isCrossRepository: () => Promise<Boolean>;
  locked: () => Promise<Boolean>;
  merged: () => Promise<Boolean>;
  additions: () => Promise<Int>;
  changedFiles: () => Promise<Int>;
  deletions: () => Promise<Int>;
  bodyText: () => Promise<String>;
}

export interface AggregateGitHubReviewThread {
  count: Int;
}

export interface AggregateGitHubReviewThreadPromise
  extends Promise<AggregateGitHubReviewThread>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGitHubReviewThreadSubscription
  extends Promise<AsyncIterator<AggregateGitHubReviewThread>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface GitHubBranchSubscriptionPayload {
  mutation: MutationType;
  node: GitHubBranch;
  updatedFields: String[];
  previousValues: GitHubBranchPreviousValues;
}

export interface GitHubBranchSubscriptionPayloadPromise
  extends Promise<GitHubBranchSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GitHubBranchPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GitHubBranchPreviousValuesPromise>() => T;
}

export interface GitHubBranchSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GitHubBranchSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GitHubBranchSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GitHubBranchPreviousValuesSubscription>() => T;
}

export interface GitHubReviewThreadConnection {
  pageInfo: PageInfo;
  edges: GitHubReviewThreadEdge[];
}

export interface GitHubReviewThreadConnectionPromise
  extends Promise<GitHubReviewThreadConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GitHubReviewThreadEdge>>() => T;
  aggregate: <T = AggregateGitHubReviewThreadPromise>() => T;
}

export interface GitHubReviewThreadConnectionSubscription
  extends Promise<AsyncIterator<GitHubReviewThreadConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<GitHubReviewThreadEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateGitHubReviewThreadSubscription>() => T;
}

export interface GitHubBranchPreviousValues {
  id: ID_Output;
  name: String;
  merged?: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface GitHubBranchPreviousValuesPromise
  extends Promise<GitHubBranchPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  merged: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface GitHubBranchPreviousValuesSubscription
  extends Promise<AsyncIterator<GitHubBranchPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  merged: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface GitHubReviewRequestEdge {
  node: GitHubReviewRequest;
  cursor: String;
}

export interface GitHubReviewRequestEdgePromise
  extends Promise<GitHubReviewRequestEdge>,
    Fragmentable {
  node: <T = GitHubReviewRequestPromise>() => T;
  cursor: () => Promise<String>;
}

export interface GitHubReviewRequestEdgeSubscription
  extends Promise<AsyncIterator<GitHubReviewRequestEdge>>,
    Fragmentable {
  node: <T = GitHubReviewRequestSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface GitHubLabel {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  updatedAtExternal: DateTimeOutput;
  createdAtExternal: DateTimeOutput;
  color: String;
  description: String;
  name: String;
  url: String;
}

export interface GitHubLabelPromise extends Promise<GitHubLabel>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  updatedAtExternal: () => Promise<DateTimeOutput>;
  createdAtExternal: () => Promise<DateTimeOutput>;
  issues: <T = FragmentableArray<GitHubIssue>>(args?: {
    where?: GitHubIssueWhereInput;
    orderBy?: GitHubIssueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  pullRequests: <T = FragmentableArray<GitHubPullRequest>>(args?: {
    where?: GitHubPullRequestWhereInput;
    orderBy?: GitHubPullRequestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  color: () => Promise<String>;
  description: () => Promise<String>;
  name: () => Promise<String>;
  url: () => Promise<String>;
}

export interface GitHubLabelSubscription
  extends Promise<AsyncIterator<GitHubLabel>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAtExternal: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAtExternal: () => Promise<AsyncIterator<DateTimeOutput>>;
  issues: <T = Promise<AsyncIterator<GitHubIssueSubscription>>>(args?: {
    where?: GitHubIssueWhereInput;
    orderBy?: GitHubIssueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  pullRequests: <
    T = Promise<AsyncIterator<GitHubPullRequestSubscription>>
  >(args?: {
    where?: GitHubPullRequestWhereInput;
    orderBy?: GitHubPullRequestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  color: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  url: () => Promise<AsyncIterator<String>>;
}

export interface GitHubLabelNullablePromise
  extends Promise<GitHubLabel | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  updatedAtExternal: () => Promise<DateTimeOutput>;
  createdAtExternal: () => Promise<DateTimeOutput>;
  issues: <T = FragmentableArray<GitHubIssue>>(args?: {
    where?: GitHubIssueWhereInput;
    orderBy?: GitHubIssueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  pullRequests: <T = FragmentableArray<GitHubPullRequest>>(args?: {
    where?: GitHubPullRequestWhereInput;
    orderBy?: GitHubPullRequestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  color: () => Promise<String>;
  description: () => Promise<String>;
  name: () => Promise<String>;
  url: () => Promise<String>;
}

export interface AggregateGitHubRepository {
  count: Int;
}

export interface AggregateGitHubRepositoryPromise
  extends Promise<AggregateGitHubRepository>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGitHubRepositorySubscription
  extends Promise<AsyncIterator<AggregateGitHubRepository>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface GitHubCommentSubscriptionPayload {
  mutation: MutationType;
  node: GitHubComment;
  updatedFields: String[];
  previousValues: GitHubCommentPreviousValues;
}

export interface GitHubCommentSubscriptionPayloadPromise
  extends Promise<GitHubCommentSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GitHubCommentPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GitHubCommentPreviousValuesPromise>() => T;
}

export interface GitHubCommentSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GitHubCommentSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GitHubCommentSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GitHubCommentPreviousValuesSubscription>() => T;
}

export interface GitHubRepositoryConnection {
  pageInfo: PageInfo;
  edges: GitHubRepositoryEdge[];
}

export interface GitHubRepositoryConnectionPromise
  extends Promise<GitHubRepositoryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GitHubRepositoryEdge>>() => T;
  aggregate: <T = AggregateGitHubRepositoryPromise>() => T;
}

export interface GitHubRepositoryConnectionSubscription
  extends Promise<AsyncIterator<GitHubRepositoryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<GitHubRepositoryEdgeSubscription>>>() => T;
  aggregate: <T = AggregateGitHubRepositorySubscription>() => T;
}

export interface GitHubCommentPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  createdAtExternal: DateTimeOutput;
  bodyText: String;
  url: String;
}

export interface GitHubCommentPreviousValuesPromise
  extends Promise<GitHubCommentPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAtExternal: () => Promise<DateTimeOutput>;
  bodyText: () => Promise<String>;
  url: () => Promise<String>;
}

export interface GitHubCommentPreviousValuesSubscription
  extends Promise<AsyncIterator<GitHubCommentPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAtExternal: () => Promise<AsyncIterator<DateTimeOutput>>;
  bodyText: () => Promise<AsyncIterator<String>>;
  url: () => Promise<AsyncIterator<String>>;
}

export interface AggregateGitHubPullRequestReview {
  count: Int;
}

export interface AggregateGitHubPullRequestReviewPromise
  extends Promise<AggregateGitHubPullRequestReview>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGitHubPullRequestReviewSubscription
  extends Promise<AsyncIterator<AggregateGitHubPullRequestReview>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface GitHubIssue {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  createdAtExternal: DateTimeOutput;
  updatedAtExternal: DateTimeOutput;
  lastEditedAt: DateTimeOutput;
  bodyText: String;
  closed?: DateTimeOutput;
  locked: Boolean;
  number: Int;
  state: String;
  title: String;
  url: String;
}

export interface GitHubIssuePromise extends Promise<GitHubIssue>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAtExternal: () => Promise<DateTimeOutput>;
  updatedAtExternal: () => Promise<DateTimeOutput>;
  lastEditedAt: () => Promise<DateTimeOutput>;
  assignees: <T = FragmentableArray<GitHubUser>>(args?: {
    where?: GitHubUserWhereInput;
    orderBy?: GitHubUserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  author: <T = GitHubUserPromise>() => T;
  comments: <T = FragmentableArray<GitHubComment>>(args?: {
    where?: GitHubCommentWhereInput;
    orderBy?: GitHubCommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  labels: <T = FragmentableArray<GitHubLabel>>(args?: {
    where?: GitHubLabelWhereInput;
    orderBy?: GitHubLabelOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  participants: <T = FragmentableArray<GitHubUser>>(args?: {
    where?: GitHubUserWhereInput;
    orderBy?: GitHubUserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  bodyText: () => Promise<String>;
  closed: () => Promise<DateTimeOutput>;
  locked: () => Promise<Boolean>;
  number: () => Promise<Int>;
  state: () => Promise<String>;
  title: () => Promise<String>;
  url: () => Promise<String>;
}

export interface GitHubIssueSubscription
  extends Promise<AsyncIterator<GitHubIssue>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAtExternal: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAtExternal: () => Promise<AsyncIterator<DateTimeOutput>>;
  lastEditedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  assignees: <T = Promise<AsyncIterator<GitHubUserSubscription>>>(args?: {
    where?: GitHubUserWhereInput;
    orderBy?: GitHubUserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  author: <T = GitHubUserSubscription>() => T;
  comments: <T = Promise<AsyncIterator<GitHubCommentSubscription>>>(args?: {
    where?: GitHubCommentWhereInput;
    orderBy?: GitHubCommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  labels: <T = Promise<AsyncIterator<GitHubLabelSubscription>>>(args?: {
    where?: GitHubLabelWhereInput;
    orderBy?: GitHubLabelOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  participants: <T = Promise<AsyncIterator<GitHubUserSubscription>>>(args?: {
    where?: GitHubUserWhereInput;
    orderBy?: GitHubUserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  bodyText: () => Promise<AsyncIterator<String>>;
  closed: () => Promise<AsyncIterator<DateTimeOutput>>;
  locked: () => Promise<AsyncIterator<Boolean>>;
  number: () => Promise<AsyncIterator<Int>>;
  state: () => Promise<AsyncIterator<String>>;
  title: () => Promise<AsyncIterator<String>>;
  url: () => Promise<AsyncIterator<String>>;
}

export interface GitHubIssueNullablePromise
  extends Promise<GitHubIssue | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAtExternal: () => Promise<DateTimeOutput>;
  updatedAtExternal: () => Promise<DateTimeOutput>;
  lastEditedAt: () => Promise<DateTimeOutput>;
  assignees: <T = FragmentableArray<GitHubUser>>(args?: {
    where?: GitHubUserWhereInput;
    orderBy?: GitHubUserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  author: <T = GitHubUserPromise>() => T;
  comments: <T = FragmentableArray<GitHubComment>>(args?: {
    where?: GitHubCommentWhereInput;
    orderBy?: GitHubCommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  labels: <T = FragmentableArray<GitHubLabel>>(args?: {
    where?: GitHubLabelWhereInput;
    orderBy?: GitHubLabelOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  participants: <T = FragmentableArray<GitHubUser>>(args?: {
    where?: GitHubUserWhereInput;
    orderBy?: GitHubUserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  bodyText: () => Promise<String>;
  closed: () => Promise<DateTimeOutput>;
  locked: () => Promise<Boolean>;
  number: () => Promise<Int>;
  state: () => Promise<String>;
  title: () => Promise<String>;
  url: () => Promise<String>;
}

export interface GitHubPullRequestReviewConnection {
  pageInfo: PageInfo;
  edges: GitHubPullRequestReviewEdge[];
}

export interface GitHubPullRequestReviewConnectionPromise
  extends Promise<GitHubPullRequestReviewConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GitHubPullRequestReviewEdge>>() => T;
  aggregate: <T = AggregateGitHubPullRequestReviewPromise>() => T;
}

export interface GitHubPullRequestReviewConnectionSubscription
  extends Promise<AsyncIterator<GitHubPullRequestReviewConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<GitHubPullRequestReviewEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateGitHubPullRequestReviewSubscription>() => T;
}

export interface GitHubCommitSubscriptionPayload {
  mutation: MutationType;
  node: GitHubCommit;
  updatedFields: String[];
  previousValues: GitHubCommitPreviousValues;
}

export interface GitHubCommitSubscriptionPayloadPromise
  extends Promise<GitHubCommitSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GitHubCommitPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GitHubCommitPreviousValuesPromise>() => T;
}

export interface GitHubCommitSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GitHubCommitSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GitHubCommitSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GitHubCommitPreviousValuesSubscription>() => T;
}

export interface GitHubPullRequestEdge {
  node: GitHubPullRequest;
  cursor: String;
}

export interface GitHubPullRequestEdgePromise
  extends Promise<GitHubPullRequestEdge>,
    Fragmentable {
  node: <T = GitHubPullRequestPromise>() => T;
  cursor: () => Promise<String>;
}

export interface GitHubPullRequestEdgeSubscription
  extends Promise<AsyncIterator<GitHubPullRequestEdge>>,
    Fragmentable {
  node: <T = GitHubPullRequestSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface GitHubCommitPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  additions: Int;
  authedDate: DateTimeOutput;
  changedFiles: Int;
  commitUrl: String;
  deletions: Int;
  message: String;
  messageHeadline: String;
  pushedDate: DateTimeOutput;
  treeUrl: String;
  url: String;
}

export interface GitHubCommitPreviousValuesPromise
  extends Promise<GitHubCommitPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  additions: () => Promise<Int>;
  authedDate: () => Promise<DateTimeOutput>;
  changedFiles: () => Promise<Int>;
  commitUrl: () => Promise<String>;
  deletions: () => Promise<Int>;
  message: () => Promise<String>;
  messageHeadline: () => Promise<String>;
  pushedDate: () => Promise<DateTimeOutput>;
  treeUrl: () => Promise<String>;
  url: () => Promise<String>;
}

export interface GitHubCommitPreviousValuesSubscription
  extends Promise<AsyncIterator<GitHubCommitPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  additions: () => Promise<AsyncIterator<Int>>;
  authedDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  changedFiles: () => Promise<AsyncIterator<Int>>;
  commitUrl: () => Promise<AsyncIterator<String>>;
  deletions: () => Promise<AsyncIterator<Int>>;
  message: () => Promise<AsyncIterator<String>>;
  messageHeadline: () => Promise<AsyncIterator<String>>;
  pushedDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  treeUrl: () => Promise<AsyncIterator<String>>;
  url: () => Promise<AsyncIterator<String>>;
}

export interface AggregateGitHubLabel {
  count: Int;
}

export interface AggregateGitHubLabelPromise
  extends Promise<AggregateGitHubLabel>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGitHubLabelSubscription
  extends Promise<AsyncIterator<AggregateGitHubLabel>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface RepositorySubscriptionPayload {
  mutation: MutationType;
  node: Repository;
  updatedFields: String[];
  previousValues: RepositoryPreviousValues;
}

export interface RepositorySubscriptionPayloadPromise
  extends Promise<RepositorySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = RepositoryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RepositoryPreviousValuesPromise>() => T;
}

export interface RepositorySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RepositorySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RepositorySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RepositoryPreviousValuesSubscription>() => T;
}

export interface GitHubLabelConnection {
  pageInfo: PageInfo;
  edges: GitHubLabelEdge[];
}

export interface GitHubLabelConnectionPromise
  extends Promise<GitHubLabelConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GitHubLabelEdge>>() => T;
  aggregate: <T = AggregateGitHubLabelPromise>() => T;
}

export interface GitHubLabelConnectionSubscription
  extends Promise<AsyncIterator<GitHubLabelConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<GitHubLabelEdgeSubscription>>>() => T;
  aggregate: <T = AggregateGitHubLabelSubscription>() => T;
}

export interface GitHubFileDiffSubscriptionPayload {
  mutation: MutationType;
  node: GitHubFileDiff;
  updatedFields: String[];
  previousValues: GitHubFileDiffPreviousValues;
}

export interface GitHubFileDiffSubscriptionPayloadPromise
  extends Promise<GitHubFileDiffSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GitHubFileDiffPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GitHubFileDiffPreviousValuesPromise>() => T;
}

export interface GitHubFileDiffSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GitHubFileDiffSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GitHubFileDiffSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GitHubFileDiffPreviousValuesSubscription>() => T;
}

export interface GitHubIssueEdge {
  node: GitHubIssue;
  cursor: String;
}

export interface GitHubIssueEdgePromise
  extends Promise<GitHubIssueEdge>,
    Fragmentable {
  node: <T = GitHubIssuePromise>() => T;
  cursor: () => Promise<String>;
}

export interface GitHubIssueEdgeSubscription
  extends Promise<AsyncIterator<GitHubIssueEdge>>,
    Fragmentable {
  node: <T = GitHubIssueSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface GitHubFileDiffPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  additions: Int;
  deletions: Int;
  filepath: String;
}

export interface GitHubFileDiffPreviousValuesPromise
  extends Promise<GitHubFileDiffPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  additions: () => Promise<Int>;
  deletions: () => Promise<Int>;
  filepath: () => Promise<String>;
}

export interface GitHubFileDiffPreviousValuesSubscription
  extends Promise<AsyncIterator<GitHubFileDiffPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  additions: () => Promise<AsyncIterator<Int>>;
  deletions: () => Promise<AsyncIterator<Int>>;
  filepath: () => Promise<AsyncIterator<String>>;
}

export interface AggregateGitHubFileDiff {
  count: Int;
}

export interface AggregateGitHubFileDiffPromise
  extends Promise<AggregateGitHubFileDiff>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGitHubFileDiffSubscription
  extends Promise<AsyncIterator<AggregateGitHubFileDiff>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface GitHubComment {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  createdAtExternal: DateTimeOutput;
  bodyText: String;
  url: String;
}

export interface GitHubCommentPromise
  extends Promise<GitHubComment>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAtExternal: () => Promise<DateTimeOutput>;
  author: <T = GitHubUserPromise>() => T;
  bodyText: () => Promise<String>;
  url: () => Promise<String>;
}

export interface GitHubCommentSubscription
  extends Promise<AsyncIterator<GitHubComment>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAtExternal: () => Promise<AsyncIterator<DateTimeOutput>>;
  author: <T = GitHubUserSubscription>() => T;
  bodyText: () => Promise<AsyncIterator<String>>;
  url: () => Promise<AsyncIterator<String>>;
}

export interface GitHubCommentNullablePromise
  extends Promise<GitHubComment | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAtExternal: () => Promise<DateTimeOutput>;
  author: <T = GitHubUserPromise>() => T;
  bodyText: () => Promise<String>;
  url: () => Promise<String>;
}

export interface GitHubFileDiffConnection {
  pageInfo: PageInfo;
  edges: GitHubFileDiffEdge[];
}

export interface GitHubFileDiffConnectionPromise
  extends Promise<GitHubFileDiffConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GitHubFileDiffEdge>>() => T;
  aggregate: <T = AggregateGitHubFileDiffPromise>() => T;
}

export interface GitHubFileDiffConnectionSubscription
  extends Promise<AsyncIterator<GitHubFileDiffConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<GitHubFileDiffEdgeSubscription>>>() => T;
  aggregate: <T = AggregateGitHubFileDiffSubscription>() => T;
}

export interface GitHubIssueSubscriptionPayload {
  mutation: MutationType;
  node: GitHubIssue;
  updatedFields: String[];
  previousValues: GitHubIssuePreviousValues;
}

export interface GitHubIssueSubscriptionPayloadPromise
  extends Promise<GitHubIssueSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GitHubIssuePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GitHubIssuePreviousValuesPromise>() => T;
}

export interface GitHubIssueSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GitHubIssueSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GitHubIssueSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GitHubIssuePreviousValuesSubscription>() => T;
}

export interface GitHubCommitEdge {
  node: GitHubCommit;
  cursor: String;
}

export interface GitHubCommitEdgePromise
  extends Promise<GitHubCommitEdge>,
    Fragmentable {
  node: <T = GitHubCommitPromise>() => T;
  cursor: () => Promise<String>;
}

export interface GitHubCommitEdgeSubscription
  extends Promise<AsyncIterator<GitHubCommitEdge>>,
    Fragmentable {
  node: <T = GitHubCommitSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface GitHubIssuePreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  createdAtExternal: DateTimeOutput;
  updatedAtExternal: DateTimeOutput;
  lastEditedAt: DateTimeOutput;
  bodyText: String;
  closed?: DateTimeOutput;
  locked: Boolean;
  number: Int;
  state: String;
  title: String;
  url: String;
}

export interface GitHubIssuePreviousValuesPromise
  extends Promise<GitHubIssuePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAtExternal: () => Promise<DateTimeOutput>;
  updatedAtExternal: () => Promise<DateTimeOutput>;
  lastEditedAt: () => Promise<DateTimeOutput>;
  bodyText: () => Promise<String>;
  closed: () => Promise<DateTimeOutput>;
  locked: () => Promise<Boolean>;
  number: () => Promise<Int>;
  state: () => Promise<String>;
  title: () => Promise<String>;
  url: () => Promise<String>;
}

export interface GitHubIssuePreviousValuesSubscription
  extends Promise<AsyncIterator<GitHubIssuePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAtExternal: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAtExternal: () => Promise<AsyncIterator<DateTimeOutput>>;
  lastEditedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  bodyText: () => Promise<AsyncIterator<String>>;
  closed: () => Promise<AsyncIterator<DateTimeOutput>>;
  locked: () => Promise<AsyncIterator<Boolean>>;
  number: () => Promise<AsyncIterator<Int>>;
  state: () => Promise<AsyncIterator<String>>;
  title: () => Promise<AsyncIterator<String>>;
  url: () => Promise<AsyncIterator<String>>;
}

export interface AggregateGitHubComment {
  count: Int;
}

export interface AggregateGitHubCommentPromise
  extends Promise<AggregateGitHubComment>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGitHubCommentSubscription
  extends Promise<AsyncIterator<AggregateGitHubComment>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Post {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  title: String;
  published: Boolean;
}

export interface PostPromise extends Promise<Post>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  title: () => Promise<String>;
  published: () => Promise<Boolean>;
  author: <T = UserPromise>() => T;
}

export interface PostSubscription
  extends Promise<AsyncIterator<Post>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  title: () => Promise<AsyncIterator<String>>;
  published: () => Promise<AsyncIterator<Boolean>>;
  author: <T = UserSubscription>() => T;
}

export interface PostNullablePromise
  extends Promise<Post | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  title: () => Promise<String>;
  published: () => Promise<Boolean>;
  author: <T = UserPromise>() => T;
}

export interface GitHubCommentConnection {
  pageInfo: PageInfo;
  edges: GitHubCommentEdge[];
}

export interface GitHubCommentConnectionPromise
  extends Promise<GitHubCommentConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GitHubCommentEdge>>() => T;
  aggregate: <T = AggregateGitHubCommentPromise>() => T;
}

export interface GitHubCommentConnectionSubscription
  extends Promise<AsyncIterator<GitHubCommentConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<GitHubCommentEdgeSubscription>>>() => T;
  aggregate: <T = AggregateGitHubCommentSubscription>() => T;
}

export interface GitHubLabelSubscriptionPayload {
  mutation: MutationType;
  node: GitHubLabel;
  updatedFields: String[];
  previousValues: GitHubLabelPreviousValues;
}

export interface GitHubLabelSubscriptionPayloadPromise
  extends Promise<GitHubLabelSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GitHubLabelPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GitHubLabelPreviousValuesPromise>() => T;
}

export interface GitHubLabelSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GitHubLabelSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GitHubLabelSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GitHubLabelPreviousValuesSubscription>() => T;
}

export interface GitHubBranchEdge {
  node: GitHubBranch;
  cursor: String;
}

export interface GitHubBranchEdgePromise
  extends Promise<GitHubBranchEdge>,
    Fragmentable {
  node: <T = GitHubBranchPromise>() => T;
  cursor: () => Promise<String>;
}

export interface GitHubBranchEdgeSubscription
  extends Promise<AsyncIterator<GitHubBranchEdge>>,
    Fragmentable {
  node: <T = GitHubBranchSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface GitHubLabelPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  updatedAtExternal: DateTimeOutput;
  createdAtExternal: DateTimeOutput;
  color: String;
  description: String;
  name: String;
  url: String;
}

export interface GitHubLabelPreviousValuesPromise
  extends Promise<GitHubLabelPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  updatedAtExternal: () => Promise<DateTimeOutput>;
  createdAtExternal: () => Promise<DateTimeOutput>;
  color: () => Promise<String>;
  description: () => Promise<String>;
  name: () => Promise<String>;
  url: () => Promise<String>;
}

export interface GitHubLabelPreviousValuesSubscription
  extends Promise<AsyncIterator<GitHubLabelPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAtExternal: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAtExternal: () => Promise<AsyncIterator<DateTimeOutput>>;
  color: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  url: () => Promise<AsyncIterator<String>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface Repository {
  id: ID_Output;
  idExternal: String;
  createdAtExternal: DateTimeOutput;
  updatedAtExternal: DateTimeOutput;
  name: String;
  description: String;
  homepageUrl?: String;
  url: String;
  owner: String;
  isTracked: Boolean;
  isFork: Boolean;
  isLocked: Boolean;
  isPrivate: Boolean;
  isArchived: Boolean;
  isDisabled: Boolean;
  sshUrl?: String;
}

export interface RepositoryPromise extends Promise<Repository>, Fragmentable {
  id: () => Promise<ID_Output>;
  idExternal: () => Promise<String>;
  createdAtExternal: () => Promise<DateTimeOutput>;
  updatedAtExternal: () => Promise<DateTimeOutput>;
  addedBy: <T = UserPromise>() => T;
  name: () => Promise<String>;
  description: () => Promise<String>;
  homepageUrl: () => Promise<String>;
  url: () => Promise<String>;
  owner: () => Promise<String>;
  isTracked: () => Promise<Boolean>;
  appKey: <T = AppKeyPromise>() => T;
  isFork: () => Promise<Boolean>;
  isLocked: () => Promise<Boolean>;
  isPrivate: () => Promise<Boolean>;
  isArchived: () => Promise<Boolean>;
  isDisabled: () => Promise<Boolean>;
  sshUrl: () => Promise<String>;
  webhookEvents: <T = FragmentableArray<GitHubWebhookEvent>>(args?: {
    where?: GitHubWebhookEventWhereInput;
    orderBy?: GitHubWebhookEventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  game: <T = GamePromise>() => T;
}

export interface RepositorySubscription
  extends Promise<AsyncIterator<Repository>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  idExternal: () => Promise<AsyncIterator<String>>;
  createdAtExternal: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAtExternal: () => Promise<AsyncIterator<DateTimeOutput>>;
  addedBy: <T = UserSubscription>() => T;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  homepageUrl: () => Promise<AsyncIterator<String>>;
  url: () => Promise<AsyncIterator<String>>;
  owner: () => Promise<AsyncIterator<String>>;
  isTracked: () => Promise<AsyncIterator<Boolean>>;
  appKey: <T = AppKeySubscription>() => T;
  isFork: () => Promise<AsyncIterator<Boolean>>;
  isLocked: () => Promise<AsyncIterator<Boolean>>;
  isPrivate: () => Promise<AsyncIterator<Boolean>>;
  isArchived: () => Promise<AsyncIterator<Boolean>>;
  isDisabled: () => Promise<AsyncIterator<Boolean>>;
  sshUrl: () => Promise<AsyncIterator<String>>;
  webhookEvents: <
    T = Promise<AsyncIterator<GitHubWebhookEventSubscription>>
  >(args?: {
    where?: GitHubWebhookEventWhereInput;
    orderBy?: GitHubWebhookEventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  game: <T = GameSubscription>() => T;
}

export interface RepositoryNullablePromise
  extends Promise<Repository | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  idExternal: () => Promise<String>;
  createdAtExternal: () => Promise<DateTimeOutput>;
  updatedAtExternal: () => Promise<DateTimeOutput>;
  addedBy: <T = UserPromise>() => T;
  name: () => Promise<String>;
  description: () => Promise<String>;
  homepageUrl: () => Promise<String>;
  url: () => Promise<String>;
  owner: () => Promise<String>;
  isTracked: () => Promise<Boolean>;
  appKey: <T = AppKeyPromise>() => T;
  isFork: () => Promise<Boolean>;
  isLocked: () => Promise<Boolean>;
  isPrivate: () => Promise<Boolean>;
  isArchived: () => Promise<Boolean>;
  isDisabled: () => Promise<Boolean>;
  sshUrl: () => Promise<String>;
  webhookEvents: <T = FragmentableArray<GitHubWebhookEvent>>(args?: {
    where?: GitHubWebhookEventWhereInput;
    orderBy?: GitHubWebhookEventOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  game: <T = GamePromise>() => T;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface GitHubPullRequestSubscriptionPayload {
  mutation: MutationType;
  node: GitHubPullRequest;
  updatedFields: String[];
  previousValues: GitHubPullRequestPreviousValues;
}

export interface GitHubPullRequestSubscriptionPayloadPromise
  extends Promise<GitHubPullRequestSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GitHubPullRequestPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GitHubPullRequestPreviousValuesPromise>() => T;
}

export interface GitHubPullRequestSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GitHubPullRequestSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GitHubPullRequestSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GitHubPullRequestPreviousValuesSubscription>() => T;
}

export interface AggregateRepository {
  count: Int;
}

export interface AggregateRepositoryPromise
  extends Promise<AggregateRepository>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRepositorySubscription
  extends Promise<AsyncIterator<AggregateRepository>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface GitHubPullRequestPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  createdAtExternal: DateTimeOutput;
  publishedAt?: DateTimeOutput;
  closedAt?: DateTimeOutput;
  mergedAt?: DateTimeOutput;
  number: Int;
  closed: Boolean;
  isCrossRepository: Boolean;
  locked: Boolean;
  merged: Boolean;
  additions: Int;
  changedFiles: Int;
  deletions: Int;
  bodyText: String;
}

export interface GitHubPullRequestPreviousValuesPromise
  extends Promise<GitHubPullRequestPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAtExternal: () => Promise<DateTimeOutput>;
  publishedAt: () => Promise<DateTimeOutput>;
  closedAt: () => Promise<DateTimeOutput>;
  mergedAt: () => Promise<DateTimeOutput>;
  number: () => Promise<Int>;
  closed: () => Promise<Boolean>;
  isCrossRepository: () => Promise<Boolean>;
  locked: () => Promise<Boolean>;
  merged: () => Promise<Boolean>;
  additions: () => Promise<Int>;
  changedFiles: () => Promise<Int>;
  deletions: () => Promise<Int>;
  bodyText: () => Promise<String>;
}

export interface GitHubPullRequestPreviousValuesSubscription
  extends Promise<AsyncIterator<GitHubPullRequestPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAtExternal: () => Promise<AsyncIterator<DateTimeOutput>>;
  publishedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  closedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  mergedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  number: () => Promise<AsyncIterator<Int>>;
  closed: () => Promise<AsyncIterator<Boolean>>;
  isCrossRepository: () => Promise<AsyncIterator<Boolean>>;
  locked: () => Promise<AsyncIterator<Boolean>>;
  merged: () => Promise<AsyncIterator<Boolean>>;
  additions: () => Promise<AsyncIterator<Int>>;
  changedFiles: () => Promise<AsyncIterator<Int>>;
  deletions: () => Promise<AsyncIterator<Int>>;
  bodyText: () => Promise<AsyncIterator<String>>;
}

export interface PostEdge {
  node: Post;
  cursor: String;
}

export interface PostEdgePromise extends Promise<PostEdge>, Fragmentable {
  node: <T = PostPromise>() => T;
  cursor: () => Promise<String>;
}

export interface PostEdgeSubscription
  extends Promise<AsyncIterator<PostEdge>>,
    Fragmentable {
  node: <T = PostSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface GitHubUser {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  createdAtExternal: DateTimeOutput;
  isBountyHunter: Boolean;
  isCampusExpert: Boolean;
  isDeveloperProgramMember: Boolean;
  isEmployee: Boolean;
  isHireable: Boolean;
  isSiteAdmin: Boolean;
  isViewer: Boolean;
  url: String;
  name: String;
  login: String;
  avatarUrl: String;
  bio?: String;
  company?: String;
  email?: String;
}

export interface GitHubUserPromise extends Promise<GitHubUser>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAtExternal: () => Promise<DateTimeOutput>;
  followers: <T = FragmentableArray<GitHubUser>>(args?: {
    where?: GitHubUserWhereInput;
    orderBy?: GitHubUserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  following: <T = FragmentableArray<GitHubUser>>(args?: {
    where?: GitHubUserWhereInput;
    orderBy?: GitHubUserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  issueComments: <T = FragmentableArray<GitHubComment>>(args?: {
    where?: GitHubCommentWhereInput;
    orderBy?: GitHubCommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  issues: <T = FragmentableArray<GitHubIssue>>(args?: {
    where?: GitHubIssueWhereInput;
    orderBy?: GitHubIssueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  pullRequests: <T = FragmentableArray<GitHubPullRequest>>(args?: {
    where?: GitHubPullRequestWhereInput;
    orderBy?: GitHubPullRequestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  isBountyHunter: () => Promise<Boolean>;
  isCampusExpert: () => Promise<Boolean>;
  isDeveloperProgramMember: () => Promise<Boolean>;
  isEmployee: () => Promise<Boolean>;
  isHireable: () => Promise<Boolean>;
  isSiteAdmin: () => Promise<Boolean>;
  isViewer: () => Promise<Boolean>;
  url: () => Promise<String>;
  name: () => Promise<String>;
  login: () => Promise<String>;
  avatarUrl: () => Promise<String>;
  bio: () => Promise<String>;
  company: () => Promise<String>;
  email: () => Promise<String>;
}

export interface GitHubUserSubscription
  extends Promise<AsyncIterator<GitHubUser>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAtExternal: () => Promise<AsyncIterator<DateTimeOutput>>;
  followers: <T = Promise<AsyncIterator<GitHubUserSubscription>>>(args?: {
    where?: GitHubUserWhereInput;
    orderBy?: GitHubUserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  following: <T = Promise<AsyncIterator<GitHubUserSubscription>>>(args?: {
    where?: GitHubUserWhereInput;
    orderBy?: GitHubUserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  issueComments: <
    T = Promise<AsyncIterator<GitHubCommentSubscription>>
  >(args?: {
    where?: GitHubCommentWhereInput;
    orderBy?: GitHubCommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  issues: <T = Promise<AsyncIterator<GitHubIssueSubscription>>>(args?: {
    where?: GitHubIssueWhereInput;
    orderBy?: GitHubIssueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  pullRequests: <
    T = Promise<AsyncIterator<GitHubPullRequestSubscription>>
  >(args?: {
    where?: GitHubPullRequestWhereInput;
    orderBy?: GitHubPullRequestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  isBountyHunter: () => Promise<AsyncIterator<Boolean>>;
  isCampusExpert: () => Promise<AsyncIterator<Boolean>>;
  isDeveloperProgramMember: () => Promise<AsyncIterator<Boolean>>;
  isEmployee: () => Promise<AsyncIterator<Boolean>>;
  isHireable: () => Promise<AsyncIterator<Boolean>>;
  isSiteAdmin: () => Promise<AsyncIterator<Boolean>>;
  isViewer: () => Promise<AsyncIterator<Boolean>>;
  url: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  login: () => Promise<AsyncIterator<String>>;
  avatarUrl: () => Promise<AsyncIterator<String>>;
  bio: () => Promise<AsyncIterator<String>>;
  company: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
}

export interface GitHubUserNullablePromise
  extends Promise<GitHubUser | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAtExternal: () => Promise<DateTimeOutput>;
  followers: <T = FragmentableArray<GitHubUser>>(args?: {
    where?: GitHubUserWhereInput;
    orderBy?: GitHubUserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  following: <T = FragmentableArray<GitHubUser>>(args?: {
    where?: GitHubUserWhereInput;
    orderBy?: GitHubUserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  issueComments: <T = FragmentableArray<GitHubComment>>(args?: {
    where?: GitHubCommentWhereInput;
    orderBy?: GitHubCommentOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  issues: <T = FragmentableArray<GitHubIssue>>(args?: {
    where?: GitHubIssueWhereInput;
    orderBy?: GitHubIssueOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  pullRequests: <T = FragmentableArray<GitHubPullRequest>>(args?: {
    where?: GitHubPullRequestWhereInput;
    orderBy?: GitHubPullRequestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  isBountyHunter: () => Promise<Boolean>;
  isCampusExpert: () => Promise<Boolean>;
  isDeveloperProgramMember: () => Promise<Boolean>;
  isEmployee: () => Promise<Boolean>;
  isHireable: () => Promise<Boolean>;
  isSiteAdmin: () => Promise<Boolean>;
  isViewer: () => Promise<Boolean>;
  url: () => Promise<String>;
  name: () => Promise<String>;
  login: () => Promise<String>;
  avatarUrl: () => Promise<String>;
  bio: () => Promise<String>;
  company: () => Promise<String>;
  email: () => Promise<String>;
}

export interface GitHubWebhookEventConnection {
  pageInfo: PageInfo;
  edges: GitHubWebhookEventEdge[];
}

export interface GitHubWebhookEventConnectionPromise
  extends Promise<GitHubWebhookEventConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GitHubWebhookEventEdge>>() => T;
  aggregate: <T = AggregateGitHubWebhookEventPromise>() => T;
}

export interface GitHubWebhookEventConnectionSubscription
  extends Promise<AsyncIterator<GitHubWebhookEventConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<GitHubWebhookEventEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateGitHubWebhookEventSubscription>() => T;
}

export interface GitHubPullRequestReviewSubscriptionPayload {
  mutation: MutationType;
  node: GitHubPullRequestReview;
  updatedFields: String[];
  previousValues: GitHubPullRequestReviewPreviousValues;
}

export interface GitHubPullRequestReviewSubscriptionPayloadPromise
  extends Promise<GitHubPullRequestReviewSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GitHubPullRequestReviewPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GitHubPullRequestReviewPreviousValuesPromise>() => T;
}

export interface GitHubPullRequestReviewSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GitHubPullRequestReviewSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GitHubPullRequestReviewSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <
    T = GitHubPullRequestReviewPreviousValuesSubscription
  >() => T;
}

export interface AggregateGitHubTopic {
  count: Int;
}

export interface AggregateGitHubTopicPromise
  extends Promise<AggregateGitHubTopic>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGitHubTopicSubscription
  extends Promise<AsyncIterator<AggregateGitHubTopic>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface GitHubPullRequestReviewPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  createdAtExternal: DateTimeOutput;
  updatedAtExternal: DateTimeOutput;
  submittedAt: DateTimeOutput;
  lastEditedAt: DateTimeOutput;
  publishedAt: DateTimeOutput;
  state: String;
  bodyText: String;
  url: String;
}

export interface GitHubPullRequestReviewPreviousValuesPromise
  extends Promise<GitHubPullRequestReviewPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAtExternal: () => Promise<DateTimeOutput>;
  updatedAtExternal: () => Promise<DateTimeOutput>;
  submittedAt: () => Promise<DateTimeOutput>;
  lastEditedAt: () => Promise<DateTimeOutput>;
  publishedAt: () => Promise<DateTimeOutput>;
  state: () => Promise<String>;
  bodyText: () => Promise<String>;
  url: () => Promise<String>;
}

export interface GitHubPullRequestReviewPreviousValuesSubscription
  extends Promise<AsyncIterator<GitHubPullRequestReviewPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAtExternal: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAtExternal: () => Promise<AsyncIterator<DateTimeOutput>>;
  submittedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  lastEditedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  publishedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  state: () => Promise<AsyncIterator<String>>;
  bodyText: () => Promise<AsyncIterator<String>>;
  url: () => Promise<AsyncIterator<String>>;
}

export interface GitHubReviewThreadEdge {
  node: GitHubReviewThread;
  cursor: String;
}

export interface GitHubReviewThreadEdgePromise
  extends Promise<GitHubReviewThreadEdge>,
    Fragmentable {
  node: <T = GitHubReviewThreadPromise>() => T;
  cursor: () => Promise<String>;
}

export interface GitHubReviewThreadEdgeSubscription
  extends Promise<AsyncIterator<GitHubReviewThreadEdge>>,
    Fragmentable {
  node: <T = GitHubReviewThreadSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface GitHubCommit {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  additions: Int;
  authedDate: DateTimeOutput;
  changedFiles: Int;
  commitUrl: String;
  deletions: Int;
  message: String;
  messageHeadline: String;
  pushedDate: DateTimeOutput;
  treeUrl: String;
  url: String;
}

export interface GitHubCommitPromise
  extends Promise<GitHubCommit>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  author: <T = GitHubUserPromise>() => T;
  associatedPullRequests: <T = FragmentableArray<GitHubPullRequest>>(args?: {
    where?: GitHubPullRequestWhereInput;
    orderBy?: GitHubPullRequestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  committer: <T = GitHubUserPromise>() => T;
  additions: () => Promise<Int>;
  authedDate: () => Promise<DateTimeOutput>;
  changedFiles: () => Promise<Int>;
  commitUrl: () => Promise<String>;
  deletions: () => Promise<Int>;
  message: () => Promise<String>;
  messageHeadline: () => Promise<String>;
  pushedDate: () => Promise<DateTimeOutput>;
  treeUrl: () => Promise<String>;
  url: () => Promise<String>;
}

export interface GitHubCommitSubscription
  extends Promise<AsyncIterator<GitHubCommit>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  author: <T = GitHubUserSubscription>() => T;
  associatedPullRequests: <
    T = Promise<AsyncIterator<GitHubPullRequestSubscription>>
  >(args?: {
    where?: GitHubPullRequestWhereInput;
    orderBy?: GitHubPullRequestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  committer: <T = GitHubUserSubscription>() => T;
  additions: () => Promise<AsyncIterator<Int>>;
  authedDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  changedFiles: () => Promise<AsyncIterator<Int>>;
  commitUrl: () => Promise<AsyncIterator<String>>;
  deletions: () => Promise<AsyncIterator<Int>>;
  message: () => Promise<AsyncIterator<String>>;
  messageHeadline: () => Promise<AsyncIterator<String>>;
  pushedDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  treeUrl: () => Promise<AsyncIterator<String>>;
  url: () => Promise<AsyncIterator<String>>;
}

export interface GitHubCommitNullablePromise
  extends Promise<GitHubCommit | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  author: <T = GitHubUserPromise>() => T;
  associatedPullRequests: <T = FragmentableArray<GitHubPullRequest>>(args?: {
    where?: GitHubPullRequestWhereInput;
    orderBy?: GitHubPullRequestOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  committer: <T = GitHubUserPromise>() => T;
  additions: () => Promise<Int>;
  authedDate: () => Promise<DateTimeOutput>;
  changedFiles: () => Promise<Int>;
  commitUrl: () => Promise<String>;
  deletions: () => Promise<Int>;
  message: () => Promise<String>;
  messageHeadline: () => Promise<String>;
  pushedDate: () => Promise<DateTimeOutput>;
  treeUrl: () => Promise<String>;
  url: () => Promise<String>;
}

export interface GitHubReviewRequestConnection {
  pageInfo: PageInfo;
  edges: GitHubReviewRequestEdge[];
}

export interface GitHubReviewRequestConnectionPromise
  extends Promise<GitHubReviewRequestConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GitHubReviewRequestEdge>>() => T;
  aggregate: <T = AggregateGitHubReviewRequestPromise>() => T;
}

export interface GitHubReviewRequestConnectionSubscription
  extends Promise<AsyncIterator<GitHubReviewRequestConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<GitHubReviewRequestEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateGitHubReviewRequestSubscription>() => T;
}

export interface GitHubRepositorySubscriptionPayload {
  mutation: MutationType;
  node: GitHubRepository;
  updatedFields: String[];
  previousValues: GitHubRepositoryPreviousValues;
}

export interface GitHubRepositorySubscriptionPayloadPromise
  extends Promise<GitHubRepositorySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GitHubRepositoryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GitHubRepositoryPreviousValuesPromise>() => T;
}

export interface GitHubRepositorySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GitHubRepositorySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GitHubRepositorySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GitHubRepositoryPreviousValuesSubscription>() => T;
}

export interface User {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  email: String;
  name?: String;
  password: String;
  role: Role;
  gitLogin: String;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  posts: <T = FragmentableArray<Post>>(args?: {
    where?: PostWhereInput;
    orderBy?: PostOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  keys: <T = FragmentableArray<AppKey>>(args?: {
    where?: AppKeyWhereInput;
    orderBy?: AppKeyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  addedRepositories: <T = FragmentableArray<Repository>>(args?: {
    where?: RepositoryWhereInput;
    orderBy?: RepositoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  email: () => Promise<String>;
  name: () => Promise<String>;
  password: () => Promise<String>;
  role: () => Promise<Role>;
  gitLogin: () => Promise<String>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  posts: <T = Promise<AsyncIterator<PostSubscription>>>(args?: {
    where?: PostWhereInput;
    orderBy?: PostOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  keys: <T = Promise<AsyncIterator<AppKeySubscription>>>(args?: {
    where?: AppKeyWhereInput;
    orderBy?: AppKeyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  addedRepositories: <
    T = Promise<AsyncIterator<RepositorySubscription>>
  >(args?: {
    where?: RepositoryWhereInput;
    orderBy?: RepositoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  email: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  role: () => Promise<AsyncIterator<Role>>;
  gitLogin: () => Promise<AsyncIterator<String>>;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  posts: <T = FragmentableArray<Post>>(args?: {
    where?: PostWhereInput;
    orderBy?: PostOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  keys: <T = FragmentableArray<AppKey>>(args?: {
    where?: AppKeyWhereInput;
    orderBy?: AppKeyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  addedRepositories: <T = FragmentableArray<Repository>>(args?: {
    where?: RepositoryWhereInput;
    orderBy?: RepositoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  email: () => Promise<String>;
  name: () => Promise<String>;
  password: () => Promise<String>;
  role: () => Promise<Role>;
  gitLogin: () => Promise<String>;
}

export interface GitHubRepositoryPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  updatedAtExternal: DateTimeOutput;
  hasBranchRules: Boolean;
  hasContributingGuidelines: Boolean;
  hasPullRequestTemplate: Boolean;
  hasReadMe: Boolean;
  hasWiki: Boolean;
  isArchived: Boolean;
  isDisabled: Boolean;
  isFork: Boolean;
  isLocked: Boolean;
  isPrivate: Boolean;
  description: String;
  license?: String;
  name: String;
  primaryLanguage?: String;
  sshUrl: String;
  url: String;
}

export interface GitHubRepositoryPreviousValuesPromise
  extends Promise<GitHubRepositoryPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  updatedAtExternal: () => Promise<DateTimeOutput>;
  hasBranchRules: () => Promise<Boolean>;
  hasContributingGuidelines: () => Promise<Boolean>;
  hasPullRequestTemplate: () => Promise<Boolean>;
  hasReadMe: () => Promise<Boolean>;
  hasWiki: () => Promise<Boolean>;
  isArchived: () => Promise<Boolean>;
  isDisabled: () => Promise<Boolean>;
  isFork: () => Promise<Boolean>;
  isLocked: () => Promise<Boolean>;
  isPrivate: () => Promise<Boolean>;
  description: () => Promise<String>;
  license: () => Promise<String>;
  name: () => Promise<String>;
  primaryLanguage: () => Promise<String>;
  sshUrl: () => Promise<String>;
  url: () => Promise<String>;
}

export interface GitHubRepositoryPreviousValuesSubscription
  extends Promise<AsyncIterator<GitHubRepositoryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAtExternal: () => Promise<AsyncIterator<DateTimeOutput>>;
  hasBranchRules: () => Promise<AsyncIterator<Boolean>>;
  hasContributingGuidelines: () => Promise<AsyncIterator<Boolean>>;
  hasPullRequestTemplate: () => Promise<AsyncIterator<Boolean>>;
  hasReadMe: () => Promise<AsyncIterator<Boolean>>;
  hasWiki: () => Promise<AsyncIterator<Boolean>>;
  isArchived: () => Promise<AsyncIterator<Boolean>>;
  isDisabled: () => Promise<AsyncIterator<Boolean>>;
  isFork: () => Promise<AsyncIterator<Boolean>>;
  isLocked: () => Promise<AsyncIterator<Boolean>>;
  isPrivate: () => Promise<AsyncIterator<Boolean>>;
  description: () => Promise<AsyncIterator<String>>;
  license: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  primaryLanguage: () => Promise<AsyncIterator<String>>;
  sshUrl: () => Promise<AsyncIterator<String>>;
  url: () => Promise<AsyncIterator<String>>;
}

export interface AggregateGitHubPullRequest {
  count: Int;
}

export interface AggregateGitHubPullRequestPromise
  extends Promise<AggregateGitHubPullRequest>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGitHubPullRequestSubscription
  extends Promise<AsyncIterator<AggregateGitHubPullRequest>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface GitHubWebhookEvent {
  id: ID_Output;
  createdAt: DateTimeOutput;
  eventType: String;
  action?: String;
  sender: String;
}

export interface GitHubWebhookEventPromise
  extends Promise<GitHubWebhookEvent>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  repository: <T = RepositoryPromise>() => T;
  eventType: () => Promise<String>;
  action: () => Promise<String>;
  sender: () => Promise<String>;
}

export interface GitHubWebhookEventSubscription
  extends Promise<AsyncIterator<GitHubWebhookEvent>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  repository: <T = RepositorySubscription>() => T;
  eventType: () => Promise<AsyncIterator<String>>;
  action: () => Promise<AsyncIterator<String>>;
  sender: () => Promise<AsyncIterator<String>>;
}

export interface GitHubWebhookEventNullablePromise
  extends Promise<GitHubWebhookEvent | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  repository: <T = RepositoryPromise>() => T;
  eventType: () => Promise<String>;
  action: () => Promise<String>;
  sender: () => Promise<String>;
}

export interface GitHubLabelEdge {
  node: GitHubLabel;
  cursor: String;
}

export interface GitHubLabelEdgePromise
  extends Promise<GitHubLabelEdge>,
    Fragmentable {
  node: <T = GitHubLabelPromise>() => T;
  cursor: () => Promise<String>;
}

export interface GitHubLabelEdgeSubscription
  extends Promise<AsyncIterator<GitHubLabelEdge>>,
    Fragmentable {
  node: <T = GitHubLabelSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface GitHubReviewRequestSubscriptionPayload {
  mutation: MutationType;
  node: GitHubReviewRequest;
  updatedFields: String[];
  previousValues: GitHubReviewRequestPreviousValues;
}

export interface GitHubReviewRequestSubscriptionPayloadPromise
  extends Promise<GitHubReviewRequestSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GitHubReviewRequestPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GitHubReviewRequestPreviousValuesPromise>() => T;
}

export interface GitHubReviewRequestSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GitHubReviewRequestSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GitHubReviewRequestSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GitHubReviewRequestPreviousValuesSubscription>() => T;
}

export interface GitHubIssueConnection {
  pageInfo: PageInfo;
  edges: GitHubIssueEdge[];
}

export interface GitHubIssueConnectionPromise
  extends Promise<GitHubIssueConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GitHubIssueEdge>>() => T;
  aggregate: <T = AggregateGitHubIssuePromise>() => T;
}

export interface GitHubIssueConnectionSubscription
  extends Promise<AsyncIterator<GitHubIssueConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<GitHubIssueEdgeSubscription>>>() => T;
  aggregate: <T = AggregateGitHubIssueSubscription>() => T;
}

export interface GitHubReviewRequestPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface GitHubReviewRequestPreviousValuesPromise
  extends Promise<GitHubReviewRequestPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface GitHubReviewRequestPreviousValuesSubscription
  extends Promise<AsyncIterator<GitHubReviewRequestPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface AggregateGitHubCommit {
  count: Int;
}

export interface AggregateGitHubCommitPromise
  extends Promise<AggregateGitHubCommit>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGitHubCommitSubscription
  extends Promise<AsyncIterator<AggregateGitHubCommit>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface GitHubBranch {
  id: ID_Output;
  name: String;
  merged?: Boolean;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface GitHubBranchPromise
  extends Promise<GitHubBranch>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  commits: <T = FragmentableArray<GitHubCommit>>(args?: {
    where?: GitHubCommitWhereInput;
    orderBy?: GitHubCommitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  pullRequest: <T = GitHubPullRequestPromise>() => T;
  merged: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface GitHubBranchSubscription
  extends Promise<AsyncIterator<GitHubBranch>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  commits: <T = Promise<AsyncIterator<GitHubCommitSubscription>>>(args?: {
    where?: GitHubCommitWhereInput;
    orderBy?: GitHubCommitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  pullRequest: <T = GitHubPullRequestSubscription>() => T;
  merged: () => Promise<AsyncIterator<Boolean>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface GitHubBranchNullablePromise
  extends Promise<GitHubBranch | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  commits: <T = FragmentableArray<GitHubCommit>>(args?: {
    where?: GitHubCommitWhereInput;
    orderBy?: GitHubCommitOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  pullRequest: <T = GitHubPullRequestPromise>() => T;
  merged: () => Promise<Boolean>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface GitHubCommentEdge {
  node: GitHubComment;
  cursor: String;
}

export interface GitHubCommentEdgePromise
  extends Promise<GitHubCommentEdge>,
    Fragmentable {
  node: <T = GitHubCommentPromise>() => T;
  cursor: () => Promise<String>;
}

export interface GitHubCommentEdgeSubscription
  extends Promise<AsyncIterator<GitHubCommentEdge>>,
    Fragmentable {
  node: <T = GitHubCommentSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface GitHubReviewThreadSubscriptionPayload {
  mutation: MutationType;
  node: GitHubReviewThread;
  updatedFields: String[];
  previousValues: GitHubReviewThreadPreviousValues;
}

export interface GitHubReviewThreadSubscriptionPayloadPromise
  extends Promise<GitHubReviewThreadSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GitHubReviewThreadPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GitHubReviewThreadPreviousValuesPromise>() => T;
}

export interface GitHubReviewThreadSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GitHubReviewThreadSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GitHubReviewThreadSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GitHubReviewThreadPreviousValuesSubscription>() => T;
}

export interface GitHubBranchConnection {
  pageInfo: PageInfo;
  edges: GitHubBranchEdge[];
}

export interface GitHubBranchConnectionPromise
  extends Promise<GitHubBranchConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GitHubBranchEdge>>() => T;
  aggregate: <T = AggregateGitHubBranchPromise>() => T;
}

export interface GitHubBranchConnectionSubscription
  extends Promise<AsyncIterator<GitHubBranchConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<GitHubBranchEdgeSubscription>>>() => T;
  aggregate: <T = AggregateGitHubBranchSubscription>() => T;
}

export interface GitHubReviewThreadPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  isResolved: Boolean;
}

export interface GitHubReviewThreadPreviousValuesPromise
  extends Promise<GitHubReviewThreadPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  isResolved: () => Promise<Boolean>;
}

export interface GitHubReviewThreadPreviousValuesSubscription
  extends Promise<AsyncIterator<GitHubReviewThreadPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  isResolved: () => Promise<AsyncIterator<Boolean>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface AggregateGame {
  count: Int;
}

export interface AggregateGamePromise
  extends Promise<AggregateGame>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGameSubscription
  extends Promise<AsyncIterator<AggregateGame>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateGitHubWebhookEvent {
  count: Int;
}

export interface AggregateGitHubWebhookEventPromise
  extends Promise<AggregateGitHubWebhookEvent>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGitHubWebhookEventSubscription
  extends Promise<AsyncIterator<AggregateGitHubWebhookEvent>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface GitHubTopicSubscriptionPayload {
  mutation: MutationType;
  node: GitHubTopic;
  updatedFields: String[];
  previousValues: GitHubTopicPreviousValues;
}

export interface GitHubTopicSubscriptionPayloadPromise
  extends Promise<GitHubTopicSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GitHubTopicPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GitHubTopicPreviousValuesPromise>() => T;
}

export interface GitHubTopicSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GitHubTopicSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GitHubTopicSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GitHubTopicPreviousValuesSubscription>() => T;
}

export interface GitHubTopicConnection {
  pageInfo: PageInfo;
  edges: GitHubTopicEdge[];
}

export interface GitHubTopicConnectionPromise
  extends Promise<GitHubTopicConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GitHubTopicEdge>>() => T;
  aggregate: <T = AggregateGitHubTopicPromise>() => T;
}

export interface GitHubTopicConnectionSubscription
  extends Promise<AsyncIterator<GitHubTopicConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<GitHubTopicEdgeSubscription>>>() => T;
  aggregate: <T = AggregateGitHubTopicSubscription>() => T;
}

export interface GitHubTopicPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
}

export interface GitHubTopicPreviousValuesPromise
  extends Promise<GitHubTopicPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  name: () => Promise<String>;
}

export interface GitHubTopicPreviousValuesSubscription
  extends Promise<AsyncIterator<GitHubTopicPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface GitHubRepositoryEdge {
  node: GitHubRepository;
  cursor: String;
}

export interface GitHubRepositoryEdgePromise
  extends Promise<GitHubRepositoryEdge>,
    Fragmentable {
  node: <T = GitHubRepositoryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface GitHubRepositoryEdgeSubscription
  extends Promise<AsyncIterator<GitHubRepositoryEdge>>,
    Fragmentable {
  node: <T = GitHubRepositorySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface GameEdge {
  node: Game;
  cursor: String;
}

export interface GameEdgePromise extends Promise<GameEdge>, Fragmentable {
  node: <T = GamePromise>() => T;
  cursor: () => Promise<String>;
}

export interface GameEdgeSubscription
  extends Promise<AsyncIterator<GameEdge>>,
    Fragmentable {
  node: <T = GameSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface GitHubPullRequestConnection {
  pageInfo: PageInfo;
  edges: GitHubPullRequestEdge[];
}

export interface GitHubPullRequestConnectionPromise
  extends Promise<GitHubPullRequestConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GitHubPullRequestEdge>>() => T;
  aggregate: <T = AggregateGitHubPullRequestPromise>() => T;
}

export interface GitHubPullRequestConnectionSubscription
  extends Promise<AsyncIterator<GitHubPullRequestConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<GitHubPullRequestEdgeSubscription>>>() => T;
  aggregate: <T = AggregateGitHubPullRequestSubscription>() => T;
}

export interface GitHubUserSubscriptionPayload {
  mutation: MutationType;
  node: GitHubUser;
  updatedFields: String[];
  previousValues: GitHubUserPreviousValues;
}

export interface GitHubUserSubscriptionPayloadPromise
  extends Promise<GitHubUserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GitHubUserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GitHubUserPreviousValuesPromise>() => T;
}

export interface GitHubUserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GitHubUserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GitHubUserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GitHubUserPreviousValuesSubscription>() => T;
}

export interface GitHubFileDiffEdge {
  node: GitHubFileDiff;
  cursor: String;
}

export interface GitHubFileDiffEdgePromise
  extends Promise<GitHubFileDiffEdge>,
    Fragmentable {
  node: <T = GitHubFileDiffPromise>() => T;
  cursor: () => Promise<String>;
}

export interface GitHubFileDiffEdgeSubscription
  extends Promise<AsyncIterator<GitHubFileDiffEdge>>,
    Fragmentable {
  node: <T = GitHubFileDiffSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface GitHubUserPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  createdAtExternal: DateTimeOutput;
  isBountyHunter: Boolean;
  isCampusExpert: Boolean;
  isDeveloperProgramMember: Boolean;
  isEmployee: Boolean;
  isHireable: Boolean;
  isSiteAdmin: Boolean;
  isViewer: Boolean;
  url: String;
  name: String;
  login: String;
  avatarUrl: String;
  bio?: String;
  company?: String;
  email?: String;
}

export interface GitHubUserPreviousValuesPromise
  extends Promise<GitHubUserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  createdAtExternal: () => Promise<DateTimeOutput>;
  isBountyHunter: () => Promise<Boolean>;
  isCampusExpert: () => Promise<Boolean>;
  isDeveloperProgramMember: () => Promise<Boolean>;
  isEmployee: () => Promise<Boolean>;
  isHireable: () => Promise<Boolean>;
  isSiteAdmin: () => Promise<Boolean>;
  isViewer: () => Promise<Boolean>;
  url: () => Promise<String>;
  name: () => Promise<String>;
  login: () => Promise<String>;
  avatarUrl: () => Promise<String>;
  bio: () => Promise<String>;
  company: () => Promise<String>;
  email: () => Promise<String>;
}

export interface GitHubUserPreviousValuesSubscription
  extends Promise<AsyncIterator<GitHubUserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdAtExternal: () => Promise<AsyncIterator<DateTimeOutput>>;
  isBountyHunter: () => Promise<AsyncIterator<Boolean>>;
  isCampusExpert: () => Promise<AsyncIterator<Boolean>>;
  isDeveloperProgramMember: () => Promise<AsyncIterator<Boolean>>;
  isEmployee: () => Promise<AsyncIterator<Boolean>>;
  isHireable: () => Promise<AsyncIterator<Boolean>>;
  isSiteAdmin: () => Promise<AsyncIterator<Boolean>>;
  isViewer: () => Promise<AsyncIterator<Boolean>>;
  url: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  login: () => Promise<AsyncIterator<String>>;
  avatarUrl: () => Promise<AsyncIterator<String>>;
  bio: () => Promise<AsyncIterator<String>>;
  company: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
}

export interface AggregateGitHubBranch {
  count: Int;
}

export interface AggregateGitHubBranchPromise
  extends Promise<AggregateGitHubBranch>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGitHubBranchSubscription
  extends Promise<AsyncIterator<AggregateGitHubBranch>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface GameConnection {
  pageInfo: PageInfo;
  edges: GameEdge[];
}

export interface GameConnectionPromise
  extends Promise<GameConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GameEdge>>() => T;
  aggregate: <T = AggregateGamePromise>() => T;
}

export interface GameConnectionSubscription
  extends Promise<AsyncIterator<GameConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<GameEdgeSubscription>>>() => T;
  aggregate: <T = AggregateGameSubscription>() => T;
}

export interface RepositoryConnection {
  pageInfo: PageInfo;
  edges: RepositoryEdge[];
}

export interface RepositoryConnectionPromise
  extends Promise<RepositoryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<RepositoryEdge>>() => T;
  aggregate: <T = AggregateRepositoryPromise>() => T;
}

export interface RepositoryConnectionSubscription
  extends Promise<AsyncIterator<RepositoryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<RepositoryEdgeSubscription>>>() => T;
  aggregate: <T = AggregateRepositorySubscription>() => T;
}

export interface GitHubWebhookEventSubscriptionPayload {
  mutation: MutationType;
  node: GitHubWebhookEvent;
  updatedFields: String[];
  previousValues: GitHubWebhookEventPreviousValues;
}

export interface GitHubWebhookEventSubscriptionPayloadPromise
  extends Promise<GitHubWebhookEventSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = GitHubWebhookEventPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = GitHubWebhookEventPreviousValuesPromise>() => T;
}

export interface GitHubWebhookEventSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<GitHubWebhookEventSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = GitHubWebhookEventSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = GitHubWebhookEventPreviousValuesSubscription>() => T;
}

export interface AggregateGitHubReviewRequest {
  count: Int;
}

export interface AggregateGitHubReviewRequestPromise
  extends Promise<AggregateGitHubReviewRequest>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGitHubReviewRequestSubscription
  extends Promise<AsyncIterator<AggregateGitHubReviewRequest>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateGitHubIssue {
  count: Int;
}

export interface AggregateGitHubIssuePromise
  extends Promise<AggregateGitHubIssue>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateGitHubIssueSubscription
  extends Promise<AsyncIterator<AggregateGitHubIssue>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PostPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  title: String;
  published: Boolean;
}

export interface PostPreviousValuesPromise
  extends Promise<PostPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  title: () => Promise<String>;
  published: () => Promise<Boolean>;
}

export interface PostPreviousValuesSubscription
  extends Promise<AsyncIterator<PostPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  title: () => Promise<AsyncIterator<String>>;
  published: () => Promise<AsyncIterator<Boolean>>;
}

export interface PostSubscriptionPayload {
  mutation: MutationType;
  node: Post;
  updatedFields: String[];
  previousValues: PostPreviousValues;
}

export interface PostSubscriptionPayloadPromise
  extends Promise<PostSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PostPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PostPreviousValuesPromise>() => T;
}

export interface PostSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PostSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PostSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PostPreviousValuesSubscription>() => T;
}

export interface Game {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  title: String;
  type: String;
}

export interface GamePromise extends Promise<Game>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  repository: <T = RepositoryPromise>() => T;
  title: () => Promise<String>;
  owner: <T = UserPromise>() => T;
  type: () => Promise<String>;
}

export interface GameSubscription
  extends Promise<AsyncIterator<Game>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  repository: <T = RepositorySubscription>() => T;
  title: () => Promise<AsyncIterator<String>>;
  owner: <T = UserSubscription>() => T;
  type: () => Promise<AsyncIterator<String>>;
}

export interface GameNullablePromise
  extends Promise<Game | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  repository: <T = RepositoryPromise>() => T;
  title: () => Promise<String>;
  owner: <T = UserPromise>() => T;
  type: () => Promise<String>;
}

export interface GitHubWebhookEventPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  eventType: String;
  action?: String;
  sender: String;
}

export interface GitHubWebhookEventPreviousValuesPromise
  extends Promise<GitHubWebhookEventPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  eventType: () => Promise<String>;
  action: () => Promise<String>;
  sender: () => Promise<String>;
}

export interface GitHubWebhookEventPreviousValuesSubscription
  extends Promise<AsyncIterator<GitHubWebhookEventPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  eventType: () => Promise<AsyncIterator<String>>;
  action: () => Promise<AsyncIterator<String>>;
  sender: () => Promise<AsyncIterator<String>>;
}

export interface GitHubCommitConnection {
  pageInfo: PageInfo;
  edges: GitHubCommitEdge[];
}

export interface GitHubCommitConnectionPromise
  extends Promise<GitHubCommitConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<GitHubCommitEdge>>() => T;
  aggregate: <T = AggregateGitHubCommitPromise>() => T;
}

export interface GitHubCommitConnectionSubscription
  extends Promise<AsyncIterator<GitHubCommitConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<GitHubCommitEdgeSubscription>>>() => T;
  aggregate: <T = AggregateGitHubCommitSubscription>() => T;
}

export interface GitHubPullRequestReviewEdge {
  node: GitHubPullRequestReview;
  cursor: String;
}

export interface GitHubPullRequestReviewEdgePromise
  extends Promise<GitHubPullRequestReviewEdge>,
    Fragmentable {
  node: <T = GitHubPullRequestReviewPromise>() => T;
  cursor: () => Promise<String>;
}

export interface GitHubPullRequestReviewEdgeSubscription
  extends Promise<AsyncIterator<GitHubPullRequestReviewEdge>>,
    Fragmentable {
  node: <T = GitHubPullRequestReviewSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface GitHubUserEdge {
  node: GitHubUser;
  cursor: String;
}

export interface GitHubUserEdgePromise
  extends Promise<GitHubUserEdge>,
    Fragmentable {
  node: <T = GitHubUserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface GitHubUserEdgeSubscription
  extends Promise<AsyncIterator<GitHubUserEdge>>,
    Fragmentable {
  node: <T = GitHubUserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface GitHubTopic {
  id: ID_Output;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
  name: String;
}

export interface GitHubTopicPromise extends Promise<GitHubTopic>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  relatedTopics: <T = FragmentableArray<GitHubTopic>>(args?: {
    where?: GitHubTopicWhereInput;
    orderBy?: GitHubTopicOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  stargazers: <T = FragmentableArray<GitHubUser>>(args?: {
    where?: GitHubUserWhereInput;
    orderBy?: GitHubUserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  name: () => Promise<String>;
}

export interface GitHubTopicSubscription
  extends Promise<AsyncIterator<GitHubTopic>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  relatedTopics: <T = Promise<AsyncIterator<GitHubTopicSubscription>>>(args?: {
    where?: GitHubTopicWhereInput;
    orderBy?: GitHubTopicOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  stargazers: <T = Promise<AsyncIterator<GitHubUserSubscription>>>(args?: {
    where?: GitHubUserWhereInput;
    orderBy?: GitHubUserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  name: () => Promise<AsyncIterator<String>>;
}

export interface GitHubTopicNullablePromise
  extends Promise<GitHubTopic | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
  relatedTopics: <T = FragmentableArray<GitHubTopic>>(args?: {
    where?: GitHubTopicWhereInput;
    orderBy?: GitHubTopicOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  stargazers: <T = FragmentableArray<GitHubUser>>(args?: {
    where?: GitHubUserWhereInput;
    orderBy?: GitHubUserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  name: () => Promise<String>;
}

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

export type Long = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Role",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  },
  {
    name: "Post",
    embedded: false
  },
  {
    name: "AppKey",
    embedded: false
  },
  {
    name: "Repository",
    embedded: false
  },
  {
    name: "GitHubWebhookEvent",
    embedded: false
  },
  {
    name: "Game",
    embedded: false
  },
  {
    name: "GitHubBranch",
    embedded: false
  },
  {
    name: "GitHubComment",
    embedded: false
  },
  {
    name: "GitHubCommit",
    embedded: false
  },
  {
    name: "GitHubFileDiff",
    embedded: false
  },
  {
    name: "GitHubIssue",
    embedded: false
  },
  {
    name: "GitHubLabel",
    embedded: false
  },
  {
    name: "GitHubPullRequest",
    embedded: false
  },
  {
    name: "GitHubPullRequestReview",
    embedded: false
  },
  {
    name: "GitHubRepository",
    embedded: false
  },
  {
    name: "GitHubReviewRequest",
    embedded: false
  },
  {
    name: "GitHubReviewThread",
    embedded: false
  },
  {
    name: "GitHubTopic",
    embedded: false
  },
  {
    name: "GitHubUser",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const Prisma = makePrismaClientClass<ClientConstructor<Prisma>>({
  typeDefs,
  models,
  endpoint: `${process.env["PRISMA_ENDPOINT"]}:${process.env["PRISMA_PORT"]}`
});
export const prisma = new Prisma();
